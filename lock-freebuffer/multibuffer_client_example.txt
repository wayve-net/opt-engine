/**
 * Buffer Service Client Examples
 * Demonstrates how different systems can interact with the buffer service
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <pthread.h>

// Log entry structure for system communication
typedef struct {
    uint64_t timestamp;
    uint32_t system_id;
    uint32_t severity;
    char message[48]; // 64-byte aligned structure
} log_entry_t;

// Client connection helper
int connect_to_service(const char* host, uint16_t port) {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(port)
    };
    inet_pton(AF_INET, host, &addr.sin_addr);
    
    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sock);
        return -1;
    }
    return sock;
}

// Producer system example (e.g., Decomposer, Node Runtime)
void* producer_system(void* arg) {
    uint32_t system_id = *(uint32_t*)arg;
    int sock = connect_to_service("127.0.0.1", 8080);
    
    for (int i = 0; i < 100; i++) {
        log_entry_t entry = {
            .timestamp = i * 1000 + system_id,
            .system_id = system_id,
            .severity = i % 4,
        };
        snprintf(entry.message, sizeof(entry.message), "System%u: Event %d", system_id, i);
        
        // Send WRITE command
        send(sock, "WRITE", 8, 0);
        send(sock, &system_id, sizeof(system_id), 0);
        send(sock, &entry, sizeof(entry), 0);
        
        // Receive result
        int result;
        recv(sock, &result, sizeof(result), 0);
        
        usleep(10000); // 10ms between writes
    }
    
    close(sock);
    printf("Producer %u finished\n", system_id);
    return NULL;
}

// Central Task Repo consumer
void* consumer_system(void* arg) {
    int sock = connect_to_service("127.0.0.1", 8080);
    log_entry_t entry;
    int processed = 0;
    
    while (processed < 500) { // Process 500 total entries
        // Send READ command
        send(sock, "READ", 8, 0);
        
        // Receive result
        int result;
        recv(sock, &result, sizeof(result), 0);
        
        if (result == 0) { // BUF_SUCCESS
            recv(sock, &entry, sizeof(entry), 0);
            printf("Processed: System%u - %s\n", entry.system_id, entry.message);
            processed++;
        } else {
            usleep(1000); // Wait if empty
        }
    }
    
    close(sock);
    printf("Consumer finished processing %d entries\n", processed);
    return NULL;
}

// Main demonstration
int main() {
    printf("Starting Buffer Service Demo\n");
    
    // In a real deployment, the service would run in a separate container/process
    // For demo purposes, we'll simulate the client interactions
    
    pthread_t producers[5], consumer;
    uint32_t system_ids[] = {0, 1, 2, 3, 4}; // 5 producer systems
    
    // Start consumer
    pthread_create(&consumer, NULL, consumer_system, NULL);
    
    // Start producers
    for (int i = 0; i < 5; i++) {
        pthread_create(&producers[i], NULL, producer_system, &system_ids[i]);
    }
    
    // Wait for completion
    for (int i = 0; i < 5; i++) {
        pthread_join(producers[i], NULL);
    }
    pthread_join(consumer, NULL);
    
    printf("Demo completed successfully\n");
    return 0;
}

/* Python Client Example:
import socket
import struct

class BufferClient:
    def __init__(self, host="127.0.0.1", port=8080):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((host, port))
    
    def write(self, buffer_id, data):
        self.sock.send(b"WRITE\x00\x00\x00")
        self.sock.send(struct.pack("I", buffer_id))
        self.sock.send(data)
        result = struct.unpack("i", self.sock.recv(4))[0]
        return result == 0
    
    def read(self):
        self.sock.send(b"READ\x00\x00\x00\x00")
        result = struct.unpack("i", self.sock.recv(4))[0]
        if result == 0:
            return self.sock.recv(64)  # log_entry_t size
        return None
*/