[
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/hostname-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"strv.h\"\n\nchar* get_default_hostname_raw(void);\n\nbool valid_ldh_char(char c) _const_;\n\ntypedef enum ValidHostnameFlags {\n        VALID_HOSTNAME_TRAILING_DOT  = 1 << 0,   /* Accept trailing dot on multi-label names */\n        VALID_HOSTNAME_DOT_HOST      = 1 << 1,   /* Accept \".host\" as valid hostname */\n        VALID_HOSTNAME_QUESTION_MARK = 1 << 2,   /* Accept \"?\" as place holder for hashed machine ID value */\n} ValidHostnameFlags;\n\nbool hostname_is_valid(const char *s, ValidHostnameFlags flags) _pure_;\nchar* hostname_cleanup(char *s);\n\nbool is_localhost(const char *hostname);\n\nstatic inline bool is_gateway_hostname(const char *hostname) {\n        /* This tries to identify the valid syntaxes for the our synthetic \"gateway\" host. */\n        return STRCASE_IN_SET(hostname, \"_gateway\", \"_gateway.\");\n}\n\nstatic inline bool is_outbound_hostname(const char *hostname) {\n        /* This tries to identify the valid syntaxes for the our synthetic \"outbound\" host. */\n        return STRCASE_IN_SET(hostname, \"_outbound\", \"_outbound.\");\n}\n\nstatic inline bool is_dns_stub_hostname(const char *hostname) {\n        return STRCASE_IN_SET(hostname, \"_localdnsstub\", \"_localdnsstub.\");\n}\n\nstatic inline bool is_dns_proxy_stub_hostname(const char *hostname) {\n        return STRCASE_IN_SET(hostname, \"_localdnsproxy\", \"_localdnsproxy.\");\n}\n\nconst char* etc_hostname(void);\nconst char* etc_machine_info(void);\n\nint get_pretty_hostname(char **ret);\n\nint machine_spec_valid(const char *s);\nint split_user_at_host(const char *s, char **ret_user, char **ret_host);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "241μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "29μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "272183μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "422518μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "417549μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "64731μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "179μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1177430μs",
      "parallelizable_steps": [],
      "critical_path_length": "690152μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 2.121212121212121
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 2.121212121212121,
        "content_hash": "789f9790a4b7fa3b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/hostname-util.h"
      }
    },
    "source_hash": "109f20ae9aea"
  },
  {
    "instruction": "Decompose the network operation: TCP 3-way handshake",
    "input": "Analyze the step-by-step process for: TCP 3-way handshake",
    "output": {
      "operation": "TCP 3-way handshake",
      "category": "tcp_connection_management",
      "steps": [
        {
          "step": 1,
          "action": "Client sends SYN packet with ISN",
          "expected_time": "807297μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Server receives SYN and allocates TCB",
          "expected_time": "466μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Server sends SYN-ACK response",
          "expected_time": "902071μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Client receives SYN-ACK and sends ACK",
          "expected_time": "392132μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Connection established and ready",
          "expected_time": "558μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2102524μs",
      "parallelizable_steps": [],
      "critical_path_length": "1709926μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "tcp_connection_management",
      "complexity": "medium",
      "code_analysis": null
    },
    "source_hash": "cd443f3d055c"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-synthesize.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\nint dns_synthesize_family(uint64_t flags);\nDnsProtocol dns_synthesize_protocol(uint64_t flags);\n\nint dns_synthesize_answer(Manager *m, DnsQuestion *q, int ifindex, DnsAnswer **ret);\n\nbool shall_synthesize_own_hostname_rrs(void);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "145μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "191μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "737436μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "709005μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "79μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "150μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1447006μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "737515μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 4.285714285714286
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 4.285714285714286,
        "content_hash": "22b4cdad09766f8f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-synthesize.h"
      }
    },
    "source_hash": "7be0a560f91b"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-memfd-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <unistd.h>\n\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"memfd-util.h\"\n#include \"tests.h\"\n\nTEST(memfd_get_sealed) {\n#define TEST_TEXT \"this is some random test text we are going to write to a memfd\"\n        _cleanup_close_ int fd = memfd_new_full(\"test-memfd-get-sealed\", MFD_ALLOW_SEALING);\n        if (fd < 0) {\n                ASSERT_TRUE(ERRNO_IS_NOT_SUPPORTED(fd));\n                return (void) log_tests_skipped_errno(fd, \"Failed to create new memfd\");\n        }\n        ASSERT_OK_EQ_ERRNO(write(fd, TEST_TEXT, strlen(TEST_TEXT)), (ssize_t) strlen(TEST_TEXT));\n        /* we'll leave the read offset at the end of the memfd, the fdopen_independent() descriptors should\n         * start at the beginning anyway */\n\n        uint64_t size, new_size;\n        ASSERT_OK(memfd_get_size(fd, &size));\n        ASSERT_GE(size, (uint64_t) strlen(TEST_TEXT));\n\n        ASSERT_OK(memfd_set_size(fd, size * 2));\n        ASSERT_OK(memfd_get_size(fd, &new_size));\n        ASSERT_EQ(new_size, size * 2);\n\n        ASSERT_OK(memfd_set_size(fd, new_size / 2));\n        ASSERT_OK(memfd_get_size(fd, &size));\n        ASSERT_EQ(size, new_size / 2);\n\n        ASSERT_OK_ZERO(memfd_get_sealed(fd));\n        ASSERT_OK(memfd_set_sealed(fd));\n        ASSERT_OK_POSITIVE(memfd_get_sealed(fd));\n}\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "64μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "46μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "96275μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "82623μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "31381μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "88494μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "42621μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "95μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "341599μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "171258μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 0.6666666666666666,
        "content_hash": "822c7a159ce74b0d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-memfd-util.c"
      }
    },
    "source_hash": "eb09bc07ea13"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/override/sys/socket.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include_next <sys/socket.h>\n\n/* Supported since kernel v6.5 (5e2ff6704a275be009be8979af17c52361b79b89) */\n#ifndef SO_PASSPIDFD\n#define SO_PASSPIDFD 76\n#endif\n\n/* Supported since kernel v6.5 (7b26952a91cf65ff1cc867a2382a8964d8c0ee7d) */\n#ifndef SO_PEERPIDFD\n#define SO_PEERPIDFD 77\n#endif\n\n/* Supported since kernel v6.16 (77cbe1a6d8730a07f99f9263c2d5f2304cf5e830) */\n#ifndef SO_PASSRIGHTS\n#define SO_PASSRIGHTS 83\n#endif\n\n/* Not exposed yet. Defined in include/linux/socket.h. */\n#ifndef SOL_SCTP\n#define SOL_SCTP 132\n#endif\n\n/* Supported since kernel v2.6.17 (2c7946a7bf45ae86736ab3b43d0085e43947945c).\n * Defined since glibc-2.39 */\n#ifndef SCM_SECURITY\n#define SCM_SECURITY 0x03\n#endif\n\n/* Supported since kernel v6.5 (5e2ff6704a275be009be8979af17c52361b79b89).\n * Defined since glibc-2.39 */\n#ifndef SCM_PIDFD\n#define SCM_PIDFD 0x04\n#endif\n\n/* The maximum number of fds that SCM_RIGHTS accepts. This is an internal kernel constant defined in\n * include/net/scm.h, but very much useful for userspace too. It's documented in unix(7) these days, hence\n * should be fairly reliable to define here. */\n#ifndef SCM_MAX_FD\n#define SCM_MAX_FD 253U\n#endif\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "747μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "394826μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "566589μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "803891μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "500583μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "815μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "2267493μs",
      "parallelizable_steps": [],
      "critical_path_length": "1200279μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 4.571428571428571
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 4.571428571428571,
        "content_hash": "8a3c2a622f254cee"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/override/sys/socket.h"
      }
    },
    "source_hash": "3a8189d3fb94"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/bpf/socket-bind/socket-bind-skel.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n/* The SPDX header above is actually correct in claiming this was\n * LGPL-2.1-or-later, because it is. Since the kernel doesn't consider that\n * compatible with GPL we will claim this to be GPL however, which should be\n * fine given that LGPL-2.1-or-later downgrades to GPL if needed.\n */\n\n#include \"bpf-dlopen.h\"\n\n/* libbpf is used via dlopen(), so rename symbols */\n#define bpf_object__open_skeleton sym_bpf_object__open_skeleton\n#define bpf_object__load_skeleton sym_bpf_object__load_skeleton\n#define bpf_object__destroy_skeleton sym_bpf_object__destroy_skeleton\n\n#include \"bpf/socket-bind/socket-bind.skel.h\"\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "199μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "182μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "463489μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "154240μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "263509μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "37547μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "919201μs",
      "parallelizable_steps": [],
      "critical_path_length": "727232μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 12,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 12,
        "complexity_score": 2.5,
        "content_hash": "ad0851910e4c7942"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/bpf/socket-bind/socket-bind-skel.h"
      }
    },
    "source_hash": "39a47bebe69b"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-selinux.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/socket.h>\n\n#include \"fd-util.h\"\n#include \"log.h\"\n#include \"selinux-util.h\"\n#include \"string-util.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nstatic void test_testing(void) {\n        bool b;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n\n        mac_selinux_retest();\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n}\n\nstatic void test_loading(void) {\n        usec_t n1, n2;\n        int r;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        n1 = now(CLOCK_MONOTONIC);\n        r = mac_selinux_init();\n        n2 = now(CLOCK_MONOTONIC);\n        log_info_errno(r, \"mac_selinux_init → %d %.2fs (%m)\", r, (n2 - n1)/1e6);\n}\n\nstatic void test_cleanup(void) {\n        usec_t n1, n2;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        n1 = now(CLOCK_MONOTONIC);\n        mac_selinux_finish();\n        n2 = now(CLOCK_MONOTONIC);\n        log_info(\"mac_selinux_finish → %.2fs\", (n2 - n1)/1e6);\n}\n\nstatic void test_misc(const char* fname) {\n        _cleanup_freecon_ char *label = NULL, *label2 = NULL, *label3 = NULL, *label4 = NULL;\n        int r;\n        _cleanup_close_ int fd = -EBADF;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        r = mac_selinux_get_our_label(&label);\n        log_info_errno(r, \"mac_selinux_get_our_label → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label));\n\n        r = mac_selinux_get_create_label_from_exe(fname, &label2);\n        log_info_errno(r, \"mac_selinux_create_label_from_exe → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label2));\n\n        fd = socket(AF_INET, SOCK_DGRAM, 0);\n        assert_se(fd >= 0);\n\n        r = mac_selinux_get_child_mls_label(fd, fname, label2, &label3);\n        log_info_errno(r, \"mac_selinux_get_child_mls_label → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label3));\n\n        r = mac_selinux_get_peer_label(fd, &label4);\n        log_info_errno(r, \"mac_selinux_get_peer_label → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label4));\n}\n\nstatic void test_create_file_prepare(const char* fname) {\n        int r;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        r = mac_selinux_create_file_prepare(fname, S_IRWXU);\n        log_info_errno(r, \"mac_selinux_create_file_prepare → %d (%m)\", r);\n\n        mac_selinux_create_file_clear();\n}\n\nint main(int argc, char **argv) {\n        const char *path = SYSTEMD_BINARY_PATH;\n        if (argc >= 2)\n                path = argv[1];\n\n        test_setup_logging(LOG_DEBUG);\n\n        test_testing();\n        test_loading();\n        test_misc(path);\n        test_create_file_prepare(path);\n        test_cleanup();\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "38μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "5μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "24759μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "43835μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "36285μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "4388μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "3μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "109313μs",
      "parallelizable_steps": [],
      "critical_path_length": "61085μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 77,
        "complexity_score": 0.25974025974025977
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 77,
        "complexity_score": 0.25974025974025977,
        "content_hash": "ec983b518ebdc80f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-selinux.c"
      }
    },
    "source_hash": "062372a09294"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/dbus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"core-forward.h\"\n\nvoid bus_send_pending_reload_message(Manager *m);\n\nint bus_init_private(Manager *m);\nint bus_init_api(Manager *m);\nint bus_init_system(Manager *m);\n\nvoid bus_done_private(Manager *m);\nvoid bus_done_api(Manager *m);\nvoid bus_done_system(Manager *m);\nvoid bus_done(Manager *m);\n\nint bus_fdset_add_all(Manager *m, FDSet *fds);\n\nvoid bus_track_serialize(sd_bus_track *t, FILE *f, const char *prefix);\n\nint bus_foreach_bus(Manager *m, sd_bus_track *subscribed2, int (*send_message)(sd_bus *bus, void *userdata), void *userdata);\n\nuint64_t manager_bus_n_queued_write(Manager *m);\n\nvoid dump_bus_properties(FILE *f);\nint bus_manager_introspect_implementations(FILE *out, const char *pattern);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "206μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "162μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "78982μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "206μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "24μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "79580μs",
      "parallelizable_steps": [],
      "critical_path_length": "79212μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 17,
        "complexity_score": 1.7647058823529413
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 17,
        "complexity_score": 1.7647058823529413,
        "content_hash": "8d5a977ba93a7473"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/dbus.h"
      }
    },
    "source_hash": "3254b9733e3f"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/analyze/analyze-verify-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef struct ExecCommand ExecCommand;\ntypedef struct Unit Unit;\n\ntypedef enum RecursiveErrors {\n        RECURSIVE_ERRORS_YES,               /* Look for errors in all associated units */\n        RECURSIVE_ERRORS_NO,                /* Don't look for errors in any but the selected unit */\n        RECURSIVE_ERRORS_ONE,               /* Look for errors in the selected unit and its direct dependencies */\n        _RECURSIVE_ERRORS_MAX,\n        _RECURSIVE_ERRORS_INVALID = -EINVAL,\n} RecursiveErrors;\n\nint verify_set_unit_path(char **filenames);\nint verify_prepare_filename(const char *filename, char **ret);\nint verify_executable(Unit *u, const ExecCommand *exec, const char *root);\nint verify_units(char **filenames, RuntimeScope scope, bool check_man, bool run_generators, RecursiveErrors recursive_errors, const char *root);\n\nconst char* recursive_errors_to_string(RecursiveErrors i) _const_;\nRecursiveErrors recursive_errors_from_string(const char *s) _pure_;\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "714μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "352μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "163313μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1458μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "204μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "166041μs",
      "parallelizable_steps": [],
      "critical_path_length": "164231μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 5.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 5.0,
        "content_hash": "85a49594ce5a7bd8"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/analyze/analyze-verify-util.h"
      }
    },
    "source_hash": "23b841595a13"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-bus-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-util.h\"\n#include \"log.h\"\n#include \"tests.h\"\n\nstatic int callback(sd_bus_message *m, void *userdata, sd_bus_error *ret_error) {\n        return 1;\n}\n\nstatic void destroy_callback(void *userdata) {\n        int *n_called = userdata;\n\n        (*n_called)++;\n}\n\nTEST(destroy_callback) {\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        sd_bus_slot *slot = NULL;\n        sd_bus_destroy_t t;\n\n        int r, n_called = 0;\n\n        r = bus_open_system_watch_bind_with_description(&bus, \"test-bus\");\n        if (r < 0)\n                return (void) log_error_errno(r, \"Failed to connect to bus: %m\");\n\n        ASSERT_OK_EQ(sd_bus_request_name_async(bus, &slot, \"org.freedesktop.systemd.test-bus-util\", 0, callback, &n_called),\n                     1);\n\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, NULL), 0);\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, &t), 0);\n\n        ASSERT_EQ(sd_bus_slot_set_destroy_callback(slot, destroy_callback), 0);\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, NULL), 1);\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, &t), 1);\n        assert_se(t == destroy_callback);\n\n        /* Force cleanup so we can look at n_called */\n        ASSERT_EQ(n_called, 0);\n        sd_bus_slot_unref(slot);\n        ASSERT_EQ(n_called, 1);\n}\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "285μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "87μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "13289μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "224061μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "41884μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "252746μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "223μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "532575μs",
      "parallelizable_steps": [],
      "critical_path_length": "476894μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.4705882352941178
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.4705882352941178,
        "content_hash": "780663527faa2961"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-bus-util.c"
      }
    },
    "source_hash": "8a6a0dbb2240"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-data-fd-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include \"data-fd-util.h\"\n#include \"fd-util.h\"\n#include \"memfd-util.h\"\n#include \"process-util.h\"\n#include \"tests.h\"\n\nstatic void assert_equal_fd(int fd1, int fd2) {\n        for (;;) {\n                uint8_t a[4096], b[4096];\n                ssize_t x, y;\n\n                x = read(fd1, a, sizeof(a));\n                assert_se(x >= 0);\n\n                y = read(fd2, b, sizeof(b));\n                assert_se(y >= 0);\n\n                assert_se(x == y);\n\n                if (x == 0)\n                        break;\n\n                assert_se(memcmp(a, b, x) == 0);\n        }\n}\n\nTEST(copy_data_fd) {\n        _cleanup_close_ int fd1 = -EBADF, fd2 = -EBADF;\n        _cleanup_close_pair_ int sfd[2] = EBADF_PAIR;\n        _cleanup_(sigkill_waitp) pid_t pid = -1;\n        int r;\n\n        fd1 = open(\"/etc/fstab\", O_RDONLY|O_CLOEXEC);\n        if (fd1 >= 0) {\n\n                fd2 = copy_data_fd(fd1);\n                assert_se(fd2 >= 0);\n\n                assert_se(lseek(fd1, 0, SEEK_SET) == 0);\n                assert_equal_fd(fd1, fd2);\n        }\n\n        fd1 = safe_close(fd1);\n        fd2 = safe_close(fd2);\n\n        fd1 = memfd_new_and_seal_string(\"data\", \"hallo\");\n        assert_se(fd1 >= 0);\n\n        fd2 = copy_data_fd(fd1);\n        assert_se(fd2 >= 0);\n\n        safe_close(fd1);\n        fd1 = memfd_new_and_seal_string(\"data\", \"hallo\");\n        assert_se(fd1 >= 0);\n\n        assert_equal_fd(fd1, fd2);\n\n        fd1 = safe_close(fd1);\n        fd2 = safe_close(fd2);\n\n        assert_se(socketpair(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0, sfd) >= 0);\n\n        r = safe_fork(\"(sd-pipe)\", FORK_RESET_SIGNALS|FORK_DEATHSIG_SIGTERM|FORK_LOG, &pid);\n        assert_se(r >= 0);\n\n        if (r == 0) {\n                /* child */\n\n                sfd[0] = safe_close(sfd[0]);\n\n                for (uint64_t i = 0; i < 1536*1024 / sizeof(uint64_t); i++)\n                        assert_se(write(sfd[1], &i, sizeof(i)) == sizeof(i));\n\n                sfd[1] = safe_close(sfd[1]);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        sfd[1] = safe_close(sfd[1]);\n\n        fd2 = copy_data_fd(sfd[0]);\n        assert_se(fd2 >= 0);\n\n        uint64_t j;\n        for (uint64_t i = 0; i < 1536*1024 / sizeof(uint64_t); i++) {\n                assert_se(read(fd2, &j, sizeof(j)) == sizeof(j));\n                assert_se(i == j);\n        }\n\n        assert_se(read(fd2, &j, sizeof(j)) == 0);\n}\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "301μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "128μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "150451μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "130295μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "302190μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "74704μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "17μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "658086μs",
      "parallelizable_steps": [],
      "critical_path_length": "452959μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 69,
        "complexity_score": 1.5942028985507246
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 69,
        "complexity_score": 1.5942028985507246,
        "content_hash": "a1492e8bf811baa4"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-data-fd-util.c"
      }
    },
    "source_hash": "0d97030ac425"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-netlink/netlink-sock-diag.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <linux/sock_diag.h>\n#include <linux/unix_diag.h>\n\n#include \"netlink-internal.h\"\n#include \"netlink-sock-diag.h\"\n\nint sd_sock_diag_socket_open(sd_netlink **ret) {\n        return netlink_open_family(ret, NETLINK_SOCK_DIAG);\n}\n\nint sd_sock_diag_message_new_unix(\n                sd_netlink *sdnl,\n                sd_netlink_message **ret,\n                ino_t inode,\n                uint64_t cookie,\n                uint32_t show) {\n\n        _cleanup_(sd_netlink_message_unrefp) sd_netlink_message *m = NULL;\n        int r;\n\n        assert_return(sdnl, -EINVAL);\n        assert_return(ret, -EINVAL);\n\n        r = message_new(sdnl, &m, SOCK_DIAG_BY_FAMILY, NLM_F_REQUEST | NLM_F_ACK);\n        if (r < 0)\n                return r;\n\n        *(struct unix_diag_req*) NLMSG_DATA(m->hdr) = (struct unix_diag_req) {\n                .sdiag_family = AF_UNIX,\n                .udiag_ino = inode,\n                .udiag_show = show,\n                .udiag_cookie = {\n                        cookie & UINT32_MAX,\n                        (cookie >> 32) & UINT32_MAX,\n                },\n        };\n\n        *ret = TAKE_PTR(m);\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "8μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "60μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "42948μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "230μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "38μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "43284μs",
      "parallelizable_steps": [],
      "critical_path_length": "42994μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061,
        "content_hash": "3ad3e28c09c09667"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-netlink/netlink-sock-diag.c"
      }
    },
    "source_hash": "2e9788920ba4"
  },
  {
    "instruction": "Study and decompose this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "689μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "593μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "469μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "271399μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "279μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "391μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "273820μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "272383μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "1a35f016fa3f"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/show-status.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/* Manager status */\n\ntypedef enum ShowStatus {\n        SHOW_STATUS_NO,         /* printing of status is disabled */\n        SHOW_STATUS_ERROR,      /* only print errors */\n        SHOW_STATUS_AUTO,       /* disabled but may flip to _TEMPORARY */\n        SHOW_STATUS_TEMPORARY,  /* enabled temporarily, may flip back to _AUTO */\n        SHOW_STATUS_YES,        /* printing of status is enabled */\n        _SHOW_STATUS_MAX,\n        _SHOW_STATUS_INVALID = -EINVAL,\n} ShowStatus;\n\ntypedef enum ShowStatusFlags {\n        SHOW_STATUS_ELLIPSIZE = 1 << 0,\n        SHOW_STATUS_EPHEMERAL = 1 << 1,\n} ShowStatusFlags;\n\ntypedef enum StatusUnitFormat {\n        STATUS_UNIT_FORMAT_NAME,\n        STATUS_UNIT_FORMAT_DESCRIPTION,\n        STATUS_UNIT_FORMAT_COMBINED,\n        _STATUS_UNIT_FORMAT_MAX,\n        _STATUS_UNIT_FORMAT_INVALID = -EINVAL,\n} StatusUnitFormat;\n\nstatic inline bool show_status_on(ShowStatus s) {\n        return IN_SET(s, SHOW_STATUS_TEMPORARY, SHOW_STATUS_YES);\n}\nShowStatus show_status_from_string(const char *v) _const_;\nconst char* show_status_to_string(ShowStatus s) _pure_;\nint parse_show_status(const char *v, ShowStatus *ret);\n\nStatusUnitFormat status_unit_format_from_string(const char *v) _const_;\nconst char* status_unit_format_to_string(StatusUnitFormat s) _pure_;\n\nint status_vprintf(const char *status, ShowStatusFlags flags, const char *format, va_list ap) _printf_(3,0);\nint status_printf(const char *status, ShowStatusFlags flags, const char *format, ...) _printf_(3,4);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "761μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "786μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "425231μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "515μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "122μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "427415μs",
      "parallelizable_steps": [],
      "critical_path_length": "426114μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 4.411764705882353
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 4.411764705882353,
        "content_hash": "a8826ba129a3407e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/show-status.h"
      }
    },
    "source_hash": "af49e43fbc49"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/ipv6_route.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n *\tLinux INET6 implementation \n *\n *\tAuthors:\n *\tPedro Roque\t\t<roque@di.fc.ul.pt>\t\n *\n *\tThis program is free software; you can redistribute it and/or\n *      modify it under the terms of the GNU General Public License\n *      as published by the Free Software Foundation; either version\n *      2 of the License, or (at your option) any later version.\n */\n\n#ifndef _LINUX_IPV6_ROUTE_H\n#define _LINUX_IPV6_ROUTE_H\n\n#include <linux/types.h>\n#include <linux/in6.h>\t\t\t/* For struct in6_addr. */\n\n#define RTF_DEFAULT\t0x00010000\t/* default - learned via ND\t*/\n#define RTF_ALLONLINK\t0x00020000\t/* (deprecated and will be removed)\n\t\t\t\t\t   fallback, no routers on link */\n#define RTF_ADDRCONF\t0x00040000\t/* addrconf route - RA\t\t*/\n#define RTF_PREFIX_RT\t0x00080000\t/* A prefix only route - RA\t*/\n#define RTF_ANYCAST\t0x00100000\t/* Anycast\t\t\t*/\n\n#define RTF_NONEXTHOP\t0x00200000\t/* route with no nexthop\t*/\n#define RTF_EXPIRES\t0x00400000\n\n#define RTF_ROUTEINFO\t0x00800000\t/* route information - RA\t*/\n\n#define RTF_CACHE\t0x01000000\t/* read-only: can not be set by user */\n#define RTF_FLOW\t0x02000000\t/* flow significant route\t*/\n#define RTF_POLICY\t0x04000000\t/* policy route\t\t\t*/\n\n#define RTF_PREF(pref)\t((pref) << 27)\n#define RTF_PREF_MASK\t0x18000000\n\n#define RTF_PCPU\t0x40000000\t/* read-only: can not be set by user */\n#define RTF_LOCAL\t0x80000000\n\n\nstruct in6_rtmsg {\n\tstruct in6_addr\t\trtmsg_dst;\n\tstruct in6_addr\t\trtmsg_src;\n\tstruct in6_addr\t\trtmsg_gateway;\n\t__u32\t\t\trtmsg_type;\n\t__u16\t\t\trtmsg_dst_len;\n\t__u16\t\t\trtmsg_src_len;\n\t__u32\t\t\trtmsg_metric;\n\tunsigned long\t\trtmsg_info;\n        __u32\t\t\trtmsg_flags;\n\tint\t\t\trtmsg_ifindex;\n};\n\n#define RTMSG_NEWDEVICE\t\t0x11\n#define RTMSG_DELDEVICE\t\t0x12\n#define RTMSG_NEWROUTE\t\t0x21\n#define RTMSG_DELROUTE\t\t0x22\n\n#define IP6_RT_PRIO_USER\t1024\n#define IP6_RT_PRIO_ADDRCONF\t256\n\n#endif /* _LINUX_IPV6_ROUTE_H */\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "355μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "235μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "84935μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "520μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "84μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "86129μs",
      "parallelizable_steps": [],
      "critical_path_length": "85374μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 1.9607843137254901
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 1.9607843137254901,
        "content_hash": "e36a62c4bc6bcd8f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/ipv6_route.h"
      }
    },
    "source_hash": "01c73c53390a"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/fuzz-netdev-parser.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"fd-util.h\"\n#include \"fuzz.h\"\n#include \"networkd-manager.h\"\n#include \"tmpfile-util.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_(manager_freep) Manager *manager = NULL;\n        _cleanup_fclose_ FILE *f = NULL;\n        _cleanup_(unlink_tempfilep) char netdev_config[] = \"/tmp/fuzz-networkd.XXXXXX\";\n        _cleanup_(netdev_unrefp) NetDev *netdev = NULL;\n\n        if (outside_size_range(size, 0, 65536))\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(fmkostemp_safe(netdev_config, \"r+\", &f) == 0);\n        if (size != 0)\n                assert_se(fwrite(data, size, 1, f) == 1);\n\n        fflush(f);\n        assert_se(manager_new(&manager, /* test_mode = */ true) >= 0);\n        (void) netdev_load_one(manager, netdev_config, &netdev);\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "16μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "252μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "131262μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "62μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "219μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "131811μs",
      "parallelizable_steps": [],
      "critical_path_length": "131497μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 1.4285714285714284
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 1.4285714285714284,
        "content_hash": "d93eae1a9b3d6815"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/fuzz-netdev-parser.c"
      }
    },
    "source_hash": "46c97f6c8b06"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal-remote/journal-remote-parse.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-event.h\"\n\n#include \"alloc-util.h\"\n#include \"journal-remote-parse.h\"\n#include \"log.h\"\n\nRemoteSource* source_free(RemoteSource *source) {\n        if (!source)\n                return NULL;\n\n        journal_importer_cleanup(&source->importer);\n\n        log_trace(\"Writer ref count %u\", source->writer->n_ref);\n        writer_unref(source->writer);\n\n        sd_event_source_unref(source->event);\n        sd_event_source_unref(source->buffer_event);\n\n        free(source->encoding);\n        return mfree(source);\n}\n\n/**\n * Initialize zero-filled source with given values. On success, takes\n * ownership of fd, name, and writer, otherwise does not touch them.\n */\nRemoteSource* source_new(int fd, bool passive_fd, char *name, Writer *writer) {\n        RemoteSource *source;\n\n        log_debug(\"Creating source for %sfd:%d (%s)\",\n                  passive_fd ? \"passive \" : \"\", fd, name);\n\n        assert(fd >= 0);\n\n        source = new0(RemoteSource, 1);\n        if (!source)\n                return NULL;\n\n        source->importer = JOURNAL_IMPORTER_MAKE(fd);\n        source->importer.passive_fd = passive_fd;\n        source->importer.name = name;\n\n        source->writer = writer;\n\n        return source;\n}\n\nint process_source(RemoteSource *source, JournalFileFlags file_flags) {\n        int r;\n\n        assert(source);\n        assert(source->writer);\n\n        r = journal_importer_process_data(&source->importer);\n        if (r <= 0)\n                return r;\n\n        /* We have a full event */\n        log_trace(\"Received full event from source@%p fd:%d (%s)\",\n                  source, source->importer.fd, source->importer.name);\n\n        if (source->importer.iovw.count == 0) {\n                log_warning(\"Entry with no payload, skipping\");\n                goto freeing;\n        }\n\n        assert(source->importer.iovw.iovec);\n\n        r = writer_write(source->writer,\n                         &source->importer.iovw,\n                         &source->importer.ts,\n                         &source->importer.boot_id,\n                         file_flags);\n        if (IN_SET(r, -EBADMSG, -EADDRNOTAVAIL)) {\n                log_warning_errno(r, \"Entry is invalid, ignoring.\");\n                r = 0;\n        } else if (r < 0)\n                log_error_errno(r, \"Failed to write entry of %zu bytes: %m\",\n                                iovw_size(&source->importer.iovw));\n        else\n                r = 1;\n\n freeing:\n        journal_importer_drop_iovw(&source->importer);\n        return r;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "333μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "14μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "92594μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "451μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "337μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "93729μs",
      "parallelizable_steps": [],
      "critical_path_length": "93264μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 66,
        "complexity_score": 1.9696969696969697
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 66,
        "complexity_score": 1.9696969696969697,
        "content_hash": "f86e808ac6d8915d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal-remote/journal-remote-parse.c"
      }
    },
    "source_hash": "bc4e3f7819d0"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-conf.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/***\n  Copyright © 2014 Vinay Kulkarni <kulkarniv@vmware.com>\n ***/\n\n#include \"conf-parser.h\"\n#include \"networkd-address-label.h\"\n#include \"networkd-conf.h\"\n#include \"networkd-manager.h\"\n#include \"networkd-speed-meter.h\"\n\nint manager_parse_config_file(Manager *m) {\n        int r;\n\n        assert(m);\n\n        r = config_parse_standard_file_with_dropins(\n                        \"systemd/networkd.conf\",\n                        \"Network\\0\"\n                        \"IPv6AcceptRA\\0\"\n                        \"IPv6AddressLabel\\0\"\n                        \"DHCPv4\\0\"\n                        \"DHCPv6\\0\"\n                        \"DHCPServer\\0\"\n                        \"DHCP\\0\",\n                        config_item_perf_lookup, networkd_gperf_lookup,\n                        CONFIG_PARSE_WARN,\n                        /* userdata= */ m);\n        if (r < 0)\n                return r;\n\n        if (m->use_speed_meter && m->speed_meter_interval_usec < SPEED_METER_MINIMUM_TIME_INTERVAL) {\n                log_warning(\"SpeedMeterIntervalSec= is too small, using %s.\",\n                            FORMAT_TIMESPAN(SPEED_METER_MINIMUM_TIME_INTERVAL, USEC_PER_SEC));\n                m->speed_meter_interval_usec = SPEED_METER_MINIMUM_TIME_INTERVAL;\n        }\n\n        manager_drop_invalid_address_labels(m);\n\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "174μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "129μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "132364μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "401μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "192μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "133260μs",
      "parallelizable_steps": [],
      "critical_path_length": "132730μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.4705882352941178
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.4705882352941178,
        "content_hash": "e58f9c07b38187d1"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-conf.c"
      }
    },
    "source_hash": "19ff81113030"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/uki.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <stdbool.h>\n\n/* List of PE sections that have special meaning for us in unified kernels. This is the canonical order in\n * which we measure the sections into TPM PCR 11. PLEASE DO NOT REORDER! */\ntypedef enum UnifiedSection {\n        UNIFIED_SECTION_LINUX,\n        UNIFIED_SECTION_OSREL,\n        UNIFIED_SECTION_CMDLINE,\n        UNIFIED_SECTION_INITRD,\n        UNIFIED_SECTION_UCODE,\n        UNIFIED_SECTION_SPLASH,\n        UNIFIED_SECTION_DTB,\n        UNIFIED_SECTION_UNAME,\n        UNIFIED_SECTION_SBAT,\n        UNIFIED_SECTION_PCRSIG,\n        UNIFIED_SECTION_PCRPKEY,\n        UNIFIED_SECTION_PROFILE,\n        UNIFIED_SECTION_DTBAUTO,\n        UNIFIED_SECTION_HWIDS,\n        UNIFIED_SECTION_EFIFW,\n        _UNIFIED_SECTION_MAX,\n} UnifiedSection;\n\nextern const char* const unified_sections[_UNIFIED_SECTION_MAX + 1];\n\nstatic inline bool unified_section_measure(UnifiedSection section) {\n        /* Don't include the PCR signature in the PCR measurements, since they sign the expected result of\n         * the measurement, and hence shouldn't be input to it. */\n        return section >= 0 && section < _UNIFIED_SECTION_MAX && section != UNIFIED_SECTION_PCRSIG;\n}\n\n/* Max number of profiles per UKI */\n#define UNIFIED_PROFILES_MAX 256U\n\n/* The native PE machine type, if known, for a full list see:\n * https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types */\n#ifndef _IMAGE_FILE_MACHINE_NATIVE\n#  if defined(__x86_64__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x8664)\n#  elif defined(__i386__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x014c)\n#  elif defined(__ia64__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x0200)\n#  elif defined(__aarch64__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0xaa64)\n#  elif defined(__arm__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x01c0)\n#  elif defined(__riscv)\n#    if __SIZEOF_POINTER__ == 4\n#      define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x5032)\n#    elif __SIZEOF_POINTER__ == 8\n#      define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x5064)\n#    endif\n#  endif\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1365μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1965390μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2462μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "3035μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "562748μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1743μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "2536743μs",
      "parallelizable_steps": [],
      "critical_path_length": "1970168μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 8.461538461538462
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 8.461538461538462,
        "content_hash": "9f118bcb918cd7fa"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/uki.h"
      }
    },
    "source_hash": "3c445eeb444f"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp-packet.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"dhcp-protocol.h\"\n#include \"forward.h\"\n\nint bootp_message_init(\n                DHCPMessage *message,\n                uint8_t op,\n                uint32_t xid,\n                uint16_t arp_type,\n                uint8_t hlen,\n                const uint8_t *chaddr);\n\nint dhcp_message_init(\n                DHCPMessage *message,\n                uint8_t op,\n                uint32_t xid,\n                uint16_t arp_type,\n                uint8_t hlen,\n                const uint8_t *chaddr,\n                uint8_t type,\n                size_t optlen,\n                size_t *ret_optoffset);\n\nuint16_t dhcp_packet_checksum(uint8_t *buf, size_t len);\n\nvoid dhcp_packet_append_ip_headers(\n                DHCPPacket *packet,\n                be32_t source_addr,\n                uint16_t source,\n                be32_t destination_addr,\n                uint16_t destination,\n                uint16_t len,\n                int ip_service_type);\n\nint dhcp_packet_verify_headers(DHCPPacket *packet, size_t len, bool checksum, uint16_t port);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "36μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "61μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "39211μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "180μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "179μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "39667μs",
      "parallelizable_steps": [],
      "critical_path_length": "39426μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 0.967741935483871
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 0.967741935483871,
        "content_hash": "c3c6cf1e99bfbc9a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp-packet.h"
      }
    },
    "source_hash": "abad748ada0d"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-search-domain.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-forward.h\"\n\ntypedef enum DnsSearchDomainType {\n        DNS_SEARCH_DOMAIN_SYSTEM,\n        DNS_SEARCH_DOMAIN_LINK,\n        DNS_SEARCH_DOMAIN_DELEGATE,\n} DnsSearchDomainType;\n\ntypedef struct DnsSearchDomain {\n        Manager *manager;\n\n        unsigned n_ref;\n\n        DnsSearchDomainType type;\n        Link *link;\n        DnsDelegate *delegate;\n\n        char *name;\n\n        bool marked:1;\n        bool route_only:1;\n\n        bool linked:1;\n        LIST_FIELDS(DnsSearchDomain, domains);\n} DnsSearchDomain;\n\nint dns_search_domain_new(\n                Manager *m,\n                DnsSearchDomain **ret,\n                DnsSearchDomainType type,\n                Link *link,\n                DnsDelegate *delegate,\n                const char *name);\n\nDnsSearchDomain* dns_search_domain_ref(DnsSearchDomain *d);\nDnsSearchDomain* dns_search_domain_unref(DnsSearchDomain *d);\n\nvoid dns_search_domain_unlink(DnsSearchDomain *d);\nvoid dns_search_domain_move_back_and_unmark(DnsSearchDomain *d);\n\nvoid dns_search_domain_unlink_all(DnsSearchDomain *first);\nbool dns_search_domain_unlink_marked(DnsSearchDomain *first);\nvoid dns_search_domain_mark_all(DnsSearchDomain *first);\n\nint dns_search_domain_find(DnsSearchDomain *first, const char *name, DnsSearchDomain **ret);\n\nstatic inline const char* DNS_SEARCH_DOMAIN_NAME(DnsSearchDomain *d) {\n        return d ? d->name : NULL;\n}\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnsSearchDomain*, dns_search_domain_unref);\n\nint dns_search_domain_dump_to_json(DnsSearchDomain *domain, sd_json_variant **ret);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "65μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "13μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "95906μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "58015μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "49μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "21μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "154069μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "95955μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805,
        "content_hash": "d493a1b0c44289fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-search-domain.h"
      }
    },
    "source_hash": "71c4b45adbde"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-bus/bus-kernel.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n#define MEMFD_CACHE_MAX 32\n\n/* When we cache a memfd block for reuse, we will truncate blocks\n * longer than this in order not to keep too much data around. */\n#define MEMFD_CACHE_ITEM_SIZE_MAX (128*1024)\n\n/* This determines at which minimum size we prefer sending memfds over\n * sending vectors */\n#define MEMFD_MIN_SIZE (512*1024)\n\nstruct memfd_cache {\n        int fd;\n        void *address;\n        size_t mapped;\n        size_t allocated;\n};\n\nvoid close_and_munmap(int fd, void *address, size_t size);\nvoid bus_flush_memfd(sd_bus *bus);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "281μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "171μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "48104μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "27μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "271μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "48854μs",
      "parallelizable_steps": [],
      "critical_path_length": "48656μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 1.6666666666666665
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 1.6666666666666665,
        "content_hash": "e6da41bfd1ca9627"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-bus/bus-kernel.h"
      }
    },
    "source_hash": "e5eac6c474e5"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/test-networkd-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"networkd-util.h\"\n#include \"tests.h\"\n\nTEST(network_config_state_to_string_alloc) {\n        for (unsigned i = 1; i <= NETWORK_CONFIG_STATE_REMOVING; i <<= 1) {\n                _cleanup_free_ char *x;\n\n                assert_se(network_config_state_to_string_alloc(i, &x) == 0);\n                log_debug(\"%u → %s\", i, x);\n        }\n\n        _cleanup_free_ char *x;\n        assert_se(network_config_state_to_string_alloc(~0u, &x) == 0);\n        log_debug(\"%u → %s\", ~0u, x);\n};\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "95μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "108μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "39355μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "227μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "36μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "39821μs",
      "parallelizable_steps": [],
      "critical_path_length": "39486μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 1.4285714285714284
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 1.4285714285714284,
        "content_hash": "395afca466802650"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/test-networkd-util.c"
      }
    },
    "source_hash": "ab3d99129277"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udevd.c\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * Copyright © 2004 Chris Friesen <chris_friesen@sympatico.ca>\n * Copyright © 2009 Canonical Ltd.\n * Copyright © 2009 Scott James Remnant <scott@netsplit.com>\n */\n\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"label-util.h\"\n#include \"log.h\"\n#include \"process-util.h\"\n#include \"rlimit-util.h\"\n#include \"terminal-util.h\"\n#include \"udev-config.h\"\n#include \"udev-manager.h\"\n#include \"udevd.h\"\n#include \"version.h\"\n\nint run_udevd(int argc, char *argv[]) {\n        _cleanup_(manager_freep) Manager *manager = NULL;\n        int r;\n\n        log_setup();\n\n        manager = manager_new();\n        if (!manager)\n                return log_oom();\n\n        r = manager_load(manager, argc, argv);\n        if (r <= 0)\n                return r;\n\n        r = must_be_root();\n        if (r < 0)\n                return r;\n\n        /* set umask before creating any file/directory */\n        umask(022);\n\n        r = mac_init();\n        if (r < 0)\n                return r;\n\n        /* Make sure we can have plenty fds (for example for pidfds) */\n        (void) rlimit_nofile_bump(-1);\n\n        r = RET_NERRNO(mkdir(\"/run/udev\", 0755));\n        if (r < 0 && r != -EEXIST)\n                return log_error_errno(r, \"Failed to create /run/udev: %m\");\n\n        if (arg_daemonize) {\n                pid_t pid;\n\n                log_info(\"Starting systemd-udevd version \" GIT_VERSION);\n\n                /* connect /dev/null to stdin, stdout, stderr */\n                if (log_get_max_level() < LOG_DEBUG) {\n                        r = make_null_stdio();\n                        if (r < 0)\n                                log_warning_errno(r, \"Failed to redirect standard streams to /dev/null: %m\");\n                }\n\n                pid = fork();\n                if (pid < 0)\n                        return log_error_errno(errno, \"Failed to fork daemon: %m\");\n                if (pid > 0)\n                        /* parent */\n                        return 0;\n\n                /* child */\n                terminal_detach_session();\n        }\n\n        return manager_main(manager);\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "141μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "163μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "49627μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "70114μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "7662μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "344118μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "260μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "472085μs",
      "parallelizable_steps": [],
      "critical_path_length": "414395μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 2.5806451612903225
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 2.5806451612903225,
        "content_hash": "c33b68fa3ac6edfe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udevd.c"
      }
    },
    "source_hash": "f04cc34dfe79"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc-redirect.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscredirectfoo\n#define foosdndiscredirectfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in6_addr;\nstruct ip6_hdr;\n\ntypedef struct sd_ndisc_redirect sd_ndisc_redirect;\n\nsd_ndisc_redirect* sd_ndisc_redirect_ref(sd_ndisc_redirect *na);\nsd_ndisc_redirect* sd_ndisc_redirect_unref(sd_ndisc_redirect *na);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc_redirect, sd_ndisc_redirect_unref);\n\nint sd_ndisc_redirect_set_sender_address(sd_ndisc_redirect *rd, const struct in6_addr *addr);\nint sd_ndisc_redirect_get_sender_address(sd_ndisc_redirect *na, struct in6_addr *ret);\nint sd_ndisc_redirect_get_target_address(sd_ndisc_redirect *na, struct in6_addr *ret);\nint sd_ndisc_redirect_get_destination_address(sd_ndisc_redirect *na, struct in6_addr *ret);\nint sd_ndisc_redirect_get_target_mac(sd_ndisc_redirect *na, struct ether_addr *ret);\nint sd_ndisc_redirect_get_redirected_header(sd_ndisc_redirect *na, struct ip6_hdr *ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "969μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "80496μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "701μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2499μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "368942μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "617μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "454224μs",
      "parallelizable_steps": [],
      "critical_path_length": "370612μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 3.125
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 3.125,
        "content_hash": "4c4f4f3b7afaebdb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc-redirect.h"
      }
    },
    "source_hash": "7d481d402f8e"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/generate-dns_type-gperf.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"Generate %-from-name.gperf from %-list.txt\n\"\"\"\n\nimport sys\n\nname, prefix, input = sys.argv[1:]\n\nprint(\"\"\"\\\n%{\n_Pragma(\"GCC diagnostic ignored \\\\\"-Wimplicit-fallthrough\\\\\"\")\n#if __GNUC__ >= 15\n_Pragma(\"GCC diagnostic ignored \\\\\"-Wzero-as-null-pointer-constant\\\\\"\")\n#endif\n%}\"\"\")\nprint(\"\"\"\\\nstruct {}_name {{ const char* name; int id; }};\n%null-strings\n%%\"\"\".format(name))\n\nfor line in open(input):\n    line = line.rstrip()\n    s = line.replace('_', '-')\n    print(\"{}, {}{}\".format(s, prefix, line))\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "554μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "79μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "164308μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "178195μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "36μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "105μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "343277μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "178379μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 21,
        "complexity_score": 2.8571428571428568
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 21,
        "complexity_score": 2.8571428571428568,
        "content_hash": "be8c929678e9f7d5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/generate-dns_type-gperf.py"
      }
    },
    "source_hash": "ec380d7f3989"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-journal/audit-type.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <stdio.h>\n\n#include \"forward.h\"\n\nconst char* audit_type_to_string(int type);\nint audit_type_from_string(const char *s);\n\n/* This is inspired by DNS TYPEnnn formatting */\n#define audit_type_name_alloca(type)                                    \\\n        ({                                                              \\\n                const char *_s_;                                        \\\n                _s_ = audit_type_to_string(type);                       \\\n                if (!_s_) {                                             \\\n                        _s_ = newa(char, STRLEN(\"AUDIT\") + DECIMAL_STR_MAX(int)); \\\n                        sprintf((char*) _s_, \"AUDIT%04i\", type);        \\\n                }                                                       \\\n                _s_;                                                    \\\n        })\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "309μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "116μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "179464μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "426290μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "249μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "70μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "606498μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "426476μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 17,
        "complexity_score": 2.3529411764705883
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 17,
        "complexity_score": 2.3529411764705883,
        "content_hash": "9a4695a84ab331da"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-journal/audit-type.h"
      }
    },
    "source_hash": "af6713142a28"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc-neighbor.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscneighborfoo\n#define foosdndiscneighborfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct in6_addr;\nstruct ether_addr;\n\ntypedef struct sd_ndisc_neighbor sd_ndisc_neighbor;\n\nsd_ndisc_neighbor *sd_ndisc_neighbor_ref(sd_ndisc_neighbor *na);\nsd_ndisc_neighbor *sd_ndisc_neighbor_unref(sd_ndisc_neighbor *na);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc_neighbor, sd_ndisc_neighbor_unref);\n\nint sd_ndisc_neighbor_get_sender_address(sd_ndisc_neighbor *na, struct in6_addr *ret);\n/* RFC 4861 section 4.4:\n * For solicited advertisements, the Target Address field in the Neighbor Solicitation message that prompted\n * this advertisement. For an unsolicited advertisement, the address whose link-layer address has changed.\n * The Target Address MUST NOT be a multicast address. */\nint sd_ndisc_neighbor_get_target_address(sd_ndisc_neighbor *na, struct in6_addr *ret);\nint sd_ndisc_neighbor_get_target_mac(sd_ndisc_neighbor *na, struct ether_addr *ret);\nint sd_ndisc_neighbor_get_flags(sd_ndisc_neighbor *na, uint32_t *ret);\nint sd_ndisc_neighbor_is_router(sd_ndisc_neighbor *na);\nint sd_ndisc_neighbor_is_solicited(sd_ndisc_neighbor *na);\nint sd_ndisc_neighbor_is_override(sd_ndisc_neighbor *na);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "829μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "434224μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1058μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1831μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "348936μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "234μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "787112μs",
      "parallelizable_steps": [],
      "critical_path_length": "436289μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.333333333333333,
        "content_hash": "a4b91656c71f4300"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc-neighbor.h"
      }
    },
    "source_hash": "372322abf38a"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/barrier.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/* See source file for an API description. */\n\ntypedef struct Barrier Barrier;\n\nenum {\n        BARRIER_SINGLE                  = 1LL,\n        BARRIER_ABORTION                = INT64_MAX,\n\n        /* bias values to store state; keep @WE < @THEY < @I */\n        BARRIER_BIAS                    = INT64_MIN,\n        BARRIER_WE_ABORTED              = BARRIER_BIAS + 1LL,\n        BARRIER_THEY_ABORTED            = BARRIER_BIAS + 2LL,\n        BARRIER_I_ABORTED               = BARRIER_BIAS + 3LL,\n};\n\nenum {\n        BARRIER_PARENT,\n        BARRIER_CHILD,\n};\n\nstruct Barrier {\n        int me;\n        int them;\n        int pipe[2];\n        int64_t barriers;\n};\n\n#define BARRIER_NULL {-EBADF, -EBADF, {-EBADF, -EBADF}, 0}\n\nint barrier_create(Barrier *obj);\nBarrier* barrier_destroy(Barrier *b);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(Barrier*, barrier_destroy);\n\nvoid barrier_set_role(Barrier *b, unsigned role);\n\nbool barrier_place(Barrier *b);\nbool barrier_abort(Barrier *b);\n\nbool barrier_wait_next(Barrier *b);\nbool barrier_wait_abortion(Barrier *b);\nbool barrier_sync_next(Barrier *b);\nbool barrier_sync(Barrier *b);\n\nstatic inline bool barrier_i_aborted(Barrier *b) {\n        return IN_SET(b->barriers, BARRIER_I_ABORTED, BARRIER_WE_ABORTED);\n}\n\nstatic inline bool barrier_they_aborted(Barrier *b) {\n        return IN_SET(b->barriers, BARRIER_THEY_ABORTED, BARRIER_WE_ABORTED);\n}\n\nstatic inline bool barrier_we_aborted(Barrier *b) {\n        return b->barriers == BARRIER_WE_ABORTED;\n}\n\nstatic inline bool barrier_is_aborted(Barrier *b) {\n        return IN_SET(b->barriers,\n                      BARRIER_I_ABORTED, BARRIER_THEY_ABORTED, BARRIER_WE_ABORTED);\n}\n\nstatic inline bool barrier_place_and_sync(Barrier *b) {\n        (void) barrier_place(b);\n        return barrier_sync(b);\n}\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "100μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "2μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "14046μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "156μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "103μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "14407μs",
      "parallelizable_steps": [],
      "critical_path_length": "14249μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.576923076923077
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.576923076923077,
        "content_hash": "281e3bc7a0240947"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/barrier.h"
      }
    },
    "source_hash": "f57f01b7b0d9"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dhcp6-bus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nextern const BusObjectImplementation dhcp6_client_object;\n\nvoid dhcp6_client_callback_bus(sd_dhcp6_client *client, int event, void *userdata);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "41μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "148μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "359074μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "836μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "476μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "360575μs",
      "parallelizable_steps": [],
      "critical_path_length": "359591μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "70bfdb9188a50568"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dhcp6-bus.h"
      }
    },
    "source_hash": "3a1e2910c083"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-varlink/varlink-org.varlink.service.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"varlink-org.varlink.service.h\"\n\nstatic SD_VARLINK_DEFINE_METHOD(\n                GetInfo,\n                SD_VARLINK_DEFINE_OUTPUT(vendor, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(product, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(version, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(url, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(interfaces, SD_VARLINK_STRING, SD_VARLINK_ARRAY));\n\nstatic SD_VARLINK_DEFINE_METHOD(\n                GetInterfaceDescription,\n                SD_VARLINK_DEFINE_INPUT(interface, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(description, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                InterfaceNotFound,\n                SD_VARLINK_DEFINE_FIELD(interface, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                MethodNotFound,\n                SD_VARLINK_DEFINE_FIELD(method, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                MethodNotImplemented,\n                SD_VARLINK_DEFINE_FIELD(method, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                InvalidParameter,\n                SD_VARLINK_DEFINE_FIELD(parameter, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(PermissionDenied);\n\nstatic SD_VARLINK_DEFINE_ERROR(ExpectedMore);\n\n/* As per https://varlink.org/Service */\nSD_VARLINK_DEFINE_INTERFACE(\n                org_varlink_service,\n                \"org.varlink.service\",\n                &vl_method_GetInfo,\n                &vl_method_GetInterfaceDescription,\n                &vl_error_InterfaceNotFound,\n                &vl_error_MethodNotFound,\n                &vl_error_MethodNotImplemented,\n                &vl_error_InvalidParameter,\n                &vl_error_PermissionDenied,\n                &vl_error_ExpectedMore);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "28μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "47135μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "67μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "64μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "17206μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "7μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "64507μs",
      "parallelizable_steps": [],
      "critical_path_length": "47206μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.2564102564102564
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.2564102564102564,
        "content_hash": "08e3e44950767eca"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-varlink/varlink-org.varlink.service.c"
      }
    },
    "source_hash": "8622a025c0a6"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/tc/tc.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nint link_request_traffic_control(Link *link);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "882μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "440μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "261846μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1519μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "647μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "265334μs",
      "parallelizable_steps": [],
      "critical_path_length": "263375μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 4,
        "complexity_score": 5.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 4,
        "complexity_score": 5.0,
        "content_hash": "c7d8ea3db44fa66c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/tc/tc.h"
      }
    },
    "source_hash": "2740ed4cbe64"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/test-acd.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <net/ethernet.h>\n\n#include \"sd-event.h\"\n#include \"sd-ipv4acd.h\"\n#include \"sd-netlink.h\"\n\n#include \"in-addr-util.h\"\n#include \"log.h\"\n#include \"tests.h\"\n\nstatic void acd_handler(sd_ipv4acd *acd, int event, void *userdata) {\n        assert_se(acd);\n\n        switch (event) {\n        case SD_IPV4ACD_EVENT_BIND:\n                log_info(\"bound\");\n                break;\n        case SD_IPV4ACD_EVENT_CONFLICT:\n                log_info(\"conflict\");\n                break;\n        case SD_IPV4ACD_EVENT_STOP:\n                log_error(\"the client was stopped\");\n                break;\n        default:\n                assert_not_reached();\n        }\n}\n\nstatic int client_run(int ifindex, const struct in_addr *pa, const struct ether_addr *ha, sd_event *e) {\n        sd_ipv4acd *acd;\n\n        assert_se(sd_ipv4acd_new(&acd) >= 0);\n        assert_se(sd_ipv4acd_attach_event(acd, e, 0) >= 0);\n\n        assert_se(sd_ipv4acd_set_ifindex(acd, ifindex) >= 0);\n        assert_se(sd_ipv4acd_set_mac(acd, ha) >= 0);\n        assert_se(sd_ipv4acd_set_address(acd, pa) >= 0);\n        assert_se(sd_ipv4acd_set_callback(acd, acd_handler, NULL) >= 0);\n\n        log_info(\"starting IPv4ACD client\");\n\n        assert_se(sd_ipv4acd_start(acd, true) >= 0);\n\n        assert_se(sd_event_loop(e) >= 0);\n\n        assert_se(!sd_ipv4acd_unref(acd));\n\n        return EXIT_SUCCESS;\n}\n\nstatic int test_acd(const char *ifname, const char *address) {\n        _cleanup_(sd_event_unrefp) sd_event *e = NULL;\n        _cleanup_(sd_netlink_unrefp) sd_netlink *rtnl = NULL;\n        _cleanup_(sd_netlink_message_unrefp) sd_netlink_message *m = NULL, *reply = NULL;\n        union in_addr_union pa;\n        struct ether_addr ha;\n        int ifindex;\n\n        assert_se(in_addr_from_string(AF_INET, address, &pa) >= 0);\n\n        assert_se(sd_event_new(&e) >= 0);\n\n        assert_se(sd_netlink_open(&rtnl) >= 0);\n        assert_se(sd_netlink_attach_event(rtnl, e, 0) >= 0);\n\n        assert_se(sd_rtnl_message_new_link(rtnl, &m, RTM_GETLINK, 0) >= 0);\n        assert_se(sd_netlink_message_append_string(m, IFLA_IFNAME, ifname) >= 0);\n        assert_se(sd_netlink_call(rtnl, m, 0, &reply) >= 0);\n\n        assert_se(sd_rtnl_message_link_get_ifindex(reply, &ifindex) >= 0);\n        assert_se(sd_netlink_message_read_ether_addr(reply, IFLA_ADDRESS, &ha) >= 0);\n\n        client_run(ifindex, &pa.in, &ha, e);\n\n        return EXIT_SUCCESS;\n}\n\nint main(int argc, char *argv[]) {\n        test_setup_logging(LOG_DEBUG);\n\n        if (argc == 3)\n                return test_acd(argv[1], argv[2]);\n        else {\n                log_error(\"This program takes two arguments.\\n\"\n                          \"\\t %s <ifname> <IPv4 address>\", program_invocation_short_name);\n                return EXIT_FAILURE;\n        }\n}\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "406μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "242μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "175686μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "768μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "215μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "177317μs",
      "parallelizable_steps": [],
      "critical_path_length": "176307μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 67,
        "complexity_score": 2.238805970149254
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 67,
        "complexity_score": 2.238805970149254,
        "content_hash": "bb613c767911b41e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/test-acd.c"
      }
    },
    "source_hash": "10d92f3233a2"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/bus-unit-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum ExecDirectoryFlags {\n        EXEC_DIRECTORY_READ_ONLY      = 1 << 0, /* Public API via DBUS, do not change */\n        EXEC_DIRECTORY_ONLY_CREATE    = 1 << 1, /* Only the private directory will be created, not the symlink to it */\n        _EXEC_DIRECTORY_FLAGS_MAX,\n        _EXEC_DIRECTORY_FLAGS_PUBLIC  = EXEC_DIRECTORY_READ_ONLY,\n        _EXEC_DIRECTORY_FLAGS_INVALID = -EINVAL,\n} ExecDirectoryFlags;\n\nExecDirectoryFlags exec_directory_flags_from_string(const char *s) _pure_;\n\ntypedef struct UnitInfo {\n        const char *machine;\n        const char *id;\n        const char *description;\n        const char *load_state;\n        const char *active_state;\n        const char *sub_state;\n        const char *following;\n        const char *unit_path;\n        uint32_t job_id;\n        const char *job_type;\n        const char *job_path;\n} UnitInfo;\n\nint bus_parse_unit_info(sd_bus_message *message, UnitInfo *u);\n\nint bus_append_unit_property_assignment(sd_bus_message *m, UnitType t, const char *assignment);\nint bus_append_unit_property_assignment_many(sd_bus_message *m, UnitType t, char * const *l);\n\nint bus_append_scope_pidref(sd_bus_message *m, const PidRef *pidref, bool allow_pidfd);\n\nint bus_deserialize_and_dump_unit_file_changes(sd_bus_message *m, bool quiet);\n\nint unit_load_state(sd_bus *bus, const char *name, char **ret);\n\nint unit_info_compare(const UnitInfo *a, const UnitInfo *b);\n\nint bus_service_manager_reload(sd_bus *bus);\n\ntypedef struct UnitFreezer UnitFreezer;\n\nUnitFreezer* unit_freezer_free(UnitFreezer *f);\nDEFINE_TRIVIAL_CLEANUP_FUNC(UnitFreezer*, unit_freezer_free);\n\nint unit_freezer_new(const char *name, UnitFreezer **ret);\n\nint unit_freezer_freeze(UnitFreezer *f);\nint unit_freezer_thaw(UnitFreezer *f);\n\nvoid bus_dump_transient_settings(UnitType t);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "6μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "86μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "2454μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "93μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "13μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2652μs",
      "parallelizable_steps": [],
      "critical_path_length": "2473μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.5128205128205128
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.5128205128205128,
        "content_hash": "2a8913ef76add2f6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/bus-unit-util.h"
      }
    },
    "source_hash": "d4ca345d4d8b"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-serialize.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nint manager_serialize(Manager *manager);\nint manager_set_serialization_fd(Manager *manager, int fd, const char *name);\nint manager_deserialize(Manager *manager);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "475μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "487μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "158496μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "905μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "160682μs",
      "parallelizable_steps": [],
      "critical_path_length": "159290μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 6,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 6,
        "complexity_score": 3.333333333333333,
        "content_hash": "532d1905dd65406b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-serialize.h"
      }
    },
    "source_hash": "0acf244b5699"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp-lease-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n/***\n  Copyright © 2013 Intel Corporation. All rights reserved.\n***/\n\n#include \"sd-dhcp-lease.h\"\n\n#include \"dhcp-client-id-internal.h\"\n#include \"dhcp-option.h\"\n#include \"forward.h\"\n#include \"list.h\"\n\nstruct sd_dhcp_route {\n        struct in_addr dst_addr;\n        struct in_addr gw_addr;\n        unsigned char dst_prefixlen;\n};\n\nstruct sd_dhcp_raw_option {\n        LIST_FIELDS(struct sd_dhcp_raw_option, options);\n\n        uint8_t tag;\n        uint8_t length;\n        void *data;\n};\n\nstruct sd_dhcp_lease {\n        unsigned n_ref;\n\n        /* each 0 if unset */\n        usec_t t1;\n        usec_t t2;\n        usec_t lifetime;\n        triple_timestamp timestamp;\n        usec_t ipv6_only_preferred_usec;\n\n        /* each 0 if unset */\n        be32_t address;\n        be32_t server_address;\n        be32_t next_server;\n\n        bool have_subnet_mask;\n        be32_t subnet_mask;\n\n        bool have_broadcast;\n        be32_t broadcast;\n\n        struct in_addr *router;\n        size_t router_size;\n\n        bool rapid_commit;\n\n        DHCPServerData servers[_SD_DHCP_LEASE_SERVER_TYPE_MAX];\n\n        sd_dns_resolver *dnr;\n        size_t n_dnr;\n\n        struct sd_dhcp_route *static_routes;\n        size_t n_static_routes;\n        struct sd_dhcp_route *classless_routes;\n        size_t n_classless_routes;\n\n        uint16_t mtu; /* 0 if unset */\n\n        char *domainname;\n        char **search_domains;\n        char *hostname;\n        char *root_path;\n        char *captive_portal;\n\n        sd_dhcp_client_id client_id;\n\n        void *vendor_specific;\n        size_t vendor_specific_len;\n\n        char *timezone;\n\n        uint8_t sixrd_ipv4masklen;\n        uint8_t sixrd_prefixlen;\n        struct in6_addr sixrd_prefix;\n        struct in_addr *sixrd_br_addresses;\n        size_t sixrd_n_br_addresses;\n\n        LIST_HEAD(struct sd_dhcp_raw_option, private_options);\n};\n\nint dhcp_lease_new(sd_dhcp_lease **ret);\n\nint dhcp_lease_parse_options(uint8_t code, uint8_t len, const void *option, void *userdata);\nint dhcp_lease_parse_search_domains(const uint8_t *option, size_t len, char ***domains);\nint dhcp_lease_insert_private_option(sd_dhcp_lease *lease, uint8_t tag, const void *data, uint8_t len);\n\nvoid dhcp_lease_set_timestamp(sd_dhcp_lease *lease, const triple_timestamp *timestamp);\nint dhcp_lease_set_default_subnet_mask(sd_dhcp_lease *lease);\nint dhcp_lease_set_client_id(sd_dhcp_lease *lease, const sd_dhcp_client_id *client_id);\n\n#define dhcp_lease_unref_and_replace(a, b)                              \\\n        unref_and_replace_full(a, b, sd_dhcp_lease_ref, sd_dhcp_lease_unref)\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "52μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "86μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "31080μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "171μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "127μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "31516μs",
      "parallelizable_steps": [],
      "critical_path_length": "31259μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 73,
        "complexity_score": 1.095890410958904
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 73,
        "complexity_score": 1.095890410958904,
        "content_hash": "2b3c1a3996e57a0e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp-lease-internal.h"
      }
    },
    "source_hash": "bf74f6bd2ca8"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/sort-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdlib.h>\n\n#include \"alloc-util.h\"\n#include \"sort-util.h\"\n\n/* hey glibc, APIs with callbacks without a user pointer are so useless */\nvoid *xbsearch_r(const void *key, const void *base, size_t nmemb, size_t size,\n                 comparison_userdata_fn_t compar, void *arg) {\n        size_t l, u, idx;\n        const void *p;\n        int comparison;\n\n        assert(!size_multiply_overflow(nmemb, size));\n\n        l = 0;\n        u = nmemb;\n        while (l < u) {\n                idx = (l + u) / 2;\n                p = (const uint8_t*) base + idx * size;\n                comparison = compar(key, p, arg);\n                if (comparison < 0)\n                        u = idx;\n                else if (comparison > 0)\n                        l = idx + 1;\n                else\n                        return (void *)p;\n        }\n        return NULL;\n}\n\nvoid* bsearch_safe(const void *key, const void *base, size_t nmemb, size_t size, comparison_fn_t compar) {\n        /**\n        * Normal bsearch requires base to be nonnull. Here were require\n        * that only if nmemb > 0.\n        */\n\n        if (nmemb <= 0)\n                return NULL;\n\n        assert(base);\n        return bsearch(key, base, nmemb, size, compar);\n}\n\nvoid qsort_safe(void *base, size_t nmemb, size_t size, comparison_fn_t compar) {\n        /**\n         * Normal qsort requires base to be nonnull. Here were require\n         * that only if nmemb > 0.\n         */\n\n        if (nmemb <= 1)\n                return;\n\n        assert(base);\n        qsort(base, nmemb, size, compar);\n}\n\nvoid qsort_r_safe(void *base, size_t nmemb, size_t size, comparison_userdata_fn_t compar, void *userdata) {\n        if (nmemb <= 1)\n                return;\n\n        assert(base);\n        qsort_r(base, nmemb, size, compar, userdata);\n}\n\nint cmp_int(const int *a, const int *b) {\n        return CMP(*a, *b);\n}\n\nint cmp_uint16(const uint16_t *a, const uint16_t *b) {\n        return CMP(*a, *b);\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "114μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "280μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "135468μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "635μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "43μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "136540μs",
      "parallelizable_steps": [],
      "critical_path_length": "135625μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 58,
        "complexity_score": 1.896551724137931
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 58,
        "complexity_score": 1.896551724137931,
        "content_hash": "722e3d89edf08fb6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/sort-util.c"
      }
    },
    "source_hash": "ca48e114a443"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/cryptsetup/cryptsetup-keyfile.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\nint find_key_file(const char *key_file, char **search_path, const char *bindname, struct iovec *ret_key);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "313μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "885μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "455488μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1284μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "809μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "458779μs",
      "parallelizable_steps": [],
      "critical_path_length": "456610μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 4,
        "complexity_score": 5.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 4,
        "complexity_score": 5.0,
        "content_hash": "e8299f1ba7a43554"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/cryptsetup/cryptsetup-keyfile.h"
      }
    },
    "source_hash": "fcfa602b65e8"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/sleep/battery-capacity.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"hashmap.h\"\n\nint fetch_batteries_capacity_by_name(Hashmap **ret_current_capacity);\nint get_capacity_by_name(Hashmap *capacities_by_name, const char *name);\n\nint get_total_suspend_interval(Hashmap *last_capacity, usec_t *ret);\n\nint estimate_battery_discharge_rate_per_hour(\n                Hashmap *last_capacity,\n                Hashmap *current_capacity,\n                usec_t before_timestamp,\n                usec_t after_timestamp);\n\nint battery_trip_point_alarm_exists(void);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "238μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "185μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "145139μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "498μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "218μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "146278μs",
      "parallelizable_steps": [],
      "critical_path_length": "145595μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 12,
        "complexity_score": 1.6666666666666665
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 12,
        "complexity_score": 1.6666666666666665,
        "content_hash": "b08c0f449c91baae"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/sleep/battery-capacity.h"
      }
    },
    "source_hash": "fc1598acfee5"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/override/netinet/in.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/in.h>   /* IWYU pragma: export */\n#include <linux/in6.h>  /* IWYU pragma: export */\n#include <linux/ipv6.h> /* IWYU pragma: export */\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/socket.h>\n\n#define INET_ADDRSTRLEN 16\n#define INET6_ADDRSTRLEN 46\n\nextern const struct in6_addr in6addr_any;        /* :: */\nextern const struct in6_addr in6addr_loopback;   /* ::1 */\n#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }\n#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }\n\ntypedef uint32_t in_addr_t;\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "22μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "30μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "30166μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "56666μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "19975μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "2283μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "46μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "109188μs",
      "parallelizable_steps": [],
      "critical_path_length": "58979μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666,
        "content_hash": "7ad6744144d86617"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/override/netinet/in.h"
      }
    },
    "source_hash": "3683bfadf0d3"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-timeouts.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-def.h\"\n#include \"time-util.h\"\n\n/* LLMNR Jitter interval, see RFC 4795 Section 7 */\n#define LLMNR_JITTER_INTERVAL_USEC (100 * USEC_PER_MSEC)\n\n/* mDNS probing interval, see RFC 6762 Section 8.1 */\n#define MDNS_PROBING_INTERVAL_USEC (250 * USEC_PER_MSEC)\n\n/* Maximum attempts to send DNS requests, across all DNS servers */\n#define DNS_TRANSACTION_ATTEMPTS_MAX 24\n\n/* Maximum attempts to send LLMNR requests, see RFC 4795 Section 2.7 */\n#define LLMNR_TRANSACTION_ATTEMPTS_MAX 3\n\n/* Maximum attempts to send MDNS requests, see RFC 6762 Section 8.1 */\n#define MDNS_TRANSACTION_ATTEMPTS_MAX 3\n\n/* Maximum attempts to send an mDNS continuous query.\n *\n * RFC 6762 Section 5.2 does not specify a maximum number of attempts directly.\n * However, it outlines two important guidelines:\n *\n * 1. The interval between the first two queries MUST be at least one second.\n * 2. The intervals between successive queries MUST increase by at least a factor of two.\n *\n * To adhere to these timing requirements for continuous queries,\n * the maximum number of attempts should be set to 1.\n */\n#define MDNS_TRANSACTION_CONTINUOUS_QUERY_MAX 1U\n\nstatic inline unsigned dns_transaction_attempts_max(DnsProtocol p, uint64_t query_flags) {\n        switch (p) {\n\n        case DNS_PROTOCOL_LLMNR:\n                return LLMNR_TRANSACTION_ATTEMPTS_MAX;\n\n        case DNS_PROTOCOL_MDNS:\n                if (FLAGS_SET(query_flags, SD_RESOLVED_QUERY_CONTINUOUS))\n                        return MDNS_TRANSACTION_CONTINUOUS_QUERY_MAX;\n                else\n                        return MDNS_TRANSACTION_ATTEMPTS_MAX;\n\n        default:\n                return DNS_TRANSACTION_ATTEMPTS_MAX;\n        }\n}\n\n/* After how much time to repeat classic DNS requests */\n#define TRANSACTION_UDP_TIMEOUT_USEC (SD_RESOLVED_QUERY_TIMEOUT_USEC / DNS_TRANSACTION_ATTEMPTS_MAX)\n\n/* When we do TCP, grant a much longer timeout, as in this case there's no need for us to quickly\n * resend, as the kernel does that anyway for us, and we really don't want to interrupt it in that\n * needlessly. */\n#define TRANSACTION_TCP_TIMEOUT_USEC (10 * USEC_PER_SEC)\n\n/* Should be longer than transaction timeout for a single UDP transaction, so we get at least\n * one transaction retry before timeouting the whole candidate */\n#define CANDIDATE_EXPEDITED_TIMEOUT_USEC (TRANSACTION_UDP_TIMEOUT_USEC + 1 * USEC_PER_SEC)\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "179μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "160μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "368412μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "8462μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "148947μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "78845μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "106612μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "265μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "711882μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "623971μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.875,
        "content_hash": "6081cc4f1bb4055f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-timeouts.h"
      }
    },
    "source_hash": "55b90439adb8"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-stream.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/socket.h>\n\n#include \"sd-id128.h\"\n\n#include \"journald-forward.h\"\n#include \"list.h\"\n\ntypedef enum StdoutStreamState {\n        STDOUT_STREAM_IDENTIFIER,\n        STDOUT_STREAM_UNIT_ID,\n        STDOUT_STREAM_PRIORITY,\n        STDOUT_STREAM_LEVEL_PREFIX,\n        STDOUT_STREAM_FORWARD_TO_SYSLOG,\n        STDOUT_STREAM_FORWARD_TO_KMSG,\n        STDOUT_STREAM_FORWARD_TO_CONSOLE,\n        STDOUT_STREAM_RUNNING,\n} StdoutStreamState;\n\ntypedef struct StdoutStream {\n        Manager *manager;\n        StdoutStreamState state;\n\n        int fd;\n\n        struct ucred ucred;\n        char *label;\n        char *identifier;\n        char *unit_id;\n        int priority;\n        bool level_prefix:1;\n        bool forward_to_syslog:1;\n        bool forward_to_kmsg:1;\n        bool forward_to_console:1;\n\n        bool fdstore:1;\n        bool in_notify_queue:1;\n\n        char *buffer;\n        size_t length;\n\n        sd_event_source *event_source;\n\n        char *state_file;\n\n        ClientContext *context;\n\n        LIST_FIELDS(StdoutStream, stdout_stream);\n        LIST_FIELDS(StdoutStream, stdout_stream_notify_queue);\n\n        char id_field[STRLEN(\"_STREAM_ID=\") + SD_ID128_STRING_MAX];\n\n        LIST_HEAD(StreamSyncReq, stream_sync_reqs);\n} StdoutStream;\n\nint manager_open_stdout_socket(Manager *m, const char *stdout_socket);\nint manager_restore_streams(Manager *m, FDSet *fds);\n\nStdoutStream* stdout_stream_free(StdoutStream *s);\nint stdout_stream_install(Manager *m, int fd, StdoutStream **ret);\nvoid stdout_stream_terminate(StdoutStream *s);\nvoid stdout_stream_send_notify(StdoutStream *s);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "25μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "20μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "100650μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "393587μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "549255μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "285670μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "239μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1329446μs",
      "parallelizable_steps": [],
      "critical_path_length": "679277μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 2.765957446808511
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 2.765957446808511,
        "content_hash": "8095de6947bc6220"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-stream.h"
      }
    },
    "source_hash": "f868bf61408d"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dnssd.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-conf.h\"\n#include \"resolved-forward.h\"\n\nenum {\n        DNS_TXT_ITEM_TEXT,\n        DNS_TXT_ITEM_DATA,\n};\n\ntypedef struct DnssdTxtData {\n        DnsResourceRecord *rr;\n\n        LIST_HEAD(DnsTxtItem, txts);\n\n        LIST_FIELDS(DnssdTxtData, items);\n} DnssdTxtData;\n\ntypedef struct DnssdRegisteredService {\n        char *path;\n        char *id;\n        char *name_template;\n        char *type;\n        char *subtype;\n        uint16_t port;\n        uint16_t priority;\n        uint16_t weight;\n\n        DnsResourceRecord *ptr_rr;\n        DnsResourceRecord *sub_ptr_rr;\n        DnsResourceRecord *srv_rr;\n\n        /* Section 6.8 of RFC 6763 allows having service\n         * instances with multiple TXT resource records. */\n        LIST_HEAD(DnssdTxtData, txt_data_items);\n\n        Manager *manager;\n\n        /* Services registered via D-Bus are not removed on reload */\n        ResolveConfigSource config_source;\n\n        bool withdrawn:1;\n        uid_t originator;\n} DnssdRegisteredService;\n\nDnssdRegisteredService *dnssd_registered_service_free(DnssdRegisteredService *service);\nDnssdTxtData *dnssd_txtdata_free(DnssdTxtData *txt_data);\nDnssdTxtData *dnssd_txtdata_free_all(DnssdTxtData *txt_data);\nvoid dnssd_registered_service_clear_on_reload(Hashmap *services);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnssdRegisteredService*, dnssd_registered_service_free);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnssdTxtData*, dnssd_txtdata_free);\n\nint dnssd_render_instance_name(Manager *m, DnssdRegisteredService *s, char **ret);\nint dnssd_load(Manager *manager);\nint dnssd_txt_item_new_from_string(const char *key, const char *value, DnsTxtItem **ret_item);\nint dnssd_txt_item_new_from_data(const char *key, const void *value, const size_t size, DnsTxtItem **ret_item);\nint dnssd_update_rrs(DnssdRegisteredService *s);\nint dnssd_signal_conflict(Manager *manager, const char *name);\n\nconst struct ConfigPerfItem* resolved_dnssd_gperf_lookup(const char *key, GPERF_LEN_TYPE length);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_registered_service_name);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_registered_service_subtype);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_registered_service_type);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_txt);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "58μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "29μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "142323μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "147501μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "43μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "19μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "289973μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "147549μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.7692307692307693
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.7692307692307693,
        "content_hash": "ad1d408a7be5a36f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dnssd.h"
      }
    },
    "source_hash": "7113583cd793"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/uki.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stddef.h>\n\n#include \"uki.h\"\n\nconst char* const unified_sections[_UNIFIED_SECTION_MAX + 1] = {\n        /* These section names must fit in 8ch (excluding any trailing NUL) as per PE spec for executables:\n         * https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#section-table-section-headers\n         * (Note that PE *object* files may have longer section names (via indirection in the string table) but\n         * this is not allowed for PE *executables*, which UKIs are.) */\n        [UNIFIED_SECTION_LINUX]   = \".linux\",\n        [UNIFIED_SECTION_OSREL]   = \".osrel\",\n        [UNIFIED_SECTION_CMDLINE] = \".cmdline\",\n        [UNIFIED_SECTION_INITRD]  = \".initrd\",\n        [UNIFIED_SECTION_UCODE]   = \".ucode\",\n        [UNIFIED_SECTION_SPLASH]  = \".splash\",\n        [UNIFIED_SECTION_DTB]     = \".dtb\",\n        [UNIFIED_SECTION_UNAME]   = \".uname\",\n        [UNIFIED_SECTION_SBAT]    = \".sbat\",\n        [UNIFIED_SECTION_PCRSIG]  = \".pcrsig\",\n        [UNIFIED_SECTION_PCRPKEY] = \".pcrpkey\",\n        [UNIFIED_SECTION_PROFILE] = \".profile\",\n        [UNIFIED_SECTION_DTBAUTO] = \".dtbauto\",\n        [UNIFIED_SECTION_HWIDS]   = \".hwids\",\n        [UNIFIED_SECTION_EFIFW]   = \".efifw\",\n        NULL,\n};\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "2960μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "2652730μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2964μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2313μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "179361μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "742μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "2841070μs",
      "parallelizable_steps": [],
      "critical_path_length": "2655785μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 9.200000000000001
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 9.200000000000001,
        "content_hash": "ced735ce2e1aa243"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/uki.c"
      }
    },
    "source_hash": "41b5a4a6e9db"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/catalog-report.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: MIT\n#\n# This file is distributed under the MIT license, see below.\n#\n# The MIT License (MIT)\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n\"\"\"\nPrints out journal entries with no or bad catalog explanations.\n\"\"\"\n\nimport re\n\nfrom systemd import id128, journal\n\n\n# pylint: disable=consider-using-f-string\ndef log_entry(entry):\n    if 'CODE_FILE' in entry:\n        # some of our code was using 'CODE_FUNCTION' instead of 'CODE_FUNC'\n        print('{}:{} {}'.format(entry.get('CODE_FILE', '???'),\n                                entry.get('CODE_LINE', '???'),\n                                entry.get('CODE_FUNC', None) or entry.get('CODE_FUNCTION', '???')))\n    print('    {}'.format(entry.get('MESSAGE', 'no message!')))\n    for k, v in entry.items():\n        if k.startswith('CODE_') or k in {'MESSAGE_ID', 'MESSAGE'}:\n            continue\n        print(f'    {k}={v}')\n    print()\n\nif __name__ == '__main__':\n    j = journal.Reader()\n    logged = set()\n    pattern = re.compile('@[A-Z0-9_]+@')\n\n    mids = { v:k for k,v in id128.__dict__.items() if k.startswith('SD_MESSAGE') }\n\n    for i, x in enumerate(j):\n        if i % 1000 == 0:\n            print(i, end='\\r')\n\n        try:\n            mid = x['MESSAGE_ID']\n        except KeyError:\n            continue\n        name = mids.get(mid, 'unknown')\n\n        try:\n            desc = journal.get_catalog(mid)\n        except FileNotFoundError:\n            if mid in logged:\n                continue\n\n            print(f'{name} {mid.hex}: no catalog entry')\n            log_entry(x)\n            logged.add(mid)\n            continue\n\n        fields = [field[1:-1] for field in pattern.findall(desc)]\n        for field in fields:\n            index = (mid, field)\n            if field in x or index in logged:\n                continue\n            print(f'{name} {mid.hex}: no field {field}')\n            log_entry(x)\n            logged.add(index)\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "335μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "875μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "131914μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "903422μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "533565μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "510234μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "338993μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "760μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "2420098μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1415291μs",
      "metadata": {
        "functions_found": [
          "log_entry"
        ],
        "classes_found": [],
        "imports": [
          "re",
          "systemd"
        ],
        "lines_of_code": 72,
        "complexity_score": 5.694444444444445
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [
          "log_entry"
        ],
        "classes": [],
        "imports": [
          "re",
          "systemd"
        ],
        "lines_of_code": 72,
        "complexity_score": 5.694444444444445,
        "content_hash": "efb4637595b7db2a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/catalog-report.py"
      }
    },
    "source_hash": "89558e81fe10"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-client-id.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpclientidhfoo\n#define foosddhcpclientidhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp_client_id sd_dhcp_client_id;\ntypedef struct sd_dhcp_duid sd_dhcp_duid;\n\nint sd_dhcp_client_id_new(sd_dhcp_client_id **ret);\nsd_dhcp_client_id* sd_dhcp_client_id_free(sd_dhcp_client_id *client_id);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp_client_id, sd_dhcp_client_id_free);\n\nint sd_dhcp_client_id_clear(sd_dhcp_client_id *client_id);\n\nint sd_dhcp_client_id_is_set(const sd_dhcp_client_id *client_id);\n\nint sd_dhcp_client_id_get(const sd_dhcp_client_id *client_id, uint8_t *ret_type, const void **ret_data, size_t *ret_size);\nint sd_dhcp_client_id_get_raw(const sd_dhcp_client_id *client_id, const void **ret_data, size_t *ret_size);\n\nint sd_dhcp_client_id_set(\n                sd_dhcp_client_id *client_id,\n                uint8_t type,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_client_id_set_raw(\n                sd_dhcp_client_id *client_id,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_client_id_set_iaid_duid(\n                sd_dhcp_client_id *client_id,\n                uint32_t iaid,\n                sd_dhcp_duid *duid);\n\nint sd_dhcp_client_id_to_string(const sd_dhcp_client_id *client_id, char **ret);\nint sd_dhcp_client_id_to_string_from_raw(const void *data, size_t data_size, char **ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "146μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "811080μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1762μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "976μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "33332μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "102μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "847398μs",
      "parallelizable_steps": [],
      "critical_path_length": "812158μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 2.3255813953488373
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 2.3255813953488373,
        "content_hash": "724aba8f4f9cc991"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-client-id.h"
      }
    },
    "source_hash": "3e23420c04af"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udev-builtin-kmod.c\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * load kernel modules\n *\n * Copyright © 2011 ProFUSION embedded systems\n */\n\n#include \"device-util.h\"\n#include \"module-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"udev-builtin.h\"\n\nstatic struct kmod_ctx *ctx = NULL;\n\nstatic int builtin_kmod(UdevEvent *event, int argc, char *argv[]) {\n        sd_device *dev = ASSERT_PTR(ASSERT_PTR(event)->dev);\n        int r;\n\n        if (event->event_mode != EVENT_UDEV_WORKER) {\n                log_device_debug(dev, \"Running in test mode, skipping execution of 'kmod' builtin command.\");\n                return 0;\n        }\n\n        if (!ctx)\n                return 0;\n\n        if (argc < 2 || !streq(argv[1], \"load\"))\n                return log_device_warning_errno(dev, SYNTHETIC_ERRNO(EINVAL),\n                                                \"%s: expected: load [module…]\", argv[0]);\n\n        char **modules = strv_skip(argv, 2);\n        if (modules)\n                STRV_FOREACH(module, modules)\n                        (void) module_load_and_warn(ctx, *module, /* verbose = */ false);\n        else {\n                const char *modalias;\n\n                r = sd_device_get_property_value(dev, \"MODALIAS\", &modalias);\n                if (r < 0)\n                        return log_device_warning_errno(dev, r, \"Failed to read property \\\"MODALIAS\\\": %m\");\n\n                (void) module_load_and_warn(ctx, modalias, /* verbose = */ false);\n        }\n\n        return 0;\n}\n\n/* called at udev startup and reload */\nstatic int builtin_kmod_init(void) {\n        int r;\n\n        if (ctx)\n                return 0;\n\n        r = module_setup_context(&ctx);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to initialize libkmod context: %m\");\n\n        log_debug(\"Loaded kernel module index.\");\n        return 0;\n}\n\n/* called on udev shutdown and reload request */\nstatic void builtin_kmod_exit(void) {\n        if (!ctx)\n                return;\n\n        ctx = sym_kmod_unref(ctx);\n        log_debug(\"Unloaded kernel module index.\");\n}\n\n/* called every couple of seconds during event activity; 'true' if config has changed */\nstatic bool builtin_kmod_should_reload(void) {\n        if (!ctx)\n                return false;\n\n        if (sym_kmod_validate_resources(ctx) != KMOD_RESOURCES_OK) {\n                log_debug(\"Kernel module index needs reloading.\");\n                return true;\n        }\n\n        return false;\n}\n\nconst UdevBuiltin udev_builtin_kmod = {\n        .name = \"kmod\",\n        .cmd = builtin_kmod,\n        .init = builtin_kmod_init,\n        .exit = builtin_kmod_exit,\n        .should_reload = builtin_kmod_should_reload,\n        .help = \"Kernel module loader\",\n        .run_once = false,\n};\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "146μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "88μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "72389μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "552μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "262μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "73437μs",
      "parallelizable_steps": [],
      "critical_path_length": "72797μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 1.7567567567567568
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 1.7567567567567568,
        "content_hash": "b2dc7620c5c06308"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udev-builtin-kmod.c"
      }
    },
    "source_hash": "59c91c2cb829"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-daemon.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/eventfd.h>\n\n#include \"sd-daemon.h\"\n\n#include \"fd-util.h\"\n#include \"parse-util.h\"\n#include \"pidfd-util.h\"\n#include \"process-util.h\"\n#include \"strv.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nint main(int argc, char *argv[]) {\n        _cleanup_strv_free_ char **l = NULL;\n        int r, n, i;\n        usec_t duration = USEC_PER_SEC / 10;\n\n        test_setup_logging(LOG_DEBUG);\n\n        if (argc >= 2) {\n                unsigned x;\n\n                ASSERT_OK(safe_atou(argv[1], &x));\n                duration = x * USEC_PER_SEC;\n        }\n\n        n = sd_listen_fds_with_names(false, &l);\n        if (n < 0) {\n                log_error_errno(n, \"Failed to get listening fds: %m\");\n                return EXIT_FAILURE;\n        }\n\n        for (i = 0; i < n; i++)\n                log_info(\"fd=%i name=%s\", SD_LISTEN_FDS_START + i, l[i]);\n\n        sd_notify(0,\n                  \"STATUS=Starting up\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Running\\n\"\n                  \"READY=1\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Reloading\\n\"\n                  \"RELOADING=1\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Running\\n\"\n                  \"READY=1\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Quitting\\n\"\n                  \"STOPPING=1\");\n        usleep_safe(duration);\n\n        _cleanup_close_ int fd = eventfd(0, EFD_CLOEXEC);\n        ASSERT_OK_ERRNO(fd);\n\n        r = sd_pidfd_get_inode_id(fd, NULL);\n        ASSERT_TRUE(IN_SET(r, -EOPNOTSUPP, -EBADF));\n        if (r == -EBADF) {\n                safe_close(fd);\n                ASSERT_OK_ERRNO(fd = pidfd_open(getpid_cached(), 0));\n                ASSERT_OK(sd_pidfd_get_inode_id(fd, NULL));\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "47μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "247μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "364925μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "16752μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "149275μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "318219μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "75272μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "41μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "924778μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "589472μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.9298245614035086
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.9298245614035086,
        "content_hash": "c4c9312a65d6e894"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-daemon.c"
      }
    },
    "source_hash": "a01a714a6168"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/bpf-dlopen.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <syslog.h>\n\n#if HAVE_LIBBPF\n\n#include <bpf/bpf.h>    /* IWYU pragma: export */\n#include <bpf/libbpf.h> /* IWYU pragma: export */\n\n#include \"bpf-compat.h\" /* IWYU pragma: export */\n#include \"dlfcn-util.h\"\n#include \"forward.h\"\n\nextern DLSYM_PROTOTYPE(bpf_link__destroy);\nextern DLSYM_PROTOTYPE(bpf_link__fd);\nextern DLSYM_PROTOTYPE(bpf_link__open);\nextern DLSYM_PROTOTYPE(bpf_link__pin);\nextern DLSYM_PROTOTYPE(bpf_map__fd);\nextern DLSYM_PROTOTYPE(bpf_map__name);\nextern DLSYM_PROTOTYPE(bpf_map__set_inner_map_fd);\nextern DLSYM_PROTOTYPE(bpf_map__set_max_entries);\nextern DLSYM_PROTOTYPE(bpf_map__set_pin_path);\nextern DLSYM_PROTOTYPE(bpf_map_delete_elem);\nextern DLSYM_PROTOTYPE(bpf_map_get_fd_by_id);\nextern DLSYM_PROTOTYPE(bpf_map_lookup_elem);\nextern DLSYM_PROTOTYPE(bpf_map_update_elem);\n/* The *_skeleton APIs are autogenerated by bpftool, the targets can be found\n * in ./build/src/core/bpf/socket-bind/socket-bind.skel.h */\nextern DLSYM_PROTOTYPE(bpf_object__attach_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__destroy_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__detach_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__load_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__name);\nextern DLSYM_PROTOTYPE(bpf_object__open_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__pin_maps);\nextern DLSYM_PROTOTYPE(bpf_program__attach);\nextern DLSYM_PROTOTYPE(bpf_program__attach_cgroup);\nextern DLSYM_PROTOTYPE(bpf_program__attach_lsm);\nextern DLSYM_PROTOTYPE(bpf_program__name);\nextern DLSYM_PROTOTYPE(libbpf_set_print);\nextern DLSYM_PROTOTYPE(ring_buffer__epoll_fd);\nextern DLSYM_PROTOTYPE(ring_buffer__free);\nextern DLSYM_PROTOTYPE(ring_buffer__new);\nextern DLSYM_PROTOTYPE(ring_buffer__poll);\n\n/* libbpf sometimes returns error codes that make sense only in the kernel, like 524 for EOPNOTSUPP. Use\n * this helper instead of libbpf_get_error() to ensure some of the known ones are translated into errnos\n * we understand. */\nint bpf_get_error_translated(const void *ptr);\n\n#endif\n\nint dlopen_bpf_full(int log_level);\nstatic inline int dlopen_bpf(void) {\n        return dlopen_bpf_full(LOG_DEBUG);\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "169μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "2μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "168143μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "71894μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "110944μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "178956μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "144μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "530252μs",
      "parallelizable_steps": [],
      "critical_path_length": "279400μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 1.0204081632653061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 1.0204081632653061,
        "content_hash": "c843f67b8231fb7f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/bpf-dlopen.h"
      }
    },
    "source_hash": "170c977e7186"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-bus/test-bus-creds.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-dump.h\"\n#include \"cgroup-util.h\"\n#include \"errno-util.h\"\n#include \"tests.h\"\n\nint main(int argc, char *argv[]) {\n        _cleanup_(sd_bus_creds_unrefp) sd_bus_creds *creds = NULL;\n        int r;\n\n        test_setup_logging(LOG_DEBUG);\n\n        if (IN_SET(cg_unified(), -ENOMEDIUM, -ENOENT))\n                return log_tests_skipped(\"/sys/fs/cgroup/ not available\");\n\n        r = sd_bus_creds_new_from_pid(&creds, 0, _SD_BUS_CREDS_ALL);\n        log_full_errno(r < 0 ? LOG_ERR : LOG_DEBUG, r, \"sd_bus_creds_new_from_pid: %m\");\n        assert_se(r >= 0);\n\n        bus_creds_dump(creds, NULL, true);\n\n        creds = sd_bus_creds_unref(creds);\n\n        r = sd_bus_creds_new_from_pid(&creds, 1, _SD_BUS_CREDS_ALL);\n        if (!ERRNO_IS_NEG_PRIVILEGE(r)) {\n                assert_se(r >= 0);\n                putchar('\\n');\n                bus_creds_dump(creds, NULL, true);\n        }\n\n        creds = sd_bus_creds_unref(creds);\n\n        _cleanup_(sd_bus_unrefp) sd_bus *bus = NULL;\n        r = sd_bus_default_system(&bus);\n        if (r < 0)\n                log_warning_errno(r, \"Unable to connect to system bus, skipping rest of test.\");\n        else {\n                const char *unique;\n\n                assert_se(sd_bus_get_unique_name(bus, &unique) >= 0);\n\n                r = sd_bus_get_name_creds(bus, unique, _SD_BUS_CREDS_ALL, &creds);\n                log_full_errno(r < 0 ? LOG_ERR : LOG_DEBUG, r, \"sd_bus_get_name_creds: %m\");\n                assert_se(r >= 0);\n\n                putchar('\\n');\n                bus_creds_dump(creds, NULL, true);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "50μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "26μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "153921μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "201224μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "77570μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "7228μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "39μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "440058μs",
      "parallelizable_steps": [],
      "critical_path_length": "231580μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 1.282051282051282
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 1.282051282051282,
        "content_hash": "5ce28f9ac4994139"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-bus/test-bus-creds.c"
      }
    },
    "source_hash": "7794db63eaf2"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-architecture.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"architecture.h\"\n#include \"errno-util.h\"\n#include \"log.h\"\n#include \"path-util.h\"\n#include \"tests.h\"\n#include \"virt.h\"\n\nint main(int argc, char *argv[]) {\n        Virtualization v;\n        Architecture a;\n        const char *p;\n\n        test_setup_logging(LOG_INFO);\n\n        ASSERT_LT(architecture_from_string(\"\"), 0);\n        ASSERT_LT(architecture_from_string(NULL), 0);\n        ASSERT_LT(architecture_from_string(\"hoge\"), 0);\n        ASSERT_NULL(architecture_to_string(-1));\n        ASSERT_EQ(architecture_from_string(architecture_to_string(0)), 0);\n        ASSERT_EQ(architecture_from_string(architecture_to_string(1)), 1);\n\n        v = detect_virtualization();\n        if (ERRNO_IS_NEG_PRIVILEGE(v))\n                return log_tests_skipped(\"Cannot detect virtualization\");\n\n        ASSERT_OK(v);\n\n        log_info(\"virtualization=%s id=%s\",\n                 VIRTUALIZATION_IS_CONTAINER(v) ? \"container\" :\n                 VIRTUALIZATION_IS_VM(v)        ? \"vm\" : \"n/a\",\n                 virtualization_to_string(v));\n\n        a = uname_architecture();\n        ASSERT_OK(a);\n\n        p = architecture_to_string(a);\n        assert_se(p);\n        log_info(\"uname architecture=%s\", p);\n        ASSERT_EQ(architecture_from_string(p), a);\n\n        a = native_architecture();\n        ASSERT_OK(a);\n\n        p = architecture_to_string(a);\n        assert_se(p);\n        log_info(\"native architecture=%s\", p);\n        ASSERT_EQ(architecture_from_string(p), a);\n\n        log_info(\"primary library architecture=\" LIB_ARCH_TUPLE);\n\n        for (Architecture i = 0; i < _ARCHITECTURE_MAX; i++) {\n                const char *n = ASSERT_PTR(architecture_to_string(i));\n\n                /* Let's validate that all architecture names we define are good for inclusion in .v/\n                 * filename patterns which use \".\" and \"_\" as field separators in the filenames. */\n                assert(filename_part_is_valid(n));\n                assert(!strchr(n, '_'));\n                assert(!strchr(n, '.'));\n\n                log_info(\"Good for inclusion in .v/ filenames: %s\", n);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "21μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "69μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "11538μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "197μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "118μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "11943μs",
      "parallelizable_steps": [],
      "critical_path_length": "11677μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 1.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 1.0,
        "content_hash": "49f4c4f0fc800356"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-architecture.c"
      }
    },
    "source_hash": "0cf9caaa4b04"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/filter.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n/*\n * Linux Socket Filter Data Structures\n */\n\n#ifndef __LINUX_FILTER_H__\n#define __LINUX_FILTER_H__\n\n\n#include <linux/types.h>\n#include <linux/bpf_common.h>\n\n/*\n * Current version of the filter code architecture.\n */\n#define BPF_MAJOR_VERSION 1\n#define BPF_MINOR_VERSION 1\n\n/*\n *\tTry and keep these values and structures similar to BSD, especially\n *\tthe BPF code definitions which need to match so you can share filters\n */\n \nstruct sock_filter {\t/* Filter block */\n\t__u16\tcode;   /* Actual filter code */\n\t__u8\tjt;\t/* Jump true */\n\t__u8\tjf;\t/* Jump false */\n\t__u32\tk;      /* Generic multiuse field */\n};\n\nstruct sock_fprog {\t/* Required for SO_ATTACH_FILTER. */\n\tunsigned short\t\tlen;\t/* Number of filter blocks */\n\tstruct sock_filter *filter;\n};\n\n/* ret - BPF_K and BPF_X also apply */\n#define BPF_RVAL(code)  ((code) & 0x18)\n#define         BPF_A           0x10\n\n/* misc */\n#define BPF_MISCOP(code) ((code) & 0xf8)\n#define         BPF_TAX         0x00\n#define         BPF_TXA         0x80\n\n/*\n * Macros for filter block array initializers.\n */\n#ifndef BPF_STMT\n#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }\n#endif\n#ifndef BPF_JUMP\n#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }\n#endif\n\n/*\n * Number of scratch memory words for: BPF_ST and BPF_STX\n */\n#define BPF_MEMWORDS 16\n\n/* RATIONALE. Negative offsets are invalid in BPF.\n   We use them to reference ancillary data.\n   Unlike introduction new instructions, it does not break\n   existing compilers/optimizers.\n */\n#define SKF_AD_OFF    (-0x1000)\n#define SKF_AD_PROTOCOL 0\n#define SKF_AD_PKTTYPE \t4\n#define SKF_AD_IFINDEX \t8\n#define SKF_AD_NLATTR\t12\n#define SKF_AD_NLATTR_NEST\t16\n#define SKF_AD_MARK \t20\n#define SKF_AD_QUEUE\t24\n#define SKF_AD_HATYPE\t28\n#define SKF_AD_RXHASH\t32\n#define SKF_AD_CPU\t36\n#define SKF_AD_ALU_XOR_X\t40\n#define SKF_AD_VLAN_TAG\t44\n#define SKF_AD_VLAN_TAG_PRESENT 48\n#define SKF_AD_PAY_OFFSET\t52\n#define SKF_AD_RANDOM\t56\n#define SKF_AD_VLAN_TPID\t60\n#define SKF_AD_MAX\t64\n\n#define SKF_NET_OFF\t(-0x100000)\n#define SKF_LL_OFF\t(-0x200000)\n\n#define BPF_NET_OFF\tSKF_NET_OFF\n#define BPF_LL_OFF\tSKF_LL_OFF\n\n#endif /* __LINUX_FILTER_H__ */\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "249μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "128μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "299483μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "257782μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "243724μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "3901μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "114μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "805381μs",
      "parallelizable_steps": [],
      "critical_path_length": "543570μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.7333333333333334
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.7333333333333334,
        "content_hash": "aeb1560f02eff26d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/filter.h"
      }
    },
    "source_hash": "b670217b8af4"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/reply-password/reply-password.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"socket-util.h\"\n#include \"string-util.h\"\n\nstatic int send_on_socket(int fd, const char *socket_name, const void *packet, size_t size) {\n        union sockaddr_union sa = {};\n        int salen;\n\n        assert(fd >= 0);\n        assert(socket_name);\n        assert(packet);\n\n        salen = sockaddr_un_set_path(&sa.un, socket_name);\n        if (salen < 0)\n                return log_error_errno(salen, \"Specified socket path for AF_UNIX socket invalid, refusing: %s\", socket_name);\n\n        if (sendto(fd, packet, size, MSG_NOSIGNAL, &sa.sa, salen) < 0)\n                return log_error_errno(errno, \"Failed to send: %m\");\n\n        return 0;\n}\n\nstatic int run(int argc, char *argv[]) {\n        _cleanup_(erase_and_freep) char *packet = NULL;\n        _cleanup_close_ int fd = -EBADF;\n        size_t length = 0;\n        int r;\n\n        log_setup();\n\n        if (argc != 3)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), \"Wrong number of arguments.\");\n\n        if (streq(argv[1], \"1\")) {\n                _cleanup_(erase_and_freep) char *line = NULL;\n\n                r = read_line(stdin, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to read password: %m\");\n                if (r == 0)\n                        return log_error_errno(SYNTHETIC_ERRNO(EIO),\n                                               \"Got EOF while reading password.\");\n\n                packet = strjoin(\"+\", line);\n                if (!packet)\n                        return log_oom();\n\n                length = 1 + strlen(line) + 1;\n\n        } else if (streq(argv[1], \"0\")) {\n                packet = strdup(\"-\");\n                if (!packet)\n                        return log_oom();\n\n                length = 1;\n\n        } else\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Invalid first argument %s\", argv[1]);\n\n        fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);\n        if (fd < 0)\n                return log_error_errno(errno, \"socket() failed: %m\");\n\n        return send_on_socket(fd, argv[2], packet, length);\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "171μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "12μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "514960μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "193571μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "397456μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "212708μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "73μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1318951μs",
      "parallelizable_steps": [],
      "critical_path_length": "912660μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926,
        "content_hash": "932f8f09d1d22307"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/reply-password/reply-password.c"
      }
    },
    "source_hash": "f7b2248228d4"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscfoo\n#define foosdndiscfoo\n\n/***\n  Copyright © 2014 Intel Corporation. All rights reserved.\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n#include \"sd-ndisc-neighbor.h\"  /* IWYU pragma: export */\n#include \"sd-ndisc-protocol.h\"  /* IWYU pragma: export */\n#include \"sd-ndisc-redirect.h\"  /* IWYU pragma: export */\n#include \"sd-ndisc-router.h\"    /* IWYU pragma: export */\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in6_addr;\n\ntypedef struct sd_event sd_event;\ntypedef struct sd_ndisc sd_ndisc;\n\n__extension__ typedef enum _SD_ENUM_TYPE_S64(sd_ndisc_event_t) {\n        SD_NDISC_EVENT_TIMEOUT,\n        SD_NDISC_EVENT_ROUTER,\n        SD_NDISC_EVENT_NEIGHBOR,\n        SD_NDISC_EVENT_REDIRECT,\n        _SD_NDISC_EVENT_MAX,\n        _SD_NDISC_EVENT_INVALID = -EINVAL,\n        _SD_ENUM_FORCE_S64(NDISC_EVENT)\n} sd_ndisc_event_t;\n\ntypedef void (*sd_ndisc_callback_t)(sd_ndisc *nd, sd_ndisc_event_t event, void *message, void *userdata);\n\nint sd_ndisc_new(sd_ndisc **ret);\nsd_ndisc *sd_ndisc_ref(sd_ndisc *nd);\nsd_ndisc *sd_ndisc_unref(sd_ndisc *nd);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc, sd_ndisc_unref);\n\nint sd_ndisc_start(sd_ndisc *nd);\nint sd_ndisc_stop(sd_ndisc *nd);\nint sd_ndisc_is_running(sd_ndisc *nd);\n\nint sd_ndisc_attach_event(sd_ndisc *nd, sd_event *event, int64_t priority);\nint sd_ndisc_detach_event(sd_ndisc *nd);\nsd_event *sd_ndisc_get_event(sd_ndisc *nd);\n\nint sd_ndisc_set_callback(sd_ndisc *nd, sd_ndisc_callback_t cb, void *userdata);\nint sd_ndisc_set_ifindex(sd_ndisc *nd, int interface_index);\nint sd_ndisc_set_ifname(sd_ndisc *nd, const char *interface_name);\nint sd_ndisc_get_ifname(sd_ndisc *nd, const char **ret);\nint sd_ndisc_set_link_local_address(sd_ndisc *nd, const struct in6_addr *addr);\nint sd_ndisc_set_mac(sd_ndisc *nd, const struct ether_addr *mac_addr);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "722μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "482262μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "782μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1738μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "475054μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "601μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "961159μs",
      "parallelizable_steps": [],
      "critical_path_length": "484601μs",
      "metadata": {
        "functions_found": [
          "void"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "void"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926,
        "content_hash": "85e51f248a4ce015"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc.h"
      }
    },
    "source_hash": "1bbc7ca7400f"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/bpf-compat.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <bpf/libbpf.h>\n\n/* libbpf has been moving quickly.\n * They added new symbols in the 0.x versions and shortly after removed\n * deprecated symbols in 1.0.\n * We only need bpf_map_create and libbpf_probe_bpf_prog_type so we work\n * around the incompatibility here by:\n *  - declaring both symbols, and looking for either depending on the libbpf\n *    so version we found\n *  - having helpers that automatically use the appropriate version behind the\n *    new API for easy cleanup later\n *\n * The advantage of doing this instead of only looking for the symbols declared at\n * compile time is that we can then load either the old or the new symbols at runtime\n * regardless of the version we were compiled with */\n\n/* declare the struct for libbpf <= 0.6.0 -- it causes no harm on newer versions */\nstruct bpf_map_create_opts;\n\n/* new symbols available from 0.7.0.\n * We need the symbols here:\n *  - after bpf_map_create_opts struct has been defined for older libbpf\n *  - before the compat static inline helpers that use them.\n * When removing this file move these back to bpf-dlopen.h */\nextern int (*sym_bpf_map_create)(enum bpf_map_type,  const char *, __u32, __u32, __u32, const struct bpf_map_create_opts *);\nextern struct bpf_map* (*sym_bpf_object__next_map)(const struct bpf_object *obj, const struct bpf_map *map);\n\n/* compat symbols removed in libbpf 1.0 */\nextern int (*sym_bpf_create_map)(enum bpf_map_type, int key_size, int value_size, int max_entries, __u32 map_flags);\n\n/* helpers to use the available variant behind new API */\nstatic inline int compat_bpf_map_create(enum bpf_map_type map_type,\n                const char *map_name,\n                __u32 key_size,\n                __u32 value_size,\n                __u32 max_entries,\n                const struct bpf_map_create_opts *opts) {\n        if (sym_bpf_map_create)\n                return sym_bpf_map_create(map_type, map_name, key_size,\n                                          value_size, max_entries, opts);\n\n        return sym_bpf_create_map(map_type, key_size, value_size, max_entries,\n                                  0 /* opts->map_flags, but opts is always NULL for us so skip build dependency on the type */);\n}\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "231μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "402μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "86919μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "500μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "374μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "88426μs",
      "parallelizable_steps": [],
      "critical_path_length": "87524μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 2.5,
        "content_hash": "c9f15363ba5037a6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/bpf-compat.h"
      }
    },
    "source_hash": "9cf4855c8ce5"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc-router-solicit.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscroutersolicitfoo\n#define foosdndiscroutersolicitfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\nstruct in6_addr;\nstruct ether_addr;\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_ndisc_router_solicit sd_ndisc_router_solicit;\n\nsd_ndisc_router_solicit *sd_ndisc_router_solicit_ref(sd_ndisc_router_solicit *rs);\nsd_ndisc_router_solicit *sd_ndisc_router_solicit_unref(sd_ndisc_router_solicit *rs);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc_router_solicit, sd_ndisc_router_solicit_unref);\n\nint sd_ndisc_router_solicit_get_sender_address(sd_ndisc_router_solicit *rs, struct in6_addr *ret);\nint sd_ndisc_router_solicit_get_sender_mac(sd_ndisc_router_solicit *rs, struct ether_addr *ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1137μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "763802μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "803μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "366540μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "132μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1132702μs",
      "parallelizable_steps": [],
      "critical_path_length": "764222μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 3.7037037037037033
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 3.7037037037037033,
        "content_hash": "db22055b973a256b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc-router-solicit.h"
      }
    },
    "source_hash": "3d1028b8e1f4"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/boot/shim.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * Port to systemd-boot\n * Copyright © 2017 Max Resch <resch.max@gmail.com>\n *\n * Security Policy Handling\n * Copyright © 2012 <James.Bottomley@HansenPartnership.com>\n * https://github.com/mjg59/efitools\n */\n#pragma once\n\n#include \"efi.h\"\n\nbool shim_loaded(void);\nbool shim_loader_available(void);\nEFI_STATUS shim_load_image(EFI_HANDLE parent, const EFI_DEVICE_PATH *device_path, bool boot_policy, EFI_HANDLE *ret_image);\nvoid shim_retain_protocol(void);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "107μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "121393μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "338μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "460μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "97730μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "252μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "220280μs",
      "parallelizable_steps": [],
      "critical_path_length": "122105μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666,
        "content_hash": "2ee369849fe3c603"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/boot/shim.h"
      }
    },
    "source_hash": "9589b3e48057"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/ipvlan.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <linux/if_arp.h>\n\n#include \"sd-netlink.h\"\n\n#include \"conf-parser.h\"\n#include \"ipvlan.h\"\n#include \"ipvlan-util.h\"\n#include \"networkd-link.h\"\n\nDEFINE_CONFIG_PARSE_ENUM(config_parse_ipvlan_mode, ipvlan_mode, IPVlanMode);\nDEFINE_CONFIG_PARSE_ENUM(config_parse_ipvlan_flags, ipvlan_flags, IPVlanFlags);\n\nstatic int netdev_ipvlan_fill_message_create(NetDev *netdev, Link *link, sd_netlink_message *req) {\n        assert(netdev);\n        assert(link);\n        assert(netdev->ifname);\n\n        IPVlan *m = netdev->kind == NETDEV_KIND_IPVLAN ? IPVLAN(netdev) : IPVTAP(netdev);\n        int r;\n\n        if (m->mode != _NETDEV_IPVLAN_MODE_INVALID) {\n                r = sd_netlink_message_append_u16(req, IFLA_IPVLAN_MODE, m->mode);\n                if (r < 0)\n                        return r;\n        }\n\n        if (m->flags != _NETDEV_IPVLAN_FLAGS_INVALID) {\n                r = sd_netlink_message_append_u16(req, IFLA_IPVLAN_FLAGS, m->flags);\n                if (r < 0)\n                        return r;\n        }\n\n        return 0;\n}\n\nstatic bool ipvlan_can_set_mac(NetDev *netdev, const struct hw_addr_data *hw_addr) {\n        assert(netdev);\n\n        /* MAC address cannot be updated. Even unchanged, IFLA_ADDRESS attribute cannot be set in the message. */\n        return netdev->ifindex <= 0;\n}\n\nstatic void ipvlan_init(NetDev *netdev) {\n        IPVlan *m = ASSERT_PTR(netdev)->kind == NETDEV_KIND_IPVLAN ? IPVLAN(netdev) : IPVTAP(netdev);\n\n        m->mode = _NETDEV_IPVLAN_MODE_INVALID;\n        m->flags = _NETDEV_IPVLAN_FLAGS_INVALID;\n}\n\nconst NetDevVTable ipvlan_vtable = {\n        .object_size = sizeof(IPVlan),\n        .init = ipvlan_init,\n        .sections = NETDEV_COMMON_SECTIONS \"IPVLAN\\0\",\n        .fill_message_create = netdev_ipvlan_fill_message_create,\n        .create_type = NETDEV_CREATE_STACKED,\n        .can_set_mac = ipvlan_can_set_mac,\n        .iftype = ARPHRD_ETHER,\n        .generate_mac = true,\n        .keep_existing = true,\n};\n\nconst NetDevVTable ipvtap_vtable = {\n        .object_size = sizeof(IPVlan),\n        .init = ipvlan_init,\n        .sections = NETDEV_COMMON_SECTIONS \"IPVTAP\\0\",\n        .fill_message_create = netdev_ipvlan_fill_message_create,\n        .create_type = NETDEV_CREATE_STACKED,\n        .can_set_mac = ipvlan_can_set_mac,\n        .iftype = ARPHRD_ETHER,\n        .generate_mac = true,\n        .keep_existing = true,\n};\n\nIPVlanMode link_get_ipvlan_mode(Link *link) {\n        assert(link);\n\n        if (!link->netdev || link->netdev->kind != NETDEV_KIND_IPVLAN)\n                return _NETDEV_IPVLAN_MODE_INVALID;\n\n        return IPVLAN(link->netdev)->mode;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "314μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "186μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "40874μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "838μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "277μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "42489μs",
      "parallelizable_steps": [],
      "critical_path_length": "41465μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 2.153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 2.153846153846154,
        "content_hash": "62416f55d19d5125"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/ipvlan.c"
      }
    },
    "source_hash": "0974651a5c53"
  },
  {
    "instruction": "Analyze and decompose this grpc code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/boot/cpio.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"efi.h\"\n#include \"proto/loaded-image.h\"\n\nEFI_STATUS pack_cpio(\n                EFI_LOADED_IMAGE_PROTOCOL *loaded_image,\n                const char16_t *dropin_dir,\n                const char16_t *match_suffix,\n                const char16_t *exclude_suffix,\n                const char *target_dir_prefix,\n                uint32_t dir_mode,\n                uint32_t access_mode,\n                uint32_t tpm_pcr,\n                const char16_t *tpm_description,\n                struct iovec *ret_buffer,\n                bool *ret_measured);\n\nEFI_STATUS pack_cpio_literal(\n                const void *data,\n                size_t data_size,\n                const char *target_dir_prefix,\n                const char16_t *target_filename,\n                uint32_t dir_mode,\n                uint32_t access_mode,\n                uint32_t tpm_pcr,\n                const char16_t *tpm_description,\n                struct iovec *ret_buffer,\n                bool *ret_measured);\n",
    "output": {
      "operation": "Grpc Implementation",
      "category": "grpc",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "50μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "51μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "3771μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "103μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "20μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "3995μs",
      "parallelizable_steps": [],
      "critical_path_length": "3841μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 0.37037037037037035
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "grpc",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 0.37037037037037035,
        "content_hash": "16f45e0814e911a7"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/boot/cpio.h"
      }
    },
    "source_hash": "f0088adeeb7a"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-bus/bus-error.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-bus-protocol.h\"\n\n#include \"errno-util.h\"\n#include \"forward.h\"\n\nbool bus_error_is_dirty(sd_bus_error *e);\n\nconst char* _bus_error_message(const sd_bus_error *e, int error, char buf[static ERRNO_BUF_LEN]);\n\n/* Note: the lifetime of the compound literal is the immediately surrounding block,\n * see C11 §6.5.2.5, and\n * https://stackoverflow.com/questions/34880638/compound-literal-lifetime-and-if-blocks */\n#define bus_error_message(e, error) _bus_error_message(e, error, (char[ERRNO_BUF_LEN]){})\n\n#define BUS_ERROR_OOM SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_NO_MEMORY, \"Out of memory\")\n#define BUS_ERROR_FAILED SD_BUS_ERROR_MAKE_CONST(SD_BUS_ERROR_FAILED, \"Operation failed\")\n\n/*\n * There are two ways to register error maps with the error translation\n * logic: by using BUS_ERROR_MAP_ELF_REGISTER, which however only\n * works when linked into the same ELF module, or via\n * sd_bus_error_add_map() which is the official, external API, that\n * works from any module.\n *\n * Note that BUS_ERROR_MAP_ELF_REGISTER has to be used as decorator in\n * the bus error table, and BUS_ERROR_MAP_ELF_USE has to be used at\n * least once per compilation unit (i.e. per library), to ensure that\n * the error map is really added to the final binary.\n *\n * In addition, set the retain attribute so that the section cannot be\n * discarded by ld --gc-sections -z start-stop-gc. Older compilers would\n * warn for the unknown attribute, so just disable -Wattributes.\n */\n\n#define BUS_ERROR_MAP_ELF_REGISTER                                      \\\n        _Pragma(\"GCC diagnostic ignored \\\"-Wattributes\\\"\")              \\\n        _section_(\"SYSTEMD_BUS_ERROR_MAP\")                              \\\n        _used_                                                          \\\n        _retain_                                                        \\\n        _alignptr_                                                      \\\n        _variable_no_sanitize_address_\n\n#define BUS_ERROR_MAP_ELF_USE(errors)                                   \\\n        extern const sd_bus_error_map errors[];                         \\\n        _used_                                                          \\\n        static const sd_bus_error_map * const CONCATENATE(errors ## _copy_, __COUNTER__) = errors;\n\n/* We use something exotic as end marker, to ensure people build the\n * maps using the macsd-ros. */\n#define BUS_ERROR_MAP_END_MARKER -'x'\n\nBUS_ERROR_MAP_ELF_USE(bus_standard_errors);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "4μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "22635μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "259μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "34μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "22974μs",
      "parallelizable_steps": [],
      "critical_path_length": "22711μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 44,
        "complexity_score": 1.5909090909090908
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 44,
        "complexity_score": 1.5909090909090908,
        "content_hash": "f1a3132782b5d82f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-bus/bus-error.h"
      }
    },
    "source_hash": "1919182e2f89"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/confidential-virt-fundamental.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdint.h>\n\n/* Keep CVM detection logic in this file at feature parity with\n * that in src/efi/boot/vmm.c */\n\n#define CPUID_PROCESSOR_INFO_AND_FEATURE_BITS UINT32_C(0x1)\n\n/*\n * AMD64 Architecture Programmer’s Manual Volume 3:\n * General-Purpose and System Instructions.\n * Chapter: E4.1 - Maximum Extended Function Number and Vendor String\n *  https://www.amd.com/system/files/TechDocs/24594.pdf\n */\n#define CPUID_GET_HIGHEST_FUNCTION UINT32_C(0x80000000)\n\n/*\n * AMD64 Architecture Programmer’s Manual Volume 3:\n * General-Purpose and System Instructions.\n * Chapter: E4.17 - Encrypted Memory Capabilities\n *  https://www.amd.com/system/files/TechDocs/24594.pdf\n */\n#define CPUID_AMD_GET_ENCRYPTED_MEMORY_CAPABILITIES UINT32_C(0x8000001f)\n\n/*\n * AMD64 Architecture Programmer’s Manual Volume 3:\n * General-Purpose and System Instructions.\n * Chapter: 15.34.10 - SEV_STATUS MSR\n * https://www.amd.com/system/files/TechDocs/24593.pdf\n */\n#define MSR_AMD64_SEV UINT32_C(0xc0010131)\n\n/*\n * Intel® TDX Module v1.5 Base Architecture Specification\n * Chapter: 11.2\n * https://www.intel.com/content/www/us/en/content-details/733575/intel-tdx-module-v1-5-base-architecture-specification.html\n */\n\n#define CPUID_INTEL_TDX_ENUMERATION UINT32_C(0x21)\n\n/* Requirements for Implementing the Microsoft Hypervisor Interface\n * https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/tlfs/tlfs\n */\n#define CPUID_HYPERV_VENDOR_AND_MAX_FUNCTIONS UINT32_C(0x40000000)\n\n#define CPUID_HYPERV_FEATURES UINT32_C(0x40000003)\n\n#define CPUID_HYPERV_ISOLATION_CONFIG UINT32_C(0x4000000C)\n\n#define CPUID_HYPERV_MIN UINT32_C(0x40000005)\n#define CPUID_HYPERV_MAX UINT32_C(0x4000ffff)\n\n#define CPUID_SIG_AMD       \"AuthenticAMD\"\n#define CPUID_SIG_INTEL     \"GenuineIntel\"\n#define CPUID_SIG_INTEL_TDX \"IntelTDX    \"\n#define CPUID_SIG_HYPERV    \"Microsoft Hv\"\n\n/* ecx bit 31: set => hyperpvisor, unset => bare metal */\n#define CPUID_FEATURE_HYPERVISOR (UINT32_C(1) << 31)\n\n/* Linux include/asm-generic/hyperv-tlfs.h */\n#define CPUID_HYPERV_CPU_MANAGEMENT (UINT32_C(1) << 12) /* root partition */\n#define CPUID_HYPERV_ISOLATION      (UINT32_C(1) << 22) /* confidential VM partition */\n\n#define CPUID_HYPERV_ISOLATION_TYPE_MASK UINT32_C(0xf)\n#define CPUID_HYPERV_ISOLATION_TYPE_SNP 2\n#define CPUID_HYPERV_ISOLATION_TYPE_TDX 3\n\n#define EAX_SEV     (UINT32_C(1) << 1)\n#define MSR_SEV     (UINT64_C(1) << 0)\n#define MSR_SEV_ES  (UINT64_C(1) << 1)\n#define MSR_SEV_SNP (UINT64_C(1) << 2)\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "195μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "120451μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "350μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "240μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "37909μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "59μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "159204μs",
      "parallelizable_steps": [],
      "critical_path_length": "120750μs",
      "metadata": {
        "functions_found": [
          "UINT32_C"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.8928571428571429
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "UINT32_C"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.8928571428571429,
        "content_hash": "aafc9e27025a1c7c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/confidential-virt-fundamental.h"
      }
    },
    "source_hash": "a5486e1f4dd4"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/web-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\nbool http_url_is_valid(const char *url) _pure_;\nbool file_url_is_valid(const char *url) _pure_;\n\nbool documentation_url_is_valid(const char *url) _pure_;\n\nbool http_etag_is_valid(const char *etag);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "349μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "129μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "175385μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "635μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "405μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "176903μs",
      "parallelizable_steps": [],
      "critical_path_length": "176139μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 2.8571428571428568
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 2.8571428571428568,
        "content_hash": "a726c26d2ec4e4c3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/web-util.h"
      }
    },
    "source_hash": "ea8cc33bd341"
  },
  {
    "instruction": "Analyze and decompose this tcp_udp code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-sync.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"journald-forward.h\"\n#include \"list.h\"\n\n/* Encapsulates the synchronization request data we need to keep per STDOUT stream. Primarily a byte counter\n * to count down. */\ntypedef struct StreamSyncReq {\n        SyncReq *req;\n        StdoutStream *stream;\n\n        uint64_t pending_siocinq; /* The SIOCINQ counter when the sync was initiated */\n\n        LIST_FIELDS(StreamSyncReq, by_sync_req);\n        LIST_FIELDS(StreamSyncReq, by_stdout_stream);\n} StreamSyncReq;\n\n/* Encapsulates a synchronization request */\ntypedef struct SyncReq {\n        Manager *manager;\n        sd_varlink *link;\n\n        bool offline; /* if true, we'll offline the journal files after sync is complete */\n\n        usec_t realtime; /* CLOCK_REALTIME timestamp when synchronization request was initiated (for syncing on AF_UNIX/SOCK_DGRAM) */\n        usec_t boottime; /* CLOCK_BOOTTIME timestamp when synchronization request was initiated (for syncing on /dev/kmsg) */\n\n        sd_event_source *idle_event_source;\n\n        uint32_t pending_rqlen;   /* The rqlen counter on the stream AF_UNIX socket when the sync was initiated */\n        LIST_FIELDS(SyncReq, pending_rqlen);\n\n        LIST_HEAD(StreamSyncReq, stream_sync_reqs);\n\n        unsigned realtime_prioq_idx;\n        unsigned boottime_prioq_idx;\n} SyncReq;\n\nStreamSyncReq *stream_sync_req_free(StreamSyncReq *ssr);\nDEFINE_TRIVIAL_CLEANUP_FUNC(StreamSyncReq*, stream_sync_req_free);\nvoid stream_sync_req_advance_revalidate(StreamSyncReq *ssr, size_t p);\n\nint sync_req_new(Manager *m, sd_varlink *link, SyncReq **ret);\nSyncReq* sync_req_free(SyncReq *req);\nDEFINE_TRIVIAL_CLEANUP_FUNC(SyncReq*, sync_req_free);\n\nbool sync_req_revalidate(SyncReq *req);\nvoid sync_req_revalidate_by_timestamp(Manager *m);\n\nvoid manager_notify_stream(Manager *m, StdoutStream *stream);\n",
    "output": {
      "operation": "Tcp Udp Implementation",
      "category": "tcp_udp",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "142μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "268μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "58068μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "331μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "330μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "59139μs",
      "parallelizable_steps": [],
      "critical_path_length": "58540μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.6666666666666665
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "tcp_udp",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.6666666666666665,
        "content_hash": "167bd5759949b09a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-sync.h"
      }
    },
    "source_hash": "97f03f966832"
  },
  {
    "instruction": "Analyze and decompose this grpc code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-ntp.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nbool link_get_use_ntp(Link *link, NetworkConfigSource proto);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_ntp);\n",
    "output": {
      "operation": "Grpc Implementation",
      "category": "grpc",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "477μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "531μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "394853μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "24μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "228μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "396113μs",
      "parallelizable_steps": [],
      "critical_path_length": "395558μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "grpc",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "50a7407cfc841d40"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-ntp.h"
      }
    },
    "source_hash": "94db24968bc5"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/unit-serialize.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"core-forward.h\"\n\n/* These functions serialize state for our own usage, i.e.: across a reload/reexec, rather than for being\n * passed to a child process. */\n\nint unit_serialize_state(Unit *u, FILE *f, FDSet *fds, bool serialize_jobs);\nint unit_deserialize_state(Unit *u, FILE *f, FDSet *fds);\nint unit_deserialize_state_skip(FILE *f);\n\nvoid unit_dump(Unit *u, FILE *f, const char *prefix);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "198μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "675μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "251949μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1082μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "452μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "254356μs",
      "parallelizable_steps": [],
      "critical_path_length": "252599μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 9,
        "complexity_score": 4.444444444444445
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 9,
        "complexity_score": 4.444444444444445,
        "content_hash": "50002b339e5c5405"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/unit-serialize.h"
      }
    },
    "source_hash": "f6df3b251422"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/environment-d-generator/environment-d-generator.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdio.h>\n\n#include \"sd-path.h\"\n\n#include \"alloc-util.h\"\n#include \"conf-files.h\"\n#include \"constants.h\"\n#include \"env-file.h\"\n#include \"escape.h\"\n#include \"glyph-util.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n\nstatic int environment_dirs(char ***ret) {\n        _cleanup_strv_free_ char **dirs = NULL;\n        _cleanup_free_ char *c = NULL;\n        int r;\n\n        dirs = strv_new(CONF_PATHS(\"environment.d\"));\n        if (!dirs)\n                return -ENOMEM;\n\n        /* ~/.config/systemd/environment.d */\n        r = sd_path_lookup(SD_PATH_USER_CONFIGURATION, \"environment.d\", &c);\n        if (r < 0)\n                return r;\n\n        r = strv_consume_prepend(&dirs, TAKE_PTR(c));\n        if (r < 0)\n                return r;\n\n        if (DEBUG_LOGGING) {\n                _cleanup_free_ char *t = NULL;\n\n                t = strv_join(dirs, \"\\n\\t\");\n                log_debug(\"Looking for environment.d files in (higher priority first):\\n\\t%s\", strna(t));\n        }\n\n        *ret = TAKE_PTR(dirs);\n        return 0;\n}\n\nstatic int load_and_print(void) {\n        _cleanup_strv_free_ char **dirs = NULL, **files = NULL, **env = NULL;\n        int r;\n\n        r = environment_dirs(&dirs);\n        if (r < 0)\n                return r;\n\n        r = conf_files_list_strv(&files, \".conf\", NULL, 0, (const char **) dirs);\n        if (r < 0)\n                return r;\n\n        /* This will mutate the existing environment, based on the presumption\n         * that in case of failure, a partial update is better than none. */\n\n        STRV_FOREACH(i, files) {\n                log_debug(\"Reading %s%s\", *i, glyph(GLYPH_ELLIPSIS));\n\n                r = merge_env_file(&env, NULL, *i);\n                if (r == -ENOMEM)\n                        return r;\n        }\n\n        STRV_FOREACH(i, env) {\n                char *t;\n                _cleanup_free_ char *q = NULL;\n\n                t = strchr(*i, '=');\n                assert(t);\n\n                q = shell_maybe_quote(t + 1, 0);\n                if (!q)\n                        return log_oom();\n\n                printf(\"%.*s=%s\\n\", (int) (t - *i), *i, q);\n        }\n\n        return 0;\n}\n\nstatic int run(int argc, char *argv[]) {\n        int r;\n\n        log_setup();\n\n        if (argc > 1)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), \"This program takes no arguments.\");\n\n        r = load_and_print();\n        if (r < 0)\n                return log_error_errno(r, \"Failed to load environment.d: %m\");\n        return 0;\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "187μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "228μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "133672μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "606μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "301μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "134994μs",
      "parallelizable_steps": [],
      "critical_path_length": "134160μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.8666666666666667
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.8666666666666667,
        "content_hash": "106139ab001cb3dc"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/environment-d-generator/environment-d-generator.c"
      }
    },
    "source_hash": "0b3f667af223"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-ndisc.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <netinet/in.h>\n\n#include \"dns-resolver-internal.h\"\n#include \"networkd-forward.h\"\n\ntypedef enum IPv6AcceptRAStartDHCP6Client {\n        IPV6_ACCEPT_RA_START_DHCP6_CLIENT_NO,\n        IPV6_ACCEPT_RA_START_DHCP6_CLIENT_ALWAYS,\n        IPV6_ACCEPT_RA_START_DHCP6_CLIENT_YES,\n        _IPV6_ACCEPT_RA_START_DHCP6_CLIENT_MAX,\n        _IPV6_ACCEPT_RA_START_DHCP6_CLIENT_INVALID = -EINVAL,\n} IPv6AcceptRAStartDHCP6Client;\n\ntypedef struct NDiscRDNSS {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        struct in6_addr address;\n} NDiscRDNSS;\n\ntypedef struct NDiscDNSSL {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        /* The domain name follows immediately. */\n} NDiscDNSSL;\n\ntypedef struct NDiscCaptivePortal {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        char *captive_portal;\n} NDiscCaptivePortal;\n\ntypedef struct NDiscPREF64 {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        uint8_t prefix_len;\n        struct in6_addr prefix;\n} NDiscPREF64;\n\ntypedef struct NDiscDNR {\n        struct in6_addr router;\n        usec_t lifetime_usec;\n        sd_dns_resolver resolver;\n} NDiscDNR;\n\nchar* ndisc_dnssl_domain(const NDiscDNSSL *n);\n\nbool link_ndisc_enabled(Link *link);\n\nvoid network_adjust_ndisc(Network *network);\n\nint ndisc_start(Link *link);\nint ndisc_stop(Link *link);\nvoid ndisc_flush(Link *link);\n\nint link_request_ndisc(Link *link);\nint link_drop_ndisc_config(Link *link, Network *network);\nint ndisc_reconfigure_address(Address *address, Link *link);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_ndisc_start_dhcp6_client);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "483μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "81μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "507922μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "270315μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "69μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "38μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "778908μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "507991μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 2.6785714285714284
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 2.6785714285714284,
        "content_hash": "016332232358df3b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-ndisc.h"
      }
    },
    "source_hash": "3c8fad649d2c"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fuzz/fuzz-main.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdlib.h>\n\n#include \"alloc-util.h\"\n#include \"fileio.h\"\n#include \"fuzz.h\"\n#include \"log.h\"\n#include \"parse-util.h\"\n#include \"string-util.h\"\n#include \"tests.h\"\n\n/* This is a test driver for the systemd fuzzers that provides main function\n * for regression testing outside of oss-fuzz (https://github.com/google/oss-fuzz)\n *\n * It reads files named on the command line and passes them one by one into the\n * fuzzer that it is compiled into. */\n\n/* This one was borrowed from\n * https://github.com/google/oss-fuzz/blob/646fca1b506b056db3a60d32c4a1a7398f171c94/infra/base-images/base-runner/bad_build_check#L19\n */\n#define NUMBER_OF_RUNS 4\n\nint main(int argc, char **argv) {\n        int r;\n\n        test_setup_logging(LOG_DEBUG);\n\n        unsigned number_of_runs = NUMBER_OF_RUNS;\n\n        const char *v = getenv(\"SYSTEMD_FUZZ_RUNS\");\n        if (!isempty(v)) {\n                r = safe_atou(v, &number_of_runs);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to parse SYSTEMD_FUZZ_RUNS=%s: %m\", v);\n        }\n\n        for (int i = 1; i < argc; i++) {\n                _cleanup_free_ char *buf = NULL;\n                size_t size;\n                char *name;\n\n                name = argv[i];\n                r = read_full_file(name, &buf, &size);\n                if (r < 0) {\n                        log_error_errno(r, \"Failed to open '%s': %m\", name);\n                        return EXIT_FAILURE;\n                }\n                printf(\"%s... \", name);\n                fflush(stdout);\n                for (unsigned j = 0; j < number_of_runs; j++)\n                        if (LLVMFuzzerTestOneInput((uint8_t*)buf, size) == EXIT_TEST_SKIP)\n                                return EXIT_TEST_SKIP;\n                printf(\"ok\\n\");\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "275μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "624935μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "397μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1449μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "258106μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "71μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "885233μs",
      "parallelizable_steps": [],
      "critical_path_length": "626455μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 1.9148936170212765
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 1.9148936170212765,
        "content_hash": "a331fd5aeeaa8d82"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fuzz/fuzz-main.c"
      }
    },
    "source_hash": "6c6e4b90ffd9"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/login/logind-utmp.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"logind-forward.h\"\n\nint manager_read_utmp(Manager *m);\nvoid manager_connect_utmp(Manager *m);\nvoid manager_reconnect_utmp(Manager *m);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "651μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "128μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "133838μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "247μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "465μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "135329μs",
      "parallelizable_steps": [],
      "critical_path_length": "134954μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 6,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 6,
        "complexity_score": 3.333333333333333,
        "content_hash": "baa2f70d3443e28e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/login/logind-utmp.h"
      }
    },
    "source_hash": "414cbface573"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/ima-setup.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/***\n  Copyright © 2012 Roberto Sassu - Politecnico di Torino, Italy\n                                   TORSEC group — http://security.polito.it\n***/\n\n#include <fcntl.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"ima-setup.h\"\n#include \"log.h\"\n\n#define IMA_SECFS_DIR \"/sys/kernel/security/ima\"\n#define IMA_SECFS_POLICY IMA_SECFS_DIR \"/policy\"\n#define IMA_POLICY_PATH \"/etc/ima/ima-policy\"\n\nint ima_setup(void) {\n#if ENABLE_IMA\n        _cleanup_fclose_ FILE *input = NULL;\n        _cleanup_close_ int imafd = -EBADF;\n        unsigned lineno = 0;\n        int r;\n\n        if (access(IMA_SECFS_DIR, F_OK) < 0) {\n                log_debug_errno(errno, \"IMA support is disabled in the kernel, ignoring: %m\");\n                return 0;\n        }\n\n        if (access(IMA_SECFS_POLICY, W_OK) < 0) {\n                log_warning_errno(errno, \"Another IMA custom policy has already been loaded, ignoring: %m\");\n                return 0;\n        }\n\n        if (access(IMA_POLICY_PATH, F_OK) < 0) {\n                log_debug_errno(errno, \"No IMA custom policy file \"IMA_POLICY_PATH\", ignoring: %m\");\n                return 0;\n        }\n\n        imafd = open(IMA_SECFS_POLICY, O_WRONLY|O_CLOEXEC);\n        if (imafd < 0) {\n                log_error_errno(errno, \"Failed to open the IMA kernel interface \"IMA_SECFS_POLICY\", ignoring: %m\");\n                return 0;\n        }\n\n        /* attempt to write the name of the policy file into sysfs file */\n        if (write(imafd, IMA_POLICY_PATH, STRLEN(IMA_POLICY_PATH)) > 0)\n                goto done;\n\n        /* fall back to copying the policy line-by-line */\n        input = fopen(IMA_POLICY_PATH, \"re\");\n        if (!input) {\n                log_warning_errno(errno, \"Failed to open the IMA custom policy file \"IMA_POLICY_PATH\", ignoring: %m\");\n                return 0;\n        }\n\n        safe_close(imafd);\n\n        imafd = open(IMA_SECFS_POLICY, O_WRONLY|O_CLOEXEC);\n        if (imafd < 0) {\n                log_error_errno(errno, \"Failed to open the IMA kernel interface \"IMA_SECFS_POLICY\", ignoring: %m\");\n                return 0;\n        }\n\n        for (;;) {\n                _cleanup_free_ char *line = NULL;\n                size_t len;\n\n                r = read_line(input, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to read the IMA custom policy file \"IMA_POLICY_PATH\": %m\");\n                if (r == 0)\n                        break;\n\n                len = strlen(line);\n                lineno++;\n\n                if (len > 0 && write(imafd, line, len) < 0)\n                        return log_error_errno(errno, \"Failed to load the IMA custom policy file \"IMA_POLICY_PATH\"%u: %m\",\n                                               lineno);\n        }\n\ndone:\n        log_info(\"Successfully loaded the IMA custom policy \"IMA_POLICY_PATH\".\");\n#endif /* ENABLE_IMA */\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "17μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "380μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "70530μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "49μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "128μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "71104μs",
      "parallelizable_steps": [],
      "critical_path_length": "70675μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 72,
        "complexity_score": 1.9444444444444444
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 72,
        "complexity_score": 1.9444444444444444,
        "content_hash": "b5f6bf4aa43a1605"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/ima-setup.c"
      }
    },
    "source_hash": "c52e7bb5631b"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/ipvlan-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"ipvlan-util.h\"\n#include \"string-table.h\"\n\nstatic const char* const ipvlan_mode_table[_NETDEV_IPVLAN_MODE_MAX] = {\n        [NETDEV_IPVLAN_MODE_L2] = \"L2\",\n        [NETDEV_IPVLAN_MODE_L3] = \"L3\",\n        [NETDEV_IPVLAN_MODE_L3S] = \"L3S\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(ipvlan_mode, IPVlanMode);\n\nstatic const char* const ipvlan_flags_table[_NETDEV_IPVLAN_FLAGS_MAX] = {\n        [NETDEV_IPVLAN_FLAGS_BRIGDE] = \"bridge\",\n        [NETDEV_IPVLAN_FLAGS_PRIVATE] = \"private\",\n        [NETDEV_IPVLAN_FLAGS_VEPA] = \"vepa\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(ipvlan_flags, IPVlanFlags);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "123μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "51μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "4446μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "37μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "90μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "4747μs",
      "parallelizable_steps": [],
      "critical_path_length": "4659μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666,
        "content_hash": "a6012dca9834c694"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/ipvlan-util.c"
      }
    },
    "source_hash": "c0c637763267"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-forward.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"conf-parser-forward.h\"    /* IWYU pragma: export */\n#include \"forward.h\"                /* IWYU pragma: export */\n\ntypedef enum NetDevLocalAddressType NetDevLocalAddressType;\ntypedef enum NetworkConfigSource NetworkConfigSource;\n\ntypedef struct Address Address;\ntypedef struct IPv6Token IPv6Token;\ntypedef struct Link Link;\ntypedef struct Manager Manager;\ntypedef struct NetDev NetDev;\ntypedef struct Network Network;\ntypedef struct NextHop NextHop;\ntypedef struct Request Request;\ntypedef struct Route Route;\ntypedef struct Wireguard Wireguard;\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "281μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "112μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "19166μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "142μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "346μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "20047μs",
      "parallelizable_steps": [],
      "critical_path_length": "19793μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 16,
        "complexity_score": 1.875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 16,
        "complexity_score": 1.875,
        "content_hash": "62917d46a28a4ed0"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-forward.h"
      }
    },
    "source_hash": "f639a2dfdab6"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dnssd-bus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#include \"forward.h\"\n\nextern const BusObjectImplementation dnssd_object;\n\nint bus_dnssd_method_unregister(sd_bus_message *message, void *userdata, sd_bus_error *error);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "229μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "117μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "231261μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "767805μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "45μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "52μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "999509μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "767974μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "308505f87cfcc600"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dnssd-bus.h"
      }
    },
    "source_hash": "fd0fa6b76ab9"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp-client-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-dhcp-client.h\"\n\n#include \"forward.h\"\n#include \"network-common.h\"\n\ntypedef enum DHCPState {\n        DHCP_STATE_STOPPED,\n        DHCP_STATE_INIT,\n        DHCP_STATE_SELECTING,\n        DHCP_STATE_INIT_REBOOT,\n        DHCP_STATE_REBOOTING,\n        DHCP_STATE_REQUESTING,\n        DHCP_STATE_BOUND,\n        DHCP_STATE_RENEWING,\n        DHCP_STATE_REBINDING,\n        _DHCP_STATE_MAX,\n        _DHCP_STATE_INVALID                     = -EINVAL,\n} DHCPState;\n\nconst char* dhcp_state_to_string(DHCPState s) _const_;\n\ntypedef struct sd_dhcp_client sd_dhcp_client;\n\nint dhcp_client_set_state_callback(\n                sd_dhcp_client *client,\n                sd_dhcp_client_callback_t cb,\n                void *userdata);\nint dhcp_client_get_state(sd_dhcp_client *client);\n\n/* If we are invoking callbacks of a dhcp-client, ensure unreffing the\n * client from the callback doesn't destroy the object we are working\n * on */\n#define DHCP_CLIENT_DONT_DESTROY(client) \\\n        _cleanup_(sd_dhcp_client_unrefp) _unused_ sd_dhcp_client *_dont_destroy_##client = sd_dhcp_client_ref(client)\n\n#define log_dhcp_client_errno(client, error, fmt, ...)          \\\n        log_interface_prefix_full_errno(                        \\\n                \"DHCPv4 client: \",                              \\\n                sd_dhcp_client, client,                         \\\n                error, fmt, ##__VA_ARGS__)\n#define log_dhcp_client(client, fmt, ...)                       \\\n        log_interface_prefix_full_errno_zerook(                 \\\n                \"DHCPv4 client: \",                              \\\n                sd_dhcp_client, client,                         \\\n                0, fmt, ##__VA_ARGS__)\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "14μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "109μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "1794μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "196μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2148μs",
      "parallelizable_steps": [],
      "critical_path_length": "1843μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 0.75
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 0.75,
        "content_hash": "8913b780aff4d209"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp-client-internal.h"
      }
    },
    "source_hash": "68771c314224"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-radv.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n/***\n  Copyright © 2017 Intel Corporation. All rights reserved.\n***/\n\n#include \"ndisc-option.h\"\n#include \"networkd-forward.h\"\n\ntypedef enum RADVPrefixDelegation {\n        RADV_PREFIX_DELEGATION_NONE   = 0,\n        RADV_PREFIX_DELEGATION_STATIC = 1 << 0,\n        RADV_PREFIX_DELEGATION_DHCP6  = 1 << 1,\n        RADV_PREFIX_DELEGATION_BOTH   = RADV_PREFIX_DELEGATION_STATIC | RADV_PREFIX_DELEGATION_DHCP6,\n        _RADV_PREFIX_DELEGATION_MAX,\n        _RADV_PREFIX_DELEGATION_INVALID = -EINVAL,\n} RADVPrefixDelegation;\n\ntypedef struct Prefix {\n        Network *network;\n        ConfigSection *section;\n\n        sd_ndisc_prefix prefix;\n\n        bool assign;\n        uint32_t route_metric;\n        Set *tokens;\n} Prefix;\n\ntypedef struct RoutePrefix {\n        Network *network;\n        ConfigSection *section;\n\n        sd_ndisc_route route;\n} RoutePrefix;\n\ntypedef struct Prefix64 {\n        Network *network;\n        ConfigSection *section;\n\n        sd_ndisc_prefix64 prefix64;\n} Prefix64;\n\nvoid network_adjust_radv(Network *network);\n\nint link_request_radv_addresses(Link *link);\nint link_reconfigure_radv_address(Address *address, Link *link);\n\nbool link_radv_enabled(Link *link);\nint radv_start(Link *link);\nint radv_update_mac(Link *link);\nint radv_add_prefix(Link *link, const struct in6_addr *prefix, uint8_t prefix_len,\n                    usec_t lifetime_preferred_usec, usec_t lifetime_valid_usec);\n\nint link_request_radv(Link *link);\nint link_drop_radv_config(Link *link, Network *network);\n\nconst char* radv_prefix_delegation_to_string(RADVPrefixDelegation i) _const_;\nRADVPrefixDelegation radv_prefix_delegation_from_string(const char *s) _pure_;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_router_prefix_delegation);\nCONFIG_PARSER_PROTOTYPE(config_parse_router_lifetime);\nCONFIG_PARSER_PROTOTYPE(config_parse_router_uint32_msec_usec);\nCONFIG_PARSER_PROTOTYPE(config_parse_router_preference);\nCONFIG_PARSER_PROTOTYPE(config_parse_prefix);\nCONFIG_PARSER_PROTOTYPE(config_parse_prefix_boolean);\nCONFIG_PARSER_PROTOTYPE(config_parse_prefix_lifetime);\nCONFIG_PARSER_PROTOTYPE(config_parse_prefix_metric);\nCONFIG_PARSER_PROTOTYPE(config_parse_prefix_token);\nCONFIG_PARSER_PROTOTYPE(config_parse_radv_dns);\nCONFIG_PARSER_PROTOTYPE(config_parse_radv_search_domains);\nCONFIG_PARSER_PROTOTYPE(config_parse_route_prefix);\nCONFIG_PARSER_PROTOTYPE(config_parse_route_prefix_lifetime);\nCONFIG_PARSER_PROTOTYPE(config_parse_route_prefix_preference);\nCONFIG_PARSER_PROTOTYPE(config_parse_pref64_prefix);\nCONFIG_PARSER_PROTOTYPE(config_parse_pref64_prefix_lifetime);\nCONFIG_PARSER_PROTOTYPE(config_parse_router_home_agent_lifetime);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "30μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "6μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "79224μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "268μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "15μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "79543μs",
      "parallelizable_steps": [],
      "critical_path_length": "79269μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 1.4516129032258065
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 1.4516129032258065,
        "content_hash": "84dad29abace6b29"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-radv.h"
      }
    },
    "source_hash": "a38e1fc82a0d"
  },
  {
    "instruction": "Analyze and decompose this proxy_tunneling code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/ip6_tunnel.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _IP6_TUNNEL_H\n#define _IP6_TUNNEL_H\n\n#include <linux/types.h>\n#include <linux/if.h>\t\t/* For IFNAMSIZ. */\n#include <linux/in6.h>\t\t/* For struct in6_addr. */\n\n#define IPV6_TLV_TNL_ENCAP_LIMIT 4\n#define IPV6_DEFAULT_TNL_ENCAP_LIMIT 4\n\n/* don't add encapsulation limit if one isn't present in inner packet */\n#define IP6_TNL_F_IGN_ENCAP_LIMIT 0x1\n/* copy the traffic class field from the inner packet */\n#define IP6_TNL_F_USE_ORIG_TCLASS 0x2\n/* copy the flowlabel from the inner packet */\n#define IP6_TNL_F_USE_ORIG_FLOWLABEL 0x4\n/* being used for Mobile IPv6 */\n#define IP6_TNL_F_MIP6_DEV 0x8\n/* copy DSCP from the outer packet */\n#define IP6_TNL_F_RCV_DSCP_COPY 0x10\n/* copy fwmark from inner packet */\n#define IP6_TNL_F_USE_ORIG_FWMARK 0x20\n/* allow remote endpoint on the local node */\n#define IP6_TNL_F_ALLOW_LOCAL_REMOTE 0x40\n\nstruct ip6_tnl_parm {\n\tchar name[IFNAMSIZ];\t/* name of tunnel device */\n\tint link;\t\t/* ifindex of underlying L2 interface */\n\t__u8 proto;\t\t/* tunnel protocol */\n\t__u8 encap_limit;\t/* encapsulation limit for tunnel */\n\t__u8 hop_limit;\t\t/* hop limit for tunnel */\n\t__be32 flowinfo;\t/* traffic class and flowlabel for tunnel */\n\t__u32 flags;\t\t/* tunnel flags */\n\tstruct in6_addr laddr;\t/* local tunnel end-point address */\n\tstruct in6_addr raddr;\t/* remote tunnel end-point address */\n};\n\nstruct ip6_tnl_parm2 {\n\tchar name[IFNAMSIZ];\t/* name of tunnel device */\n\tint link;\t\t/* ifindex of underlying L2 interface */\n\t__u8 proto;\t\t/* tunnel protocol */\n\t__u8 encap_limit;\t/* encapsulation limit for tunnel */\n\t__u8 hop_limit;\t\t/* hop limit for tunnel */\n\t__be32 flowinfo;\t/* traffic class and flowlabel for tunnel */\n\t__u32 flags;\t\t/* tunnel flags */\n\tstruct in6_addr laddr;\t/* local tunnel end-point address */\n\tstruct in6_addr raddr;\t/* remote tunnel end-point address */\n\n\t__be16\t\t\ti_flags;\n\t__be16\t\t\to_flags;\n\t__be32\t\t\ti_key;\n\t__be32\t\t\to_key;\n};\n\n#endif\n",
    "output": {
      "operation": "Proxy Tunneling Implementation",
      "category": "proxy_tunneling",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "699μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "354μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "278960μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1360μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "722μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "282095μs",
      "parallelizable_steps": [],
      "critical_path_length": "280381μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 4.081632653061225
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "proxy_tunneling",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 4.081632653061225,
        "content_hash": "e8dec4d84ffc451e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/ip6_tunnel.h"
      }
    },
    "source_hash": "0142f4f3a93c"
  },
  {
    "instruction": "Decompose the network operation: gRPC Service Call",
    "input": "Analyze the step-by-step process for: gRPC Service Call",
    "output": {
      "operation": "gRPC Service Call",
      "category": "grpc",
      "steps": [
        {
          "step": 1,
          "action": "Serialize protobuf message",
          "expected_time": "962μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Establish HTTP/2 stream",
          "expected_time": "877782μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Send gRPC headers and metadata",
          "expected_time": "476721μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Stream request message",
          "expected_time": "176113μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Receive and deserialize response",
          "expected_time": "461μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Handle gRPC status and trailers",
          "expected_time": "29μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "1532068μs",
      "parallelizable_steps": [],
      "critical_path_length": "1053924μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "grpc",
      "complexity": "medium",
      "code_analysis": null
    },
    "source_hash": "08281a6d1938"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/escape.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/* What characters are special in the shell? */\n/* must be escaped outside and inside double-quotes */\n#define SHELL_NEED_ESCAPE \"\\\"\\\\`$\"\n\n/* Those that can be escaped or double-quoted.\n *\n * Strictly speaking, ! does not need to be escaped, except in interactive\n * mode, but let's be extra nice to the user and quote ! in case this\n * output is ever used in interactive mode. */\n#define SHELL_NEED_QUOTES SHELL_NEED_ESCAPE GLOB_CHARS \"'()<>|&;!\"\n\n/* Note that we assume control characters would need to be escaped too in\n * addition to the \"special\" characters listed here, if they appear in the\n * string. Current users disallow control characters. Also '\"' shall not\n * be escaped.\n */\n#define SHELL_NEED_ESCAPE_POSIX \"\\\\\\'\"\n\ntypedef enum UnescapeFlags {\n        UNESCAPE_RELAX      = 1 << 0,\n        UNESCAPE_ACCEPT_NUL = 1 << 1,\n} UnescapeFlags;\n\ntypedef enum ShellEscapeFlags {\n        /* The default is to add shell quotes (\"\") so the shell will consider this a single argument.\n         * Tabs and newlines are escaped. */\n\n        SHELL_ESCAPE_POSIX = 1 << 1, /* Use POSIX shell escape syntax (a string enclosed in $'') instead of plain quotes. */\n        SHELL_ESCAPE_EMPTY = 1 << 2, /* Format empty arguments as \"\". */\n} ShellEscapeFlags;\n\nint cescape_char(char c, char *buf);\nchar* cescape_length(const char *s, size_t n) _nonnull_if_nonzero_(1, 2);\nstatic inline char* cescape(const char *s) {\n        return cescape_length(s, SIZE_MAX);\n}\n\nint cunescape_one(const char *p, size_t length, char32_t *ret, bool *eight_bit, bool accept_nul);\n\nssize_t cunescape_length_with_prefix(const char *s, size_t length, const char *prefix, UnescapeFlags flags, char **ret);\nstatic inline ssize_t cunescape_length(const char *s, size_t length, UnescapeFlags flags, char **ret) {\n        return cunescape_length_with_prefix(s, length, NULL, flags, ret);\n}\nstatic inline ssize_t cunescape(const char *s, UnescapeFlags flags, char **ret) {\n        return cunescape_length(s, SIZE_MAX, flags, ret);\n}\n\ntypedef enum XEscapeFlags {\n        XESCAPE_8_BIT          = 1 << 0,\n        XESCAPE_FORCE_ELLIPSIS = 1 << 1,\n} XEscapeFlags;\n\nchar* xescape_full(const char *s, const char *bad, size_t console_width, XEscapeFlags flags);\nstatic inline char* xescape(const char *s, const char *bad) {\n        return xescape_full(s, bad, SIZE_MAX, 0);\n}\nchar* octescape(const char *s, size_t len);\nchar* decescape(const char *s, size_t len, const char *bad) _nonnull_if_nonzero_(1, 2);\nchar* escape_non_printable_full(const char *str, size_t console_width, XEscapeFlags flags);\n\nchar* shell_escape(const char *s, const char *bad);\nchar* shell_maybe_quote(const char *s, ShellEscapeFlags flags);\nchar* quote_command_line(char * const *argv, ShellEscapeFlags flags);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "69μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "277μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "73301μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "590μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "30μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "74267μs",
      "parallelizable_steps": [],
      "critical_path_length": "73400μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 1.8181818181818183,
        "content_hash": "58cfcd44131121db"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/escape.h"
      }
    },
    "source_hash": "aa50571a2fac"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-ipv6-proxy-ndp.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nvoid network_adjust_ipv6_proxy_ndp(Network *network);\n\nint link_request_static_ipv6_proxy_ndp_addresses(Link *link);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_ipv6_proxy_ndp_address);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "249μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "329μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "2373μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "453μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "303μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "3707μs",
      "parallelizable_steps": [],
      "critical_path_length": "2925μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 6,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 6,
        "complexity_score": 3.333333333333333,
        "content_hash": "17e21f6b1e391452"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-ipv6-proxy-ndp.h"
      }
    },
    "source_hash": "332e061c6ebb"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/import/curl-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <curl/curl.h>\n\n#include \"forward.h\"\n\ntypedef struct CurlGlue CurlGlue;\n\ntypedef struct CurlGlue {\n        sd_event *event;\n        CURLM *curl;\n        sd_event_source *timer;\n        Hashmap *ios;\n        sd_event_source *defer;\n\n        void (*on_finished)(CurlGlue *g, CURL *curl, CURLcode code);\n        void *userdata;\n} CurlGlue;\n\nint curl_glue_new(CurlGlue **glue, sd_event *event);\nCurlGlue* curl_glue_unref(CurlGlue *glue);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(CurlGlue*, curl_glue_unref);\n\nint curl_glue_make(CURL **ret, const char *url, void *userdata);\nint curl_glue_add(CurlGlue *g, CURL *c);\nvoid curl_glue_remove_and_free(CurlGlue *g, CURL *c);\n\nstruct curl_slist *curl_slist_new(const char *first, ...) _sentinel_;\nint curl_header_strdup(const void *contents, size_t sz, const char *field, char **value);\nint curl_parse_http_time(const char *t, usec_t *ret);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC_FULL(CURL*, curl_easy_cleanup, NULL);\nDEFINE_TRIVIAL_CLEANUP_FUNC_FULL(CURLM*, curl_multi_cleanup, NULL);\nDEFINE_TRIVIAL_CLEANUP_FUNC_FULL(struct curl_slist*, curl_slist_free_all, NULL);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "104μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "44μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "28601μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "306μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "129μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "29184μs",
      "parallelizable_steps": [],
      "critical_path_length": "28834μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 0.7692307692307693
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 0.7692307692307693,
        "content_hash": "1c145b8fecaf1acf"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/import/curl-util.h"
      }
    },
    "source_hash": "d1c15df07ccd"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/killall.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\nint broadcast_signal(int sig, bool wait_for_exit, bool send_sighup, usec_t timeout);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "189μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "810μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "644014μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1340μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "486μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "646839μs",
      "parallelizable_steps": [],
      "critical_path_length": "644689μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 4,
        "complexity_score": 7.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 4,
        "complexity_score": 7.5,
        "content_hash": "5fd43142f60c1d84"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/killall.h"
      }
    },
    "source_hash": "c28a2a532985"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/hid.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2001 Vojtech Pavlik\n *  Copyright (c) 2006-2007 Jiri Kosina\n */\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n *\n * Should you need to contact me, the author, you can do so either by\n * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:\n * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic\n */\n#ifndef __HID_H\n#define __HID_H\n\n\n\n/*\n * USB HID (Human Interface Device) interface class code\n */\n\n#define USB_INTERFACE_CLASS_HID\t\t3\n\n/*\n * USB HID interface subclass and protocol codes\n */\n\n#define USB_INTERFACE_SUBCLASS_BOOT\t1\n#define USB_INTERFACE_PROTOCOL_KEYBOARD\t1\n#define USB_INTERFACE_PROTOCOL_MOUSE\t2\n\n/*\n * HID report types --- Ouch! HID spec says 1 2 3!\n */\n\nenum hid_report_type {\n\tHID_INPUT_REPORT\t\t= 0,\n\tHID_OUTPUT_REPORT\t\t= 1,\n\tHID_FEATURE_REPORT\t\t= 2,\n\n\tHID_REPORT_TYPES,\n};\n\n/*\n * HID class requests\n */\n\nenum hid_class_request {\n\tHID_REQ_GET_REPORT\t\t= 0x01,\n\tHID_REQ_GET_IDLE\t\t= 0x02,\n\tHID_REQ_GET_PROTOCOL\t\t= 0x03,\n\tHID_REQ_SET_REPORT\t\t= 0x09,\n\tHID_REQ_SET_IDLE\t\t= 0x0A,\n\tHID_REQ_SET_PROTOCOL\t\t= 0x0B,\n};\n\n/*\n * HID class descriptor types\n */\n\n#define HID_DT_HID\t\t\t(USB_TYPE_CLASS | 0x01)\n#define HID_DT_REPORT\t\t\t(USB_TYPE_CLASS | 0x02)\n#define HID_DT_PHYSICAL\t\t\t(USB_TYPE_CLASS | 0x03)\n\n#define HID_MAX_DESCRIPTOR_SIZE\t\t4096\n\n\n#endif /* __HID_H */\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "131μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "144μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "174584μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "176674μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "320419μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "17871μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "131722μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "161μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "821706μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "626725μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 1.6923076923076925
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 1.6923076923076925,
        "content_hash": "3972eb94c5948287"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/hid.h"
      }
    },
    "source_hash": "1101a89328e7"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/bpf/sysctl-monitor/sysctl-write-event.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#ifndef TASK_COMM_LEN\n#define TASK_COMM_LEN 16\n#endif\n\n/* It would be nice to size these members to bigger values, but the stack\n * in BPF programs is limited to 512 bytes, and allocating bigger structures\n * leads to this compile time error:\n *   error: Looks like the BPF stack limit is exceeded.\n *   Please move large on stack variables into BPF per-cpu array map.\n *   For non-kernel uses, the stack can be increased using -mllvm -bpf-stack-size. */\nstruct sysctl_write_event {\n        /* Used to track changes in the struct layout */\n        int version;\n\n        /* Error code returned to userspace to handle eventual failures. */\n        int errorcode;\n\n        /* The PID of the process which is writing the sysctl. */\n        pid_t pid;\n\n        /* The cgroup id of the process. */\n        uint64_t cgroup_id;\n\n        /* The name of the binary. */\n        char comm[TASK_COMM_LEN];\n\n        /* The path of the sysctl, relative to /proc/sys/.\n         * The longest path observed is 64 bytes:\n         * net/ipv4/conf/123456789012345/igmpv3_unsolicited_report_interval\n         * so set it to 100 gives us lot of headroom */\n        char path[100];\n\n        /* The value of the sysctl just before the write.\n         * The longest value observed is net.core.netdev_rss_key which\n         * contains 155 bytes, so set it to 160 to have some headroom\n         * even in this corner case. */\n        char current[160];\n\n        /* The new value being written into the sysctl.\n         * same sizing as 'current' */\n        char newvalue[160];\n};\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "90μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "171μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "64473μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "117μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "149μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "65000μs",
      "parallelizable_steps": [],
      "critical_path_length": "64712μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.3888888888888888
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.3888888888888888,
        "content_hash": "cc643f426bf29170"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/bpf/sysctl-monitor/sysctl-write-event.h"
      }
    },
    "source_hash": "351edbe6e291"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/cryptenroll/cryptenroll-tpm2.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\nint load_volume_key_tpm2(struct crypt_device *cd, const char *cd_node, const char *device, void *ret_vk, size_t *ret_vks);\nint enroll_tpm2(struct crypt_device *cd, const struct iovec *volume_key, const char *device, uint32_t seal_key_handle, const char *device_key, Tpm2PCRValue *hash_pcr_values, size_t n_hash_pcr_values, const char *pubkey_path, bool load_pcr_pubkey, uint32_t pubkey_pcr_mask, const char *signature_path, bool use_pin, const char *pcrlock_path, int *ret_slot_to_wipe);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "146μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "660μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "63702μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1312μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "437μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "66257μs",
      "parallelizable_steps": [],
      "critical_path_length": "64285μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "2dffa0b6eaf0aab6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/cryptenroll/cryptenroll-tpm2.h"
      }
    },
    "source_hash": "858b07882a67"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-address-label.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <netinet/in.h>\n\n#include \"networkd-forward.h\"\n\ntypedef struct AddressLabel {\n        Manager *manager;\n        Network *network;\n        ConfigSection *section;\n\n        uint32_t label;\n        struct in6_addr prefix;\n        unsigned char prefixlen;\n        bool prefix_set;\n} AddressLabel;\n\nAddressLabel *address_label_free(AddressLabel *label);\n\nvoid network_drop_invalid_address_labels(Network *network);\nvoid manager_drop_invalid_address_labels(Manager *manager);\n\nint link_request_static_address_labels(Link *link);\nint manager_request_static_address_labels(Manager *manager);\n\ntypedef enum IPv6AddressLabelConfParserType {\n        IPV6_ADDRESS_LABEL,\n        IPV6_ADDRESS_LABEL_PREFIX,\n        _IPV6_ADDRESS_LABEL_CONF_PARSER_MAX,\n        _IPV6_ADDRESS_LABEL_CONF_PARSER_INVALID = -EINVAL,\n\n        IPV6_ADDRESS_LABEL_BY_MANAGER           = 1 << 16,\n        IPV6_ADDRESS_LABEL_SECTION_MASK         = IPV6_ADDRESS_LABEL_BY_MANAGER - 1,\n} IPv6AddressLabelConfParserType;\n\nassert_cc(IPV6_ADDRESS_LABEL_BY_MANAGER >= _IPV6_ADDRESS_LABEL_CONF_PARSER_MAX);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_ipv6_address_label_section);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "63μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "64726μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "169μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "25μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "65036μs",
      "parallelizable_steps": [],
      "critical_path_length": "64814μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 28,
        "complexity_score": 0.7142857142857142
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 28,
        "complexity_score": 0.7142857142857142,
        "content_hash": "208623d41ddfb826"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-address-label.h"
      }
    },
    "source_hash": "619c8b0b0ece"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemctl/systemctl-reset-failed.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-error.h\"\n#include \"bus-locator.h\"\n#include \"log.h\"\n#include \"strv.h\"\n#include \"systemctl-reset-failed.h\"\n#include \"systemctl-trivial-method.h\"\n#include \"systemctl-util.h\"\n\nint verb_reset_failed(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **names = NULL;\n        sd_bus *bus;\n        int r, q;\n\n        if (argc <= 1) /* Shortcut to trivial_method() if no argument is given */\n                return verb_trivial_method(argc, argv, userdata);\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        r = expand_unit_names(bus, strv_skip(argv, 1), NULL, &names, NULL);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to expand names: %m\");\n\n        STRV_FOREACH(name, names) {\n                _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n\n                q = bus_call_method(bus, bus_systemd_mgr, \"ResetFailedUnit\", &error, NULL, \"s\", *name);\n                if (q < 0) {\n                        log_error_errno(q, \"Failed to reset failed state of unit %s: %s\", *name, bus_error_message(&error, q));\n                        if (r == 0)\n                                r = q;\n                }\n        }\n\n        return r;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "103μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "371μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "120625μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "791μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "83μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "121973μs",
      "parallelizable_steps": [],
      "critical_path_length": "120811μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 2.4242424242424243
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 2.4242424242424243,
        "content_hash": "e9eb918fc9d418cb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemctl/systemctl-reset-failed.c"
      }
    },
    "source_hash": "b62e0070ff04"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-setlink.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nint link_request_to_set_addrgen_mode(Link *link);\nint link_request_to_set_bond(Link *link);\nint link_request_to_set_bridge(Link *link);\nint link_request_to_set_bridge_vlan(Link *link);\nint link_request_to_set_can(Link *link);\nint link_request_to_set_flags(Link *link);\nint link_request_to_set_group(Link *link);\nint link_request_to_set_mac(Link *link, bool allow_retry);\nint link_request_to_set_ipoib(Link *link);\nint link_request_to_set_master(Link *link);\nint link_request_to_set_mtu(Link *link, uint32_t mtu);\n\nint link_configure_mtu(Link *link);\n\nint link_request_to_activate(Link *link);\n\nint link_request_to_bring_up_or_down(Link *link, bool up);\n\nint link_up_or_down_now(Link *link, bool up);\nstatic inline int link_up_now(Link *link) {\n        return link_up_or_down_now(link, true);\n}\nstatic inline int link_down_now(Link *link) {\n        return link_up_or_down_now(link, false);\n}\n\nint link_down_slave_links(Link *link);\nint link_remove(Link *link);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "138μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "75μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "101399μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "252μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "50μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "101914μs",
      "parallelizable_steps": [],
      "critical_path_length": "101587μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 1.153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 1.153846153846154,
        "content_hash": "ebbfb15184a3d91e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-setlink.h"
      }
    },
    "source_hash": "80a3fd08ee8b"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/blockdev-list.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-device.h\"\n\n#include \"ansi-color.h\"\n#include \"blockdev-list.h\"\n#include \"blockdev-util.h\"\n#include \"device-util.h\"\n#include \"strv.h\"\n#include \"terminal-util.h\"\n\nint blockdev_list(BlockDevListFlags flags) {\n        _cleanup_(sd_device_enumerator_unrefp) sd_device_enumerator *e = NULL;\n        int r;\n\n        if (sd_device_enumerator_new(&e) < 0)\n                return log_oom();\n\n        r = sd_device_enumerator_add_match_subsystem(e, \"block\", /* match = */ true);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to add subsystem match: %m\");\n\n        if (FLAGS_SET(flags, BLOCKDEV_LIST_REQUIRE_LUKS)) {\n                r = sd_device_enumerator_add_match_property(e, \"ID_FS_TYPE\", \"crypto_LUKS\");\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to add match for LUKS block devices: %m\");\n        }\n\n        FOREACH_DEVICE(e, dev) {\n                const char *node;\n\n                r = sd_device_get_devname(dev, &node);\n                if (r < 0) {\n                        log_warning_errno(r, \"Failed to get device node of discovered block device, ignoring: %m\");\n                        continue;\n                }\n\n                if (FLAGS_SET(flags, BLOCKDEV_LIST_IGNORE_ZRAM)) {\n                        r = device_sysname_startswith(dev, \"zram\");\n                        if (r < 0) {\n                                log_warning_errno(r, \"Failed to check device name of discovered block device '%s', ignoring: %m\", node);\n                                continue;\n                        }\n                        if (r > 0)\n                                continue;\n                }\n\n                if (FLAGS_SET(flags, BLOCKDEV_LIST_REQUIRE_PARTITION_SCANNING)) {\n                        r = blockdev_partscan_enabled(dev);\n                        if (r < 0) {\n                                log_warning_errno(r, \"Unable to determine whether '%s' supports partition scanning, skipping device: %m\", node);\n                                continue;\n                        }\n                        if (r == 0) {\n                                log_debug(\"Device '%s' does not support partition scanning, skipping.\", node);\n                                continue;\n                        }\n                }\n\n                printf(\"%s\\n\", node);\n\n                if (FLAGS_SET(flags, BLOCKDEV_LIST_SHOW_SYMLINKS)) {\n                        _cleanup_strv_free_ char **list = NULL;\n\n                        FOREACH_DEVICE_DEVLINK(dev, l)\n                                if (strv_extend(&list, l) < 0)\n                                        return log_oom();\n\n                        strv_sort(list);\n\n                        STRV_FOREACH(i, list)\n                                printf(\"%s%s%s%s\\n\", on_tty() ? \"    \" : \"\", ansi_grey(), *i, ansi_normal());\n                }\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "287μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "471μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "578473μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "470019μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "364272μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "33375μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "30040μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "311μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1477248μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "972785μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 3.114754098360656
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 3.114754098360656,
        "content_hash": "c3e1bc48a107261d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/blockdev-list.c"
      }
    },
    "source_hash": "fc0f7f9d51d3"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-native.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"journald-forward.h\"\n\nvoid manager_process_native_message(\n                Manager *m,\n                const char *buffer,\n                size_t buffer_size,\n                const struct ucred *ucred,\n                const struct timeval *tv,\n                const char *label,\n                size_t label_len);\n\nint manager_process_native_file(\n                Manager *m,\n                int fd,\n                const struct ucred *ucred,\n                const struct timeval *tv,\n                const char *label,\n                size_t label_len);\n\nint manager_open_native_socket(Manager *m, const char *native_socket);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "43μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "208μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "82926μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "136μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "69μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "83382μs",
      "parallelizable_steps": [],
      "critical_path_length": "83038μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 19,
        "complexity_score": 1.0526315789473684
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 19,
        "complexity_score": 1.0526315789473684,
        "content_hash": "7d0afecff8b593ee"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-native.h"
      }
    },
    "source_hash": "5ff2f555d826"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-web-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"tests.h\"\n#include \"web-util.h\"\n\nTEST(is_valid_documentation_url) {\n        ASSERT_TRUE(documentation_url_is_valid(\"https://www.freedesktop.org/wiki/Software/systemd\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"https://www.kernel.org/doc/Documentation/binfmt_misc.txt\"));  /* dead */\n        ASSERT_TRUE(documentation_url_is_valid(\"https://www.kernel.org/doc/Documentation/admin-guide/binfmt-misc.rst\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"https://docs.kernel.org/admin-guide/binfmt-misc.html\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"file:/foo/foo\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"man:systemd.special(7)\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"info:bar\"));\n\n        ASSERT_FALSE(documentation_url_is_valid(\"foo:\"));\n        ASSERT_FALSE(documentation_url_is_valid(\"info:\"));\n        ASSERT_FALSE(documentation_url_is_valid(\"\"));\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "235μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "184321μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "159μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "437μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "10975μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "20μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "196147μs",
      "parallelizable_steps": [],
      "critical_path_length": "184778μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 16,
        "complexity_score": 0.625
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 16,
        "complexity_score": 0.625,
        "content_hash": "003b06b5cf7c96fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-web-util.c"
      }
    },
    "source_hash": "82b17d17e114"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: man/check-os-release.py\n\nCode:\n#!/usr/bin/python\n# SPDX-License-Identifier: MIT-0\n\nimport ast\nimport re\nimport sys\n\ndef read_os_release():\n    try:\n        filename = '/etc/os-release'\n        f = open(filename)\n    except FileNotFoundError:\n        filename = '/usr/lib/os-release'\n        f = open(filename)\n\n    for line_number, line in enumerate(f, start=1):\n        line = line.rstrip()\n        if not line or line.startswith('#'):\n            continue\n        m = re.match(r'([A-Z][A-Z_0-9]+)=(.*)', line)\n        if m:\n            name, val = m.groups()\n            if val and val[0] in '\"\\'':\n                val = ast.literal_eval(val)\n            yield name, val\n        else:\n            print(f'{filename}:{line_number}: bad line {line!r}',\n                  file=sys.stderr)\n\nos_release = dict(read_os_release())\n\npretty_name = os_release.get('PRETTY_NAME', 'Linux')\nprint(f'Running on {pretty_name!r}')\n\nif 'debian' in [os_release.get('ID', 'linux'),\n                *os_release.get('ID_LIKE', '').split()]:\n    print('Looks like Debian!')\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "96μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "540μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "359493μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "1291μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "503659μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "399953μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "199837μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "162μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1465031μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1062989μs",
      "metadata": {
        "functions_found": [
          "read_os_release"
        ],
        "classes_found": [],
        "imports": [
          "ast",
          "re",
          "sys"
        ],
        "lines_of_code": 31,
        "complexity_score": 2.903225806451613
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [
          "read_os_release"
        ],
        "classes": [],
        "imports": [
          "ast",
          "re",
          "sys"
        ],
        "lines_of_code": 31,
        "complexity_score": 2.903225806451613,
        "content_hash": "34f909320046a786"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "man/check-os-release.py"
      }
    },
    "source_hash": "46cbf1da7a92"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-state-file.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nvoid link_dirty(Link *link);\nvoid link_clean(Link *link);\nint link_save_and_clean_full(Link *link, bool also_save_manager);\nstatic inline int link_save_and_clean(Link *link) {\n        return link_save_and_clean_full(link, false);\n}\n\nint manager_save(Manager *m);\nint manager_clean_all(Manager *manager);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "90μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "236μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "16656μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "345μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "306μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "17633μs",
      "parallelizable_steps": [],
      "critical_path_length": "17052μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183,
        "content_hash": "1d02f3b7e6c20765"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-state-file.h"
      }
    },
    "source_hash": "28491ff91ff4"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/fuzz-lldp-rx.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include \"sd-event.h\"\n#include \"sd-json.h\"\n#include \"sd-lldp-rx.h\"\n\n#include \"fd-util.h\"\n#include \"fuzz.h\"\n#include \"lldp-network.h\"\n#include \"lldp-rx-internal.h\"\n#include \"memstream-util.h\"\n\nstatic int test_fd[2] = EBADF_PAIR;\n\nint lldp_network_bind_raw_socket(int ifindex) {\n        if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0, test_fd) < 0)\n                return -errno;\n\n        return test_fd[0];\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_(sd_event_unrefp) sd_event *e = NULL;\n        _cleanup_(sd_lldp_rx_unrefp) sd_lldp_rx *lldp_rx = NULL;\n        _cleanup_(sd_json_variant_unrefp) sd_json_variant *v = NULL;\n        _cleanup_(memstream_done) MemStream m = {};\n        FILE *f;\n\n        if (outside_size_range(size, 0, 2048))\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(sd_event_new(&e) == 0);\n        assert_se(sd_lldp_rx_new(&lldp_rx) >= 0);\n        assert_se(sd_lldp_rx_set_ifindex(lldp_rx, 42) >= 0);\n        assert_se(sd_lldp_rx_attach_event(lldp_rx, e, 0) >= 0);\n        assert_se(sd_lldp_rx_start(lldp_rx) >= 0);\n\n        assert_se(write(test_fd[1], data, size) == (ssize_t) size);\n        assert_se(sd_event_run(e, 0) >= 0);\n\n        assert_se(lldp_rx_build_neighbors_json(lldp_rx, &v) >= 0);\n        assert_se(f = memstream_init(&m));\n        (void) sd_json_variant_dump(v, SD_JSON_FORMAT_PRETTY|SD_JSON_FORMAT_COLOR, f, NULL);\n\n        assert_se(sd_lldp_rx_stop(lldp_rx) >= 0);\n        assert_se(sd_lldp_rx_detach_event(lldp_rx) >= 0);\n        test_fd[1] = safe_close(test_fd[1]);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "317μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "13μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "152871μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "246605μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "44562μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "113405μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "177μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "557950μs",
      "parallelizable_steps": [],
      "critical_path_length": "360023μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732,
        "content_hash": "b5cdb818324a69c6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/fuzz-lldp-rx.c"
      }
    },
    "source_hash": "9ddbf63f9d36"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-sha1.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"hexdecoct.h\"\n#include \"sha1-fundamental.h\"\n#include \"tests.h\"\n\nstatic void sha1_process_string(const char *key, struct sha1_ctx *ctx) {\n        sha1_process_bytes(key, strlen(key), ctx);\n}\n\nstatic void test_sha1_one(const char *key, const char *expect) {\n        uint8_t result[SHA1_DIGEST_SIZE + 3];\n        _cleanup_free_ char *str = NULL;\n        struct sha1_ctx ctx;\n\n        log_debug(\"\\\"%s\\\" → %s\", key, expect);\n\n        assert_se(str = new(char, strlen(key) + 4));\n\n        /* This tests unaligned buffers. */\n\n        for (size_t i = 0; i < 4; i++) {\n                strcpy(str + i, key);\n\n                for (size_t j = 0; j < 4; j++) {\n                        _cleanup_free_ char *hex_result = NULL;\n\n                        sha1_init_ctx(&ctx);\n                        sha1_process_string(str + i, &ctx);\n                        sha1_finish_ctx(&ctx, result + j);\n\n                        hex_result = hexmem(result + j, SHA1_DIGEST_SIZE);\n                        ASSERT_STREQ(hex_result, expect);\n                }\n        }\n}\n\n/* From https://datatracker.ietf.org/doc/html/rfc3174#section-7.3 */\n#define TEST1   \"abc\"\n#define RESULT1 \"a9993e364706816aba3e25717850c26c9cd0d89d\"\n#define TEST2   \"abcdbcdecdefdefgefghfghighijhi\" \"jkijkljklmklmnlmnomnopnopq\"\n#define RESULT2 \"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n#define TEST3   \"a\"\n#define RESULT3 \"86f7e437faa5a7fce15d1ddcb9eaeaea377667b8\"\n#define TEST4   \"01234567012345670123456701234567\" \"01234567012345670123456701234567\"\n#define RESULT4 \"e0c094e867ef46c350ef54a7f59dd60bed92ae83\"\n\nTEST(sha1) {\n        /* Results compared with output of 'echo -n \"<input>\" | sha1sum -' */\n\n        test_sha1_one(TEST1, RESULT1);\n        test_sha1_one(TEST2, RESULT2);\n        test_sha1_one(TEST3, RESULT3);\n        test_sha1_one(TEST4, RESULT4);\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "231μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "351563μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "604μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "443μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "50903μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "33μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "403777μs",
      "parallelizable_steps": [],
      "critical_path_length": "352039μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.9302325581395349
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.9302325581395349,
        "content_hash": "9060d4b6c2575a19"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-sha1.c"
      }
    },
    "source_hash": "bfd4afcf1c22"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-varlink.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"journald-forward.h\"\n\nint manager_open_varlink(Manager *m, const char *socket, int fd);\n\nvoid sync_req_varlink_reply(SyncReq *req);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "743μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "88μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "524637μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "266739μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "252190μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "20881μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "730μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1066008μs",
      "parallelizable_steps": [],
      "critical_path_length": "778300μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "fc2b32e385be0c22"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-varlink.h"
      }
    },
    "source_hash": "67d87235dbb4"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-trust-anchor.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\n/* This contains a fixed database mapping domain names to DS or DNSKEY records. */\n\ntypedef struct DnsTrustAnchor {\n        Hashmap *positive_by_key;\n        Set *negative_by_name;\n        Set *revoked_by_rr;\n} DnsTrustAnchor;\n\nint dns_trust_anchor_load(DnsTrustAnchor *d);\nvoid dns_trust_anchor_flush(DnsTrustAnchor *d);\n\nint dns_trust_anchor_lookup_positive(DnsTrustAnchor *d, const DnsResourceKey* key, DnsAnswer **answer);\nint dns_trust_anchor_lookup_negative(DnsTrustAnchor *d, const char *name);\n\nint dns_trust_anchor_check_revoked(DnsTrustAnchor *d, DnsResourceRecord *dnskey, DnsAnswer *rrs);\nint dns_trust_anchor_is_revoked(DnsTrustAnchor *d, DnsResourceRecord *rr);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "155μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "37μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "151917μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "17441μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "153μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "58μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "169761μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "152070μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 1.3333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 1.3333333333333333,
        "content_hash": "5c705c51c4e0a4ec"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-trust-anchor.h"
      }
    },
    "source_hash": "ecfeb19266a5"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/cryptenroll/cryptenroll-wipe.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum WipeScope WipeScope;\n\nint wipe_slots(struct crypt_device *cd,\n               const int explicit_slots[],\n               size_t n_explicit_slots,\n               WipeScope by_scope,\n               unsigned by_mask,\n               int except_slot);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "557μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "274μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "106294μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1123μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "212μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "108460μs",
      "parallelizable_steps": [],
      "critical_path_length": "107063μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 3.0,
        "content_hash": "ffef7b8991350c52"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/cryptenroll/cryptenroll-wipe.h"
      }
    },
    "source_hash": "3b68a9ef75c6"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/varlink.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"core-forward.h\"\n\nint manager_setup_varlink_server(Manager *m);\n\nint manager_varlink_init(Manager *m);\nvoid manager_varlink_done(Manager *m);\n\n/* The manager is expected to send an update to systemd-oomd if one of the following occurs:\n * - The value of ManagedOOM*= properties change\n * - A unit with ManagedOOM*= properties changes unit active state */\nint manager_varlink_send_managed_oom_update(Unit *u);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "76μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "396μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "711544μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "261726μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "269254μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "254266μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1497297μs",
      "parallelizable_steps": [],
      "critical_path_length": "980909μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 4.0,
        "content_hash": "970cd614d837f375"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/varlink.h"
      }
    },
    "source_hash": "aa21629190df"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/cryptenroll/cryptenroll.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum EnrollType {\n        ENROLL_PASSWORD,\n        ENROLL_RECOVERY,\n        ENROLL_PKCS11,\n        ENROLL_FIDO2,\n        ENROLL_TPM2,\n        _ENROLL_TYPE_MAX,\n        _ENROLL_TYPE_INVALID = -EINVAL,\n} EnrollType;\n\ntypedef enum UnlockType {\n        UNLOCK_PASSWORD,\n        UNLOCK_KEYFILE,\n        UNLOCK_FIDO2,\n        UNLOCK_TPM2,\n        _UNLOCK_TYPE_MAX,\n        _UNLOCK_TYPE_INVALID = -EINVAL,\n} UnlockType;\n\ntypedef enum WipeScope {\n        WIPE_EXPLICIT,          /* only wipe the listed slots */\n        WIPE_ALL,               /* wipe all slots */\n        WIPE_EMPTY_PASSPHRASE,  /* wipe slots with empty passphrases plus listed slots */\n        _WIPE_SCOPE_MAX,\n        _WIPE_SCOPE_INVALID = -EINVAL,\n} WipeScope;\n\nconst char* enroll_type_to_string(EnrollType t);\nEnrollType enroll_type_from_string(const char *s);\n\nconst char* luks2_token_type_to_string(EnrollType t);\nEnrollType luks2_token_type_from_string(const char *s);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "139μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "97μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "1940μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "231μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "92μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2499μs",
      "parallelizable_steps": [],
      "critical_path_length": "2171μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 0.967741935483871
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 0.967741935483871,
        "content_hash": "9948b66f2e3cbe72"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/cryptenroll/cryptenroll.h"
      }
    },
    "source_hash": "f7f63cc817d8"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/if_vlan.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n * VLAN\t\tAn implementation of 802.1Q VLAN tagging.\n *\n * Authors:\tBen Greear <greearb@candelatech.com>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n */\n\n#ifndef _LINUX_IF_VLAN_H_\n#define _LINUX_IF_VLAN_H_\n\n\n/* VLAN IOCTLs are found in sockios.h */\n\n/* Passed in vlan_ioctl_args structure to determine behaviour. */\nenum vlan_ioctl_cmds {\n\tADD_VLAN_CMD,\n\tDEL_VLAN_CMD,\n\tSET_VLAN_INGRESS_PRIORITY_CMD,\n\tSET_VLAN_EGRESS_PRIORITY_CMD,\n\tGET_VLAN_INGRESS_PRIORITY_CMD,\n\tGET_VLAN_EGRESS_PRIORITY_CMD,\n\tSET_VLAN_NAME_TYPE_CMD,\n\tSET_VLAN_FLAG_CMD,\n\tGET_VLAN_REALDEV_NAME_CMD, /* If this works, you know it's a VLAN device, btw */\n\tGET_VLAN_VID_CMD /* Get the VID of this VLAN (specified by name) */\n};\n\nenum vlan_flags {\n\tVLAN_FLAG_REORDER_HDR\t\t= 0x1,\n\tVLAN_FLAG_GVRP\t\t\t= 0x2,\n\tVLAN_FLAG_LOOSE_BINDING\t\t= 0x4,\n\tVLAN_FLAG_MVRP\t\t\t= 0x8,\n\tVLAN_FLAG_BRIDGE_BINDING\t= 0x10,\n};\n\nenum vlan_name_types {\n\tVLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */\n\tVLAN_NAME_TYPE_RAW_PLUS_VID, /* name will look like:  eth1.0005 */\n\tVLAN_NAME_TYPE_PLUS_VID_NO_PAD, /* Name will look like:  vlan5 */\n\tVLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD, /* Name will look like:  eth0.5 */\n\tVLAN_NAME_TYPE_HIGHEST\n};\n\nstruct vlan_ioctl_args {\n\tint cmd; /* Should be one of the vlan_ioctl_cmds enum above. */\n\tchar device1[24];\n\n        union {\n\t\tchar device2[24];\n\t\tint VID;\n\t\tunsigned int skb_priority;\n\t\tunsigned int name_type;\n\t\tunsigned int bind_type;\n\t\tunsigned int flag; /* Matches vlan_dev_priv flags */\n        } u;\n\n\tshort vlan_qos;   \n};\n\n#endif /* _LINUX_IF_VLAN_H_ */\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "200μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "305μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "206338μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "312377μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "279254μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "293570μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "74425μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "148μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1166617μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "606400μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.7857142857142858
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.7857142857142858,
        "content_hash": "37e4ce89343c0d97"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/if_vlan.h"
      }
    },
    "source_hash": "692889ea3ca4"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: man/inotify-watch-tmp.c\n\nCode:\n/* SPDX-License-Identifier: MIT-0 */\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/inotify.h>\n\n#include <systemd/sd-event.h>\n\n#define _cleanup_(f) __attribute__((cleanup(f)))\n\nstatic int inotify_handler(sd_event_source *source,\n                           const struct inotify_event *event,\n                           void *userdata) {\n\n  const char *desc = NULL;\n\n  sd_event_source_get_description(source, &desc);\n\n  if (event->mask & IN_Q_OVERFLOW)\n    printf(\"inotify-handler <%s>: overflow\\n\", desc);\n  else if (event->mask & IN_CREATE)\n    printf(\"inotify-handler <%s>: create on %s\\n\", desc, event->name);\n  else if (event->mask & IN_DELETE)\n    printf(\"inotify-handler <%s>: delete on %s\\n\", desc, event->name);\n  else if (event->mask & IN_MOVED_TO)\n    printf(\"inotify-handler <%s>: moved-to on %s\\n\", desc, event->name);\n\n  /* Terminate the program if an \"exit\" file appears */\n  if ((event->mask & (IN_CREATE|IN_MOVED_TO)) &&\n      strcmp(event->name, \"exit\") == 0)\n    sd_event_exit(sd_event_source_get_event(source), 0);\n\n  return 1;\n}\n\nint main(int argc, char **argv) {\n  _cleanup_(sd_event_unrefp) sd_event *event = NULL;\n  _cleanup_(sd_event_source_unrefp) sd_event_source *source1 = NULL, *source2 = NULL;\n\n  const char *path1 = argc > 1 ? argv[1] : \"/tmp\";\n  const char *path2 = argc > 2 ? argv[2] : NULL;\n\n  /* Note: failure handling is omitted for brevity */\n\n  sd_event_default(&event);\n\n  sd_event_add_inotify(event, &source1, path1,\n                       IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_TO,\n                       inotify_handler, NULL);\n  if (path2)\n    sd_event_add_inotify(event, &source2, path2,\n                         IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_TO,\n                         inotify_handler, NULL);\n\n  sd_event_loop(event);\n\n  return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "860μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "1000μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "966316μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "730504μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "247980μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "7217μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "171232μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "133μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "2125242μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1385528μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 42,
        "complexity_score": 5.238095238095238
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 42,
        "complexity_score": 5.238095238095238,
        "content_hash": "782cd479c938824a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "man/inotify-watch-tmp.c"
      }
    },
    "source_hash": "541e457f50eb"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/tc/ets.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/pkt_sched.h>\n\n#include \"forward.h\"\n#include \"qdisc.h\"\n\ntypedef struct EnhancedTransmissionSelection {\n        QDisc meta;\n\n        uint8_t n_bands;\n        uint8_t n_strict;\n        unsigned n_quanta;\n        uint32_t quanta[TCQ_ETS_MAX_BANDS];\n        unsigned n_prio;\n        uint8_t prio[TC_PRIO_MAX + 1];\n} EnhancedTransmissionSelection;\n\nDEFINE_QDISC_CAST(ETS, EnhancedTransmissionSelection);\nextern const QDiscVTable ets_vtable;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_ets_u8);\nCONFIG_PARSER_PROTOTYPE(config_parse_ets_quanta);\nCONFIG_PARSER_PROTOTYPE(config_parse_ets_prio);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "96μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "55μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "16963μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "411μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "19μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "17544μs",
      "parallelizable_steps": [],
      "critical_path_length": "17078μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 19,
        "complexity_score": 1.0526315789473684
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 19,
        "complexity_score": 1.0526315789473684,
        "content_hash": "7686d2cb21dd91e0"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/tc/ets.h"
      }
    },
    "source_hash": "ba63e64b9340"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/system-update-generator/system-update-generator.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"fs-util.h\"\n#include \"generator.h\"\n#include \"initrd-util.h\"\n#include \"log.h\"\n#include \"path-util.h\"\n#include \"proc-cmdline.h\"\n#include \"special.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"unit-file.h\"\n\n/*\n * Implements the logic described in systemd.offline-updates(7).\n */\n\nstatic const char *arg_dest = NULL;\n\nstatic int generate_symlink(void) {\n        int r;\n\n        FOREACH_STRING(p, \"/system-update\", \"/etc/system-update\") {\n                r = access_nofollow(p, F_OK);\n                if (r < 0) {\n                        if (r != -ENOENT)\n                                log_warning_errno(r, \"Failed to check if %s symlink exists, ignoring: %m\", p);\n                        continue;\n                }\n\n                _cleanup_free_ char *j = NULL;\n\n                j = path_join(arg_dest, SPECIAL_DEFAULT_TARGET);\n                if (!j)\n                        return log_oom();\n\n                if (symlink(SYSTEM_DATA_UNIT_DIR \"/system-update.target\", j) < 0)\n                        return log_error_errno(errno, \"Failed to create symlink %s: %m\", j);\n\n                return 1;\n        }\n\n        return 0;\n}\n\nstatic int parse_proc_cmdline_item(const char *key, const char *value, void *data) {\n        assert(key);\n\n        /* Check if a run level is specified on the kernel command line. The\n         * command line has higher priority than any on-disk configuration, so\n         * it'll make any symlink we create moot.\n         */\n\n        if (streq(key, \"systemd.unit\") && !proc_cmdline_value_missing(key, value))\n                log_warning(\"Offline system update overridden by kernel command line systemd.unit= setting\");\n        else if (!value && runlevel_to_target(key))\n                log_warning(\"Offline system update overridden by runlevel \\\"%s\\\" on the kernel command line\", key);\n\n        return 0;\n}\n\nstatic int run(const char *dest, const char *dest_early, const char *dest_late) {\n        int r;\n\n        assert_se(arg_dest = dest_early);\n\n        if (in_initrd()) {\n                log_debug(\"Skipping generator, running in the initrd.\");\n                return EXIT_SUCCESS;\n        }\n\n        r = generate_symlink();\n        if (r <= 0)\n                return r;\n\n        /* We parse the command line only to emit warnings. */\n        r = proc_cmdline_parse(parse_proc_cmdline_item, NULL, 0);\n        if (r < 0)\n                log_warning_errno(r, \"Failed to parse kernel command line, ignoring: %m\");\n\n        return 0;\n}\n\nDEFINE_MAIN_GENERATOR_FUNCTION(run);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "367μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "384μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "60842μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "809μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "408μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "62810μs",
      "parallelizable_steps": [],
      "critical_path_length": "61617μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 2.153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 2.153846153846154,
        "content_hash": "9a98903c2b1b1298"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/system-update-generator/system-update-generator.c"
      }
    },
    "source_hash": "cd497582749c"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ipv4ll.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdipv4llfoo\n#define foosdipv4llfoo\n\n/***\n  Copyright © 2014 Axis Communications AB. All rights reserved.\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in_addr;\n\ntypedef struct sd_event sd_event;\n\nenum {\n        SD_IPV4LL_EVENT_STOP            = 0,\n        SD_IPV4LL_EVENT_BIND            = 1,\n        SD_IPV4LL_EVENT_CONFLICT        = 2\n};\n\ntypedef struct sd_ipv4ll sd_ipv4ll;\ntypedef void (*sd_ipv4ll_callback_t)(sd_ipv4ll *ll, int event, void *userdata);\ntypedef int (*sd_ipv4ll_check_mac_callback_t)(sd_ipv4ll *ll, const struct ether_addr *mac, void *userdata);\n\nint sd_ipv4ll_detach_event(sd_ipv4ll *ll);\nint sd_ipv4ll_attach_event(sd_ipv4ll *ll, sd_event *event, int64_t priority);\nint sd_ipv4ll_get_address(sd_ipv4ll *ll, struct in_addr *address);\nint sd_ipv4ll_set_callback(sd_ipv4ll *ll, sd_ipv4ll_callback_t cb, void *userdata);\nint sd_ipv4ll_set_check_mac_callback(sd_ipv4ll *ll, sd_ipv4ll_check_mac_callback_t cb, void *userdata);\nint sd_ipv4ll_set_mac(sd_ipv4ll *ll, const struct ether_addr *addr);\nint sd_ipv4ll_set_timeout(sd_ipv4ll *ll, uint64_t usec);\nint sd_ipv4ll_set_ifindex(sd_ipv4ll *ll, int interface_index);\nint sd_ipv4ll_get_ifindex(sd_ipv4ll *ll);\nint sd_ipv4ll_set_ifname(sd_ipv4ll *ll, const char *interface_name);\nint sd_ipv4ll_get_ifname(sd_ipv4ll *ll, const char **ret);\nint sd_ipv4ll_set_address(sd_ipv4ll *ll, const struct in_addr *address);\nint sd_ipv4ll_set_address_seed(sd_ipv4ll *ll, uint64_t seed);\nint sd_ipv4ll_is_running(sd_ipv4ll *ll);\nint sd_ipv4ll_restart(sd_ipv4ll *ll);\nint sd_ipv4ll_start(sd_ipv4ll *ll);\nint sd_ipv4ll_stop(sd_ipv4ll *ll);\nsd_ipv4ll *sd_ipv4ll_ref(sd_ipv4ll *ll);\nsd_ipv4ll *sd_ipv4ll_unref(sd_ipv4ll *ll);\nint sd_ipv4ll_new(sd_ipv4ll **ret);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ipv4ll, sd_ipv4ll_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "529μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "682924μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1938μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1219μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "55158μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "972μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "742740μs",
      "parallelizable_steps": [],
      "critical_path_length": "685115μs",
      "metadata": {
        "functions_found": [
          "void",
          "int"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "void",
          "int"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692,
        "content_hash": "ff8c8a8957924859"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ipv4ll.h"
      }
    },
    "source_hash": "52d902d0fa01"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/make-autosuspend-rules.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n# Generate autosuspend rules for devices that have been tested to work properly\n# with autosuspend by the Chromium OS team. Based on\n# https://chromium.googlesource.com/chromiumos/platform2/+/master/power_manager/udev/gen_autosuspend_rules.py\n\nimport chromiumos.gen_autosuspend_rules\n\nprint('# pci:v<00VENDOR>d<00DEVICE> (8 uppercase hexadecimal digits twice)')\nfor entry in chromiumos.gen_autosuspend_rules.PCI_IDS:\n    vendor, device = entry.split(':')\n    vendor = int(vendor, 16)\n    device = int(device, 16)\n    print(f'pci:v{vendor:08X}d{device:08X}*')\n\nprint('# usb:v<VEND>p<PROD> (4 uppercase hexadecimal digits twice)')\nfor entry in chromiumos.gen_autosuspend_rules.USB_IDS:\n    vendor, product = entry.split(':')\n    vendor = int(vendor, 16)\n    product = int(product, 16)\n    print(f'usb:v{vendor:04X}p{product:04X}*')\n\nprint(' ID_AUTOSUSPEND=1')\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "612μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "479280μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "554μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "372μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "988720μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1476μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1471014μs",
      "parallelizable_steps": [],
      "critical_path_length": "989886μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [
          "chromiumos.gen_autosuspend_rules"
        ],
        "lines_of_code": 19,
        "complexity_score": 5.263157894736842
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [
          "chromiumos.gen_autosuspend_rules"
        ],
        "lines_of_code": 19,
        "complexity_score": 5.263157894736842,
        "content_hash": "c7b4d6340806d237"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/make-autosuspend-rules.py"
      }
    },
    "source_hash": "113e4aa94d47"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/login/logind-seat-dbus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"logind-forward.h\"\n\nextern const BusObjectImplementation seat_object;\n\nchar* seat_bus_path(Seat *s);\n\nint seat_send_signal(Seat *s, bool new_seat);\nint seat_send_changed_strv(Seat *s, char **properties);\n#define seat_send_changed(s, ...) seat_send_changed_strv(s, STRV_MAKE(__VA_ARGS__))\n\nint bus_seat_method_terminate(sd_bus_message *message, void *userdata, sd_bus_error *error);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "424μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "30169μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "609μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "155μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "31676μs",
      "parallelizable_steps": [],
      "critical_path_length": "30748μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 9,
        "complexity_score": 2.2222222222222223
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 9,
        "complexity_score": 2.2222222222222223,
        "content_hash": "8121e2ce070f4523"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/login/logind-seat-dbus.h"
      }
    },
    "source_hash": "c33284d982ac"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/varlink-io.systemd.ManagedOOM.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"varlink-io.systemd.ManagedOOM.h\"\n\n/* Pull in vl_type_ControlGroup, since both interfaces need it */\n#include \"varlink-io.systemd.oom.h\"\n\n/* This is PID1's Varlink service, where PID 1 is the server and oomd is the client.\n *\n * Compare with io.systemd.oom where the client/server roles of oomd and the service manager are swapped! */\n\nstatic SD_VARLINK_DEFINE_METHOD_FULL(\n                SubscribeManagedOOMCGroups,\n                SD_VARLINK_SUPPORTS_MORE,\n                SD_VARLINK_DEFINE_OUTPUT_BY_TYPE(cgroups, ControlGroup, SD_VARLINK_ARRAY));\n\nstatic SD_VARLINK_DEFINE_ERROR(SubscriptionTaken);\n\nSD_VARLINK_DEFINE_INTERFACE(\n                io_systemd_ManagedOOM,\n                \"io.systemd.ManagedOOM\",\n                &vl_method_SubscribeManagedOOMCGroups,\n                &vl_type_ControlGroup,\n                &vl_error_SubscriptionTaken);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "33μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "148μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "53293μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "32μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "30μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "53536μs",
      "parallelizable_steps": [],
      "critical_path_length": "53356μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 1.1111111111111112
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 1.1111111111111112,
        "content_hash": "f5165f449a259b47"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/varlink-io.systemd.ManagedOOM.c"
      }
    },
    "source_hash": "0f3658cbe60d"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/selinux-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/socket.h>\n\n#include \"forward.h\"\n\n#if HAVE_SELINUX\n#include <selinux/selinux.h> /* IWYU pragma: export */\n\nDEFINE_TRIVIAL_CLEANUP_FUNC_FULL(char*, freecon, NULL);\n#else\nstatic inline void freeconp(char **p) {\n        assert(*p == NULL);\n}\n#endif\n\n#define _cleanup_freecon_ _cleanup_(freeconp)\n\n/* This accepts 0 error, like _zerook(). */\n#define log_selinux_enforcing_errno(error, ...)                         \\\n        ({                                                              \\\n                int _e = (error);                                       \\\n                bool _enforcing = mac_selinux_enforcing();              \\\n                int _level =                                            \\\n                        ERRNO_VALUE(_e) == 0 ? LOG_DEBUG :              \\\n                                  _enforcing ? LOG_ERR : LOG_WARNING;   \\\n                                                                        \\\n                int _r = (log_get_max_level() >= LOG_PRI(_level))       \\\n                        ? log_internal(_level, _e, PROJECT_FILE, __LINE__, __func__, __VA_ARGS__) \\\n                        : -ERRNO_VALUE(_e);                             \\\n                _enforcing ? _r : 0;                                    \\\n        })\n\nbool mac_selinux_use(void);\nvoid mac_selinux_retest(void);\nbool mac_selinux_enforcing(void);\n\nint mac_selinux_init(void);\nint mac_selinux_init_lazy(void);\nvoid mac_selinux_maybe_reload(void);\nvoid mac_selinux_finish(void);\n\nvoid mac_selinux_disable_logging(void);\n\nint mac_selinux_fix_full(int atfd, const char *inode_path, const char *label_path, LabelFixFlags flags);\n\nint mac_selinux_apply(const char *path, const char *label);\nint mac_selinux_apply_fd(int fd, const char *path, const char *label);\n\nint mac_selinux_get_create_label_from_exe(const char *exe, char **ret_label);\nint mac_selinux_get_our_label(char **ret_label);\nint mac_selinux_get_peer_label(int socket_fd, char **ret_label);\nint mac_selinux_get_child_mls_label(int socket_fd, const char *exe, const char *exec_label, char **ret_label);\n\nint mac_selinux_create_file_prepare_at(int dirfd, const char *path, mode_t mode);\nstatic inline int mac_selinux_create_file_prepare(const char *path, mode_t mode) {\n        return mac_selinux_create_file_prepare_at(AT_FDCWD, path, mode);\n}\nint mac_selinux_create_file_prepare_label(const char *path, const char *label);\nvoid mac_selinux_create_file_clear(void);\n\nint mac_selinux_create_socket_prepare(const char *label);\nvoid mac_selinux_create_socket_clear(void);\n\nint mac_selinux_bind(int fd, const struct sockaddr *addr, socklen_t addrlen);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "45μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "79μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "286978μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "195384μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "42997μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "64734μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "127μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "590344μs",
      "parallelizable_steps": [],
      "critical_path_length": "330147μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 1.9607843137254901
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 1.9607843137254901,
        "content_hash": "7c0a7649cd9bfae5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/selinux-util.h"
      }
    },
    "source_hash": "17c39042d01b"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/wait-online/dns-configuration.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/uio.h>\n\n#include \"forward.h\"\n\ntypedef struct DNSServer {\n        struct iovec addr;\n        int family;\n        uint16_t port;\n        int ifindex;\n        char *server_name;\n        bool accessible;\n} DNSServer;\n\nDNSServer* dns_server_free(DNSServer *s);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DNSServer*, dns_server_free);\n\ntypedef struct SearchDomain {\n        char *name;\n        bool route_only;\n        int ifindex;\n} SearchDomain;\n\nSearchDomain* search_domain_free(SearchDomain *d);\nDEFINE_TRIVIAL_CLEANUP_FUNC(SearchDomain*, search_domain_free);\n\ntypedef struct DNSConfiguration {\n        char *ifname;\n        int ifindex;\n        bool default_route;\n        DNSServer *current_dns_server;\n        Set *dns_servers;\n        Set *search_domains;\n} DNSConfiguration;\n\nDNSConfiguration* dns_configuration_free(DNSConfiguration *c);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DNSConfiguration*, dns_configuration_free);\n\nint dns_configuration_from_json(sd_json_variant *variant, DNSConfiguration **ret);\nbool dns_is_accessible(DNSConfiguration *c);\nbool dns_configuration_contains_search_domain(DNSConfiguration *c, const char *domain);\n\nextern const struct hash_ops dns_configuration_hash_ops;\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "65μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "50μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "197632μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "25519μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "79μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "77μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "223422μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "197711μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 1.7142857142857144
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 1.7142857142857144,
        "content_hash": "39d4be5feb31e15c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/wait-online/dns-configuration.h"
      }
    },
    "source_hash": "c7222a7e9f46"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/web-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"utf8.h\"\n#include \"web-util.h\"\n\nbool http_etag_is_valid(const char *etag) {\n        if (isempty(etag))\n                return false;\n\n        if (!endswith(etag, \"\\\"\"))\n                return false;\n\n        if (!STARTSWITH_SET(etag, \"\\\"\", \"W/\\\"\"))\n                return false;\n\n        return true;\n}\n\nbool http_url_is_valid(const char *url) {\n        const char *p;\n\n        if (isempty(url))\n                return false;\n\n        p = STARTSWITH_SET(url, \"http://\", \"https://\");\n        if (!p)\n                return false;\n\n        if (isempty(p))\n                return false;\n\n        return ascii_is_valid(p);\n}\n\nbool file_url_is_valid(const char *url) {\n        const char *p;\n\n        if (isempty(url))\n                return false;\n\n        p = startswith(url, \"file:/\");\n        if (isempty(p))\n                return false;\n\n        return ascii_is_valid(p);\n}\n\nbool documentation_url_is_valid(const char *url) {\n        const char *p;\n\n        if (isempty(url))\n                return false;\n\n        if (http_url_is_valid(url) || file_url_is_valid(url))\n                return true;\n\n        p = STARTSWITH_SET(url, \"info:\", \"man:\");\n        if (isempty(p))\n                return false;\n\n        return ascii_is_valid(p);\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "518μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "370080μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2237μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2864μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "464759μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "723μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "841181μs",
      "parallelizable_steps": [],
      "critical_path_length": "467514μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.7777777777777777
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.7777777777777777,
        "content_hash": "a6dad0ec18112747"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/web-util.c"
      }
    },
    "source_hash": "e4a4c9a67d74"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/hidraw.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n/*\n *  Copyright (c) 2007 Jiri Kosina\n */\n/*\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * You should have received a copy of the GNU General Public License along with\n * this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.\n */\n#ifndef _HIDRAW_H\n#define _HIDRAW_H\n\n\n\n#include <linux/hid.h>\n#include <linux/types.h>\n\nstruct hidraw_report_descriptor {\n\t__u32 size;\n\t__u8 value[HID_MAX_DESCRIPTOR_SIZE];\n};\n\nstruct hidraw_devinfo {\n\t__u32 bustype;\n\t__s16 vendor;\n\t__s16 product;\n};\n\n/* ioctl interface */\n#define HIDIOCGRDESCSIZE\t_IOR('H', 0x01, int)\n#define HIDIOCGRDESC\t\t_IOR('H', 0x02, struct hidraw_report_descriptor)\n#define HIDIOCGRAWINFO\t\t_IOR('H', 0x03, struct hidraw_devinfo)\n#define HIDIOCGRAWNAME(len)     _IOC(_IOC_READ, 'H', 0x04, len)\n#define HIDIOCGRAWPHYS(len)     _IOC(_IOC_READ, 'H', 0x05, len)\n/* The first byte of SFEATURE and GFEATURE is the report number */\n#define HIDIOCSFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x06, len)\n#define HIDIOCGFEATURE(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x07, len)\n#define HIDIOCGRAWUNIQ(len)     _IOC(_IOC_READ, 'H', 0x08, len)\n/* The first byte of SINPUT and GINPUT is the report number */\n#define HIDIOCSINPUT(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x09, len)\n#define HIDIOCGINPUT(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x0A, len)\n/* The first byte of SOUTPUT and GOUTPUT is the report number */\n#define HIDIOCSOUTPUT(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x0B, len)\n#define HIDIOCGOUTPUT(len)    _IOC(_IOC_WRITE|_IOC_READ, 'H', 0x0C, len)\n#define HIDIOCREVOKE\t      _IOW('H', 0x0D, int) /* Revoke device access */\n\n#define HIDRAW_FIRST_MINOR 0\n#define HIDRAW_MAX_DEVICES 64\n/* number of reports to buffer */\n#define HIDRAW_BUFFER_SIZE 64\n\n\n/* kernel-only API declarations */\n\n#endif /* _HIDRAW_H */\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "207μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "253μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "143695μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "188μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "200μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "144543μs",
      "parallelizable_steps": [],
      "critical_path_length": "144102μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 1.6326530612244896
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 1.6326530612244896,
        "content_hash": "ea91836c74ffc80f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/hidraw.h"
      }
    },
    "source_hash": "bcb431213b9d"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-procfs-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"errno-util.h\"\n#include \"format-util.h\"\n#include \"log.h\"\n#include \"process-util.h\"\n#include \"procfs-util.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nint main(int argc, char *argv[]) {\n        nsec_t nsec;\n        uint64_t v, pid_max, threads_max, limit;\n        int r;\n\n        test_setup_logging(LOG_DEBUG);\n\n        assert_se(procfs_cpu_get_usage(&nsec) >= 0);\n        log_info(\"Current system CPU time: %s\", FORMAT_TIMESPAN(nsec/NSEC_PER_USEC, 1));\n\n        assert_se(procfs_memory_get_used(&v) >= 0);\n        log_info(\"Current memory usage: %s\", FORMAT_BYTES(v));\n\n        assert_se(procfs_tasks_get_current(&v) >= 0);\n        log_info(\"Current number of tasks: %\" PRIu64, v);\n\n        pid_max = TASKS_MAX;\n        r = procfs_get_pid_max(&pid_max);\n        if (r == -ENOENT || ERRNO_IS_NEG_PRIVILEGE(r))\n                return log_tests_skipped_errno(r, \"can't get pid max\");\n        assert(r >= 0);\n        log_info(\"kernel.pid_max: %\"PRIu64, pid_max);\n\n        threads_max = TASKS_MAX;\n        r = procfs_get_threads_max(&threads_max);\n        if (r == -ENOENT || ERRNO_IS_NEG_PRIVILEGE(r))\n                return log_tests_skipped_errno(r, \"can't get threads max\");\n        assert(r >= 0);\n        log_info(\"kernel.threads-max: %\"PRIu64, threads_max);\n\n        limit = MIN(pid_max - (pid_max > 0), threads_max);\n\n        assert_se(r >= 0);\n        log_info(\"Limit of tasks: %\" PRIu64, limit);\n        assert_se(limit > 0);\n\n        /* This call should never fail, as we're trying to set it to the same limit */\n        assert(procfs_tasks_set_limit(limit) >= 0);\n\n        if (limit > 100) {\n                log_info(\"Reducing limit by one to %\"PRIu64\"…\", limit-1);\n\n                r = procfs_tasks_set_limit(limit-1);\n                if (r == -ENOENT || ERRNO_IS_NEG_FS_WRITE_REFUSED(r))\n                        return log_tests_skipped_errno(r, \"can't set tasks limit\");\n                assert_se(r >= 0);\n\n                assert_se(procfs_get_pid_max(&v) >= 0);\n                /* We never decrease the pid_max, so it shouldn't have changed */\n                assert_se(v == pid_max);\n\n                assert_se(procfs_get_threads_max(&v) >= 0);\n                assert_se(v == limit-1);\n\n                assert_se(procfs_tasks_set_limit(limit) >= 0);\n\n                assert_se(procfs_get_pid_max(&v) >= 0);\n                assert_se(v == pid_max);\n\n                assert_se(procfs_get_threads_max(&v) >= 0);\n                assert_se(v == limit);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "248μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "180μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "265185μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "308484μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "141953μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "205028μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "131427μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "101μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1052606μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "538565μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.6071428571428572
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.6071428571428572,
        "content_hash": "910a3a9165ee5bbe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-procfs-util.c"
      }
    },
    "source_hash": "ff316652e2bd"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"dns-def.h\"\n#include \"dns-domain.h\"\n#include \"hostname-setup.h\"\n#include \"hostname-util.h\"\n#include \"idn-util.h\"\n#include \"log.h\"\n#include \"resolved-util.h\"\n#include \"utf8.h\"\n\nint resolve_system_hostname(char **full_hostname, char **first_label) {\n        _cleanup_free_ char *h = NULL, *n = NULL;\n#if HAVE_LIBIDN2\n        _cleanup_free_ char *utf8 = NULL;\n#elif HAVE_LIBIDN\n        int k;\n#endif\n        char label[DNS_LABEL_MAX+1];\n        const char *p, *decoded;\n        int r;\n\n        /* Return the full hostname in *full_hostname, if nonnull.\n         *\n         * Extract and normalize the first label of the locally configured hostname, check it's not\n         * \"localhost\", and return it in *first_label, if nonnull. */\n\n        r = gethostname_strict(&h);\n        if (r < 0)\n                return log_debug_errno(r, \"Can't determine system hostname: %m\");\n\n        p = h;\n        r = dns_label_unescape(&p, label, sizeof label, 0);\n        if (r < 0)\n                return log_debug_errno(r, \"Failed to unescape hostname: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Couldn't find a single label in hostname.\");\n\n#if HAVE_LIBIDN || HAVE_LIBIDN2\n        r = dlopen_idn();\n        if (r < 0) {\n                log_debug_errno(r, \"Failed to initialize IDN support, ignoring: %m\");\n                decoded = label; /* no decoding */\n        } else\n#endif\n        {\n#if HAVE_LIBIDN2\n                r = sym_idn2_to_unicode_8z8z(label, &utf8, 0);\n                if (r != IDN2_OK)\n                        return log_debug_errno(SYNTHETIC_ERRNO(EUCLEAN),\n                                               \"Failed to undo IDNA: %s\", sym_idn2_strerror(r));\n                assert(utf8_is_valid(utf8));\n\n                r = strlen(utf8);\n                decoded = utf8;\n#elif HAVE_LIBIDN\n                k = dns_label_undo_idna(label, r, label, sizeof label);\n                if (k < 0)\n                        return log_debug_errno(k, \"Failed to undo IDNA: %m\");\n                if (k > 0)\n                        r = k;\n\n                if (!utf8_is_valid(label))\n                        return log_debug_errno(SYNTHETIC_ERRNO(EINVAL),\n                                               \"System hostname is not UTF-8 clean.\");\n                decoded = label;\n#else\n                decoded = label; /* no decoding */\n#endif\n        }\n\n        r = dns_label_escape_new(decoded, r, &n);\n        if (r < 0)\n                return log_debug_errno(r, \"Failed to escape hostname: %m\");\n\n        if (is_localhost(n))\n                return log_debug_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"System hostname is 'localhost', ignoring.\");\n\n        if (full_hostname)\n                *full_hostname = TAKE_PTR(h);\n        if (first_label)\n                *first_label = TAKE_PTR(n);\n        return 0;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "562μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "28μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "347177μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "278369μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "363μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "51μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "626550μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "347540μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 76,
        "complexity_score": 3.026315789473684
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 76,
        "complexity_score": 3.026315789473684,
        "content_hash": "d3711059f886d58f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-util.c"
      }
    },
    "source_hash": "facdec1b6cb6"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/timesync/timesyncd-server.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"socket-util.h\"\n#include \"timesyncd-forward.h\"\n\ntypedef enum ServerType {\n        SERVER_SYSTEM,\n        SERVER_FALLBACK,\n        SERVER_LINK,\n        SERVER_RUNTIME,\n        _SERVER_TYPE_MAX,\n        _SERVER_TYPE_INVALID = -EINVAL,\n} ServerType;\n\nstruct ServerAddress {\n        ServerName *name;\n\n        union sockaddr_union sockaddr;\n        socklen_t socklen;\n\n        LIST_FIELDS(ServerAddress, addresses);\n};\n\nstruct ServerName {\n        Manager *manager;\n\n        bool marked;\n\n        ServerType type;\n        char *string;\n\n        LIST_HEAD(ServerAddress, addresses);\n        LIST_FIELDS(ServerName, names);\n};\n\nint server_address_new(ServerName *n, ServerAddress **ret, const union sockaddr_union *sockaddr, socklen_t socklen);\nServerAddress* server_address_free(ServerAddress *a);\nstatic inline int server_address_pretty(ServerAddress *a, char **pretty) {\n        return sockaddr_pretty(&a->sockaddr.sa, a->socklen, true, true, pretty);\n}\n\nint server_name_new(Manager *m, ServerName **ret, ServerType type,const char *string);\nServerName *server_name_free(ServerName *n);\nvoid server_name_flush_addresses(ServerName *n);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "30μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "54μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "74536μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "23984μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "71456μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "43959μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "111μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "214130μs",
      "parallelizable_steps": [],
      "critical_path_length": "146133μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 0.5714285714285714
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 0.5714285714285714,
        "content_hash": "4b7bb2df975290cb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/timesync/timesyncd-server.h"
      }
    },
    "source_hash": "aa5b4c9093cc"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/bless-boot/bless-boot-generator.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <unistd.h>\n\n#include \"efivars.h\"\n#include \"generator.h\"\n#include \"initrd-util.h\"\n#include \"log.h\"\n#include \"special.h\"\n#include \"virt.h\"\n\n/* This generator pulls systemd-bless-boot.service into the initial transaction if the \"LoaderBootCountPath\"\n * EFI variable is set, i.e. the system boots up with boot counting in effect, which means we should mark the\n * boot as \"good\" if we manage to boot up far enough. */\n\nstatic int run(const char *dest, const char *dest_early, const char *dest_late) {\n        assert(dest_early);\n\n        if (in_initrd()) {\n                log_debug(\"Skipping generator, running in the initrd.\");\n                return 0;\n        }\n\n        if (detect_container() > 0) {\n                log_debug(\"Skipping generator, running in a container.\");\n                return 0;\n        }\n\n        if (!is_efi_boot()) {\n                log_debug(\"Skipping generator, not an EFI boot.\");\n                return 0;\n        }\n\n        if (access(EFIVAR_PATH(EFI_LOADER_VARIABLE_STR(\"LoaderBootCountPath\")), F_OK) < 0) {\n                if (errno == ENOENT) {\n                        log_debug_errno(errno, \"Skipping generator, not booted with boot counting in effect.\");\n                        return 0;\n                }\n\n                return log_error_errno(errno, \"Failed to check if LoaderBootCountPath EFI variable exists: %m\");\n        }\n\n        /* We pull this in from basic.target so that it ends up in all \"regular\" boot ups, but not in\n         * rescue.target or even emergency.target. */\n        return generator_add_symlink(dest_early, SPECIAL_BASIC_TARGET, \"wants\", \"systemd-bless-boot.service\");\n}\n\nDEFINE_MAIN_GENERATOR_FUNCTION(run);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "516μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "462μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "113482μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1175μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "501μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "116136μs",
      "parallelizable_steps": [],
      "critical_path_length": "114499μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 37,
        "complexity_score": 2.9729729729729732
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 37,
        "complexity_score": 2.9729729729729732,
        "content_hash": "5d552c1c5159ea5f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/bless-boot/bless-boot-generator.c"
      }
    },
    "source_hash": "af5fcbdf9959"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp6-option.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcp6optionhfoo\n#define foosddhcp6optionhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n#include \"sd-dhcp6-protocol.h\"  /* IWYU pragma: export */\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp6_option sd_dhcp6_option;\n\nint sd_dhcp6_option_new(uint16_t option, const void *data, size_t length, uint32_t enterprise_identifier, sd_dhcp6_option **ret);\nsd_dhcp6_option *sd_dhcp6_option_ref(sd_dhcp6_option *ra);\nsd_dhcp6_option *sd_dhcp6_option_unref(sd_dhcp6_option *ra);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp6_option, sd_dhcp6_option_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1045μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1708295μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2285μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1569μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "233080μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "278μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1946552μs",
      "parallelizable_steps": [],
      "critical_path_length": "1710142μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.4
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.4,
        "content_hash": "c382c77861603970"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp6-option.h"
      }
    },
    "source_hash": "77a166c8f502"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/home/test-homed-regression-31896.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-locator.h\"\n#include \"main-func.h\"\n#include \"tests.h\"\n\nstatic int run(int argc, char **argv) {\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *ref = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        const char *username = NULL;\n\n        /* This is a regression test for the following bug:\n         * https://github.com/systemd/systemd/pull/31896\n         * It is run as part of TEST-46-HOMED\n         */\n\n        test_setup_logging(LOG_DEBUG);\n        assert_se(sd_bus_open_system(&bus) >= 0);\n\n        assert_se(argc == 2);\n        username = argv[1];\n\n        assert_se(bus_call_method(bus, bus_home_mgr, \"RefHomeUnrestricted\", NULL, &ref, \"sb\", username, true) >= 0);\n\n        assert_se(bus_call_method_async(bus, NULL, bus_home_mgr, \"AuthenticateHome\", NULL, NULL, \"ss\", username, \"{}\") >= 0);\n        assert_se(sd_bus_flush(bus) >= 0);\n\n        (void) bus_call_method(bus, bus_home_mgr, \"ReleaseHome\", &error, NULL, \"s\", username);\n        assert_se(!sd_bus_error_has_name(&error, SD_BUS_ERROR_NO_REPLY)); /* Make sure we didn't crash */\n\n        return 0;\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "360μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "104395μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "794μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "144μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "72059μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "154μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "177906μs",
      "parallelizable_steps": [],
      "critical_path_length": "104693μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 1.153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 1.153846153846154,
        "content_hash": "80c0d47d1c9b09e6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/home/test-homed-regression-31896.c"
      }
    },
    "source_hash": "54dc96f24902"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/memory-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <threads.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"memory-util.h\"\n\nsize_t page_size(void) {\n        static thread_local size_t pgsz = 0;\n        long r;\n\n        if (_likely_(pgsz > 0))\n                return pgsz;\n\n        r = sysconf(_SC_PAGESIZE);\n        assert(r > 0);\n\n        pgsz = (size_t) r;\n        return pgsz;\n}\n\nbool memeqbyte(uint8_t byte, const void *data, size_t length) {\n        /* Does the buffer consist entirely of the same specific byte value?\n         * Copied from https://github.com/systemd/casync/, copied in turn from\n         * https://github.com/rustyrussell/ccan/blob/master/ccan/mem/mem.c#L92,\n         * which is licensed CC-0.\n         */\n\n        const uint8_t *p = data;\n\n        /* Check first 16 bytes manually */\n        for (size_t i = 0; i < 16; i++, length--) {\n                if (length == 0)\n                        return true;\n                if (p[i] != byte)\n                        return false;\n        }\n\n        /* Now we know first 16 bytes match, memcmp() with self.  */\n        return memcmp(data, p + 16, length) == 0;\n}\n\nvoid* memdup_reverse(const void *mem, size_t size) {\n        assert(mem);\n        assert(size != 0);\n\n        void *p = malloc(size);\n        if (!p)\n                return NULL;\n\n        uint8_t *p_dst = p;\n        const uint8_t *p_src = mem;\n        for (size_t i = 0, k = size; i < size; i++, k--)\n                p_dst[i] = p_src[k-1];\n\n        return p;\n}\n\nvoid* erase_and_free(void *p) {\n        size_t l;\n\n        if (!p)\n                return NULL;\n\n        l = MALLOC_SIZEOF_SAFE(p);\n        explicit_bzero_safe(p, l);\n        return mfree(p);\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "617μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "733272μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "70μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1300μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "242005μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "128μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "977392μs",
      "parallelizable_steps": [],
      "critical_path_length": "734700μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154,
        "content_hash": "f206851f3461b99d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/memory-util.c"
      }
    },
    "source_hash": "eca31c429f26"
  },
  {
    "instruction": "Analyze and decompose this tcp_udp code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-ip-protocol-list.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <netinet/in.h>\n\n#include \"ip-protocol-list.h\"\n#include \"stdio-util.h\"\n#include \"tests.h\"\n\nstatic void test_int(int i) {\n        char str[DECIMAL_STR_MAX(int)];\n\n        assert_se(ip_protocol_from_name(ip_protocol_to_name(i)) == i);\n\n        xsprintf(str, \"%i\", i);\n        assert_se(ip_protocol_from_name(ip_protocol_to_name(parse_ip_protocol(str))) == i);\n}\n\nstatic void test_int_fail(int i, int error) {\n        char str[DECIMAL_STR_MAX(int)];\n\n        assert_se(!ip_protocol_to_name(i));\n\n        xsprintf(str, \"%i\", i);\n        assert_se(parse_ip_protocol(str) == error);\n}\n\nstatic void test_str(const char *s) {\n        ASSERT_STREQ(ip_protocol_to_name(ip_protocol_from_name(s)), s);\n        ASSERT_STREQ(ip_protocol_to_name(parse_ip_protocol(s)), s);\n}\n\nstatic void test_str_fail(const char *s, int error) {\n        assert_se(ip_protocol_from_name(s) == -EINVAL);\n        assert_se(parse_ip_protocol(s) == error);\n}\n\nTEST(integer) {\n        test_int(IPPROTO_TCP);\n        test_int(IPPROTO_DCCP);\n        test_int_fail(-1, -ERANGE);\n        test_int_fail(1024 * 1024, -EPROTONOSUPPORT);\n}\n\nTEST(string) {\n        test_str(\"sctp\");\n        test_str(\"udp\");\n        test_str_fail(\"hoge\", -EINVAL);\n        test_str_fail(\"-1\", -ERANGE);\n        test_str_fail(\"1000000000\", -EPROTONOSUPPORT);\n}\n\nTEST(parse_ip_protocol) {\n        assert_se(parse_ip_protocol(\"sctp\") == IPPROTO_SCTP);\n        assert_se(parse_ip_protocol(\"ScTp\") == IPPROTO_SCTP);\n        assert_se(parse_ip_protocol(\"mptcp\") == IPPROTO_MPTCP);\n        assert_se(parse_ip_protocol(\"MPTCP\") == IPPROTO_MPTCP);\n        assert_se(parse_ip_protocol(\"ip\") == IPPROTO_IP);\n        assert_se(parse_ip_protocol(\"\") == IPPROTO_IP);\n        assert_se(parse_ip_protocol(\"1\") == 1);\n        assert_se(parse_ip_protocol(\"0\") == 0);\n        assert_se(parse_ip_protocol(\"-10\") == -ERANGE);\n        assert_se(parse_ip_protocol(\"100000000\") == -EPROTONOSUPPORT);\n}\n\nTEST(parse_ip_protocol_full) {\n        assert_se(parse_ip_protocol_full(\"-1\", true) == -ERANGE);\n        assert_se(parse_ip_protocol_full(\"0\", true) == 0);\n        assert_se(parse_ip_protocol_full(\"11\", true) == 11);\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Tcp Udp Implementation",
      "category": "tcp_udp",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "5μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "19μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "8432μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "56μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "26μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "8538μs",
      "parallelizable_steps": [],
      "critical_path_length": "8463μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.17857142857142855
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "tcp_udp",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.17857142857142855,
        "content_hash": "5081a7ac81d95abb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-ip-protocol-list.c"
      }
    },
    "source_hash": "d5b6305d4539"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/netif-sriov.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/if_link.h>\n#include <net/ethernet.h>\n\n#include \"conf-parser-forward.h\"\n#include \"forward.h\"\n\ntypedef enum SRIOVAttribute {\n        SR_IOV_VF_MAC,\n        SR_IOV_VF_SPOOFCHK,\n        SR_IOV_VF_RSS_QUERY_EN,\n        SR_IOV_VF_TRUST,\n        SR_IOV_VF_LINK_STATE,\n        SR_IOV_VF_VLAN_LIST,\n        _SR_IOV_ATTRIBUTE_MAX,\n        _SR_IOV_ATTRIBUTE_INVALID = -EINVAL,\n} SRIOVAttribute;\n\ntypedef enum SRIOVLinkState {\n        SR_IOV_LINK_STATE_AUTO     = IFLA_VF_LINK_STATE_AUTO,\n        SR_IOV_LINK_STATE_ENABLE   = IFLA_VF_LINK_STATE_ENABLE,\n        SR_IOV_LINK_STATE_DISABLE  = IFLA_VF_LINK_STATE_DISABLE,\n        _SR_IOV_LINK_STATE_MAX,\n        _SR_IOV_LINK_STATE_INVALID = -EINVAL,\n} SRIOVLinkState;\n\ntypedef struct SRIOV {\n        ConfigSection *section;\n        OrderedHashmap *sr_iov_by_section;\n\n        uint32_t vf;   /* 0 - 2147483646 */\n        uint32_t vlan; /* 0 - 4095, 0 disables VLAN filter */\n        uint32_t qos;\n        uint16_t vlan_proto; /* ETH_P_8021Q or ETH_P_8021AD */\n        int vf_spoof_check_setting;\n        int query_rss;\n        int trust;\n        SRIOVLinkState link_state;\n        struct ether_addr mac;\n} SRIOV;\n\nconst char* sr_iov_attribute_to_string(SRIOVAttribute a) _const_;\n\nvoid sr_iov_hash_func(const SRIOV *sr_iov, struct siphash *state);\nint sr_iov_compare_func(const SRIOV *s1, const SRIOV *s2);\nbool sr_iov_has_config(SRIOV *sr_iov, SRIOVAttribute attr);\nint sr_iov_set_netlink_message(SRIOV *sr_iov, SRIOVAttribute attr, sd_netlink_message *req);\nint sr_iov_get_num_vfs(sd_device *device, uint32_t *ret);\nint sr_iov_set_num_vfs(sd_device *device, uint32_t num_vfs, OrderedHashmap *sr_iov_by_section);\nint sr_iov_drop_invalid_sections(uint32_t num_vfs, OrderedHashmap *sr_iov_by_section);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_sr_iov_uint32);\nCONFIG_PARSER_PROTOTYPE(config_parse_sr_iov_boolean);\nCONFIG_PARSER_PROTOTYPE(config_parse_sr_iov_link_state);\nCONFIG_PARSER_PROTOTYPE(config_parse_sr_iov_vlan_proto);\nCONFIG_PARSER_PROTOTYPE(config_parse_sr_iov_mac);\nCONFIG_PARSER_PROTOTYPE(config_parse_sr_iov_num_vfs);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "182μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "87μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "96137μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "45μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "55μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "96506μs",
      "parallelizable_steps": [],
      "critical_path_length": "96374μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 1.4000000000000001
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 1.4000000000000001,
        "content_hash": "36436c1284d62aff"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/netif-sriov.h"
      }
    },
    "source_hash": "e6409cbef4a8"
  },
  {
    "instruction": "Analyze and decompose this tcp_udp code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netfilter/nf_conntrack_tuple_common.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _NF_CONNTRACK_TUPLE_COMMON_H\n#define _NF_CONNTRACK_TUPLE_COMMON_H\n\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_conntrack_common.h> /* IP_CT_IS_REPLY */\n\nenum ip_conntrack_dir {\n\tIP_CT_DIR_ORIGINAL,\n\tIP_CT_DIR_REPLY,\n\tIP_CT_DIR_MAX\n};\n\n/* The protocol-specific manipulable parts of the tuple: always in\n * network order\n */\nunion nf_conntrack_man_proto {\n\t/* Add other protocols here. */\n\t__be16 all;\n\n\tstruct {\n\t\t__be16 port;\n\t} tcp;\n\tstruct {\n\t\t__be16 port;\n\t} udp;\n\tstruct {\n\t\t__be16 id;\n\t} icmp;\n\tstruct {\n\t\t__be16 port;\n\t} dccp;\n\tstruct {\n\t\t__be16 port;\n\t} sctp;\n\tstruct {\n\t\t__be16 key;\t/* GRE key is 32bit, PPtP only uses 16bit */\n\t} gre;\n};\n\n#define CTINFO2DIR(ctinfo) ((ctinfo) >= IP_CT_IS_REPLY ? IP_CT_DIR_REPLY : IP_CT_DIR_ORIGINAL)\n\n#endif /* _NF_CONNTRACK_TUPLE_COMMON_H */\n",
    "output": {
      "operation": "Tcp Udp Implementation",
      "category": "tcp_udp",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "107μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "15μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "88275μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "184μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "87μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "88668μs",
      "parallelizable_steps": [],
      "critical_path_length": "88469μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 38,
        "complexity_score": 1.3157894736842104
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "tcp_udp",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 38,
        "complexity_score": 1.3157894736842104,
        "content_hash": "9f5bfd0828e15b6b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netfilter/nf_conntrack_tuple_common.h"
      }
    },
    "source_hash": "6906f8525b26"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dhcp4.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\ntypedef enum DHCPClientIdentifier {\n        DHCP_CLIENT_ID_MAC,\n        DHCP_CLIENT_ID_DUID,\n        _DHCP_CLIENT_ID_MAX,\n        _DHCP_CLIENT_ID_INVALID = -EINVAL,\n} DHCPClientIdentifier;\n\nvoid network_adjust_dhcp4(Network *network);\nint dhcp4_update_mac(Link *link);\nint dhcp4_update_ipv6_connectivity(Link *link);\nint dhcp4_start_full(Link *link, bool set_ipv6_connectivity);\nstatic inline int dhcp4_start(Link *link) {\n        return dhcp4_start_full(link, true);\n}\nint dhcp4_renew(Link *link);\nint dhcp4_lease_lost(Link *link);\nint dhcp4_check_ready(Link *link);\n\nint link_request_dhcp4_client(Link *link);\nint link_drop_dhcp4_config(Link *link, Network *network);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_client_identifier);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_max_attempts);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_ip_service_type);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_socket_priority);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_mud_url);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_fallback_lease_lifetime);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_label);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "371μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "47μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "172147μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "782μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "204μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "173551μs",
      "parallelizable_steps": [],
      "critical_path_length": "172722μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 28,
        "complexity_score": 2.142857142857143
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 28,
        "complexity_score": 2.142857142857143,
        "content_hash": "8f984698e32c395f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dhcp4.h"
      }
    },
    "source_hash": "43d130cd3a70"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-pretty-print.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"pretty-print.h\"\n#include \"tests.h\"\n\n#define CYLON_WIDTH 6\n\nstatic void test_draw_cylon_one(unsigned pos) {\n        char buf[CYLON_WIDTH + CYLON_BUFFER_EXTRA + 1];\n\n        log_debug(\"/* %s(%u) */\", __func__, pos);\n\n        assert(pos <= CYLON_WIDTH + 1);\n\n        memset(buf, 0xff, sizeof(buf));\n        draw_cylon(buf, sizeof(buf), CYLON_WIDTH, pos);\n        ASSERT_LE(strlen(buf), sizeof(buf));\n}\n\nTEST(draw_cylon) {\n        bool saved = log_get_show_color();\n\n        log_show_color(false);\n        for (unsigned i = 0; i <= CYLON_WIDTH + 1; i++)\n                test_draw_cylon_one(i);\n\n        log_show_color(true);\n        for (unsigned i = 0; i <= CYLON_WIDTH + 1; i++)\n                test_draw_cylon_one(i);\n\n        log_show_color(saved);\n}\n\nTEST(terminal_urlify) {\n        _cleanup_free_ char *formatted = NULL;\n\n        assert_se(terminal_urlify(\"https://www.freedesktop.org/wiki/Software/systemd\", \"systemd homepage\", &formatted) >= 0);\n        printf(\"Hey, consider visiting the %s right now! It is very good!\\n\", formatted);\n\n        formatted = mfree(formatted);\n\n        assert_se(terminal_urlify_path(\"/etc/fstab\", \"this link to your /etc/fstab\", &formatted) >= 0);\n        printf(\"Or click on %s to have a look at it!\\n\", formatted);\n}\n\nTEST(cat_files) {\n        assert_se(cat_files(\"/no/such/file\", NULL, 0) == -ENOENT);\n        assert_se(cat_files(NULL, NULL, 0) == 0);\n\n        if (access(\"/etc/fstab\", R_OK) >= 0)\n                assert_se(cat_files(\"/etc/fstab\", STRV_MAKE(\"/etc/fstab\", \"/etc/fstab\"), 0) == 0);\n}\n\nTEST(red_green_cross_check_mark) {\n        bool b = false;\n\n        printf(\"yea: <%s>\\n\", GREEN_CHECK_MARK());\n        printf(\"nay: <%s>\\n\", RED_CROSS_MARK());\n\n        printf(\"%s → %s → %s → %s\\n\",\n               COLOR_MARK_BOOL(b),\n               COLOR_MARK_BOOL(!b),\n               COLOR_MARK_BOOL(!!b),\n               COLOR_MARK_BOOL(!!!b));\n}\n\nTEST(print_separator) {\n        print_separator();\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "574μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "488391μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "22μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1363μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "523389μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "810μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1014549μs",
      "parallelizable_steps": [],
      "critical_path_length": "523985μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 2.641509433962264
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 2.641509433962264,
        "content_hash": "f0a06b8b3d9e72fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-pretty-print.c"
      }
    },
    "source_hash": "c5d79fa0b990"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-audit.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/socket.h>\n\n#include \"journald-forward.h\"\n\nvoid manager_process_audit_message(Manager *m, const void *buffer, size_t buffer_size, const struct ucred *ucred, const union sockaddr_union *sa, socklen_t salen);\n\nvoid process_audit_string(Manager *m, int type, const char *data, size_t size);\n\nint manager_open_audit(Manager *m);\nvoid manager_reset_kernel_audit(Manager *m, int old_set_audit);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "296μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "227μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "314605μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "111584μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "365823μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "414666μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "318μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1207519μs",
      "parallelizable_steps": [],
      "critical_path_length": "681042μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 8,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 8,
        "complexity_score": 2.5,
        "content_hash": "0f58fbf6643b997f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-audit.h"
      }
    },
    "source_hash": "dd296fdb1398"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-hwdb.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdhwdbhfoo\n#define foosdhwdbhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_hwdb sd_hwdb;\n\nsd_hwdb *sd_hwdb_ref(sd_hwdb *hwdb);\nsd_hwdb *sd_hwdb_unref(sd_hwdb *hwdb);\n\nint sd_hwdb_new(sd_hwdb **ret);\nint sd_hwdb_new_from_path(const char *path, sd_hwdb **ret);\n\nint sd_hwdb_get(sd_hwdb *hwdb, const char *modalias, const char *key, const char **value);\n\nint sd_hwdb_seek(sd_hwdb *hwdb, const char *modalias);\nint sd_hwdb_enumerate(sd_hwdb *hwdb, const char **key, const char **value);\n\n/* the inverse condition avoids ambiguity of dangling 'else' after the macro */\n#define SD_HWDB_FOREACH_PROPERTY(hwdb, modalias, key, value)            \\\n        if (sd_hwdb_seek(hwdb, modalias) < 0) { }                       \\\n        else while (sd_hwdb_enumerate(hwdb, &(key), &(value)) > 0)\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_hwdb, sd_hwdb_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1057μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "701963μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "127μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "848μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "369139μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "283μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1073417μs",
      "parallelizable_steps": [],
      "critical_path_length": "703094μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 4.0625
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 4.0625,
        "content_hash": "1869619d698298ce"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-hwdb.h"
      }
    },
    "source_hash": "42569e907c93"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/kill.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum KillMode {\n        /* The kill mode is a property of a unit. */\n        KILL_CONTROL_GROUP = 0,\n        KILL_PROCESS,\n        KILL_MIXED,\n        KILL_NONE,\n        _KILL_MODE_MAX,\n        _KILL_MODE_INVALID = -EINVAL,\n} KillMode;\n\ntypedef struct KillContext {\n        KillMode kill_mode;\n        int kill_signal;\n        int restart_kill_signal;\n        int final_kill_signal;\n        int watchdog_signal;\n        bool send_sigkill;\n        bool send_sighup;\n} KillContext;\n\ntypedef enum KillWhom {\n        /* Kill whom is a property of an operation */\n        KILL_MAIN,\n        KILL_CONTROL,\n        KILL_ALL,\n        KILL_MAIN_FAIL,\n        KILL_CONTROL_FAIL,\n        KILL_ALL_FAIL,\n        KILL_CGROUP,\n        KILL_CGROUP_FAIL,\n        _KILL_WHOM_MAX,\n        _KILL_WHOM_INVALID = -EINVAL,\n} KillWhom;\n\nvoid kill_context_init(KillContext *c);\nvoid kill_context_dump(KillContext *c, FILE *f, const char *prefix);\n\nconst char* kill_mode_to_string(KillMode k) _const_;\nKillMode kill_mode_from_string(const char *s) _pure_;\n\nconst char* kill_whom_to_string(KillWhom k) _const_;\nKillWhom kill_whom_from_string(const char *s) _pure_;\n\nstatic inline int restart_kill_signal(const KillContext *c) {\n        if (c->restart_kill_signal != 0)\n                return c->restart_kill_signal;\n        return c->kill_signal;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "51μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "34708μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "80μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "12μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "34893μs",
      "parallelizable_steps": [],
      "critical_path_length": "34771μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 0.6666666666666666,
        "content_hash": "17e86cd97950b036"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/kill.h"
      }
    },
    "source_hash": "23b735df155b"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/efi-fundamental.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <stdint.h>\n\n/* Matches EFI API definition of the same structure for userspace */\ntypedef struct {\n        uint32_t Data1;\n        uint16_t Data2;\n        uint16_t Data3;\n        uint8_t Data4[8];\n} EFI_GUID;\n\n#if !SD_BOOT\n#  include <stdbool.h>\n#  include <string.h>\nstatic inline bool efi_guid_equal(const EFI_GUID *a, const EFI_GUID *b) {\n        return memcmp(a, b, sizeof(EFI_GUID)) == 0;\n}\n#endif\n\ntypedef struct {\n        EFI_GUID SignatureOwner;\n        uint8_t\tSignatureData[];\n} EFI_SIGNATURE_DATA;\n\ntypedef struct {\n        EFI_GUID SignatureType;\n        uint32_t SignatureListSize;\n        uint32_t SignatureHeaderSize;\n        uint32_t SignatureSize;\n        EFI_SIGNATURE_DATA Signatures[];\n} EFI_SIGNATURE_LIST;\n\ntypedef struct {\n        uint32_t dwLength;\n        uint16_t wRevision;\n        uint16_t wCertificateType;\n} WIN_CERTIFICATE_HEADER;\n\ntypedef struct {\n        WIN_CERTIFICATE_HEADER Hdr;\n        EFI_GUID CertType;\n        uint8_t CertData[];\n} WIN_CERTIFICATE_UEFI_GUID;\n\ntypedef struct {\n        uint16_t Year;\n        uint8_t Month;\n        uint8_t Day;\n        uint8_t Hour;\n        uint8_t Minute;\n        uint8_t Second;\n        uint8_t Pad1;\n        uint32_t Nanosecond;\n        int16_t TimeZone;\n        uint8_t Daylight;\n        uint8_t Pad2;\n} EFI_TIME;\n\ntypedef struct {\n        EFI_TIME TimeStamp;\n        WIN_CERTIFICATE_UEFI_GUID AuthInfo;\n} EFI_VARIABLE_AUTHENTICATION_2;\n\n#define GUID_DEF(d1, d2, d3, d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8) \\\n    { d1, d2, d3, { d4_1, d4_2, d4_3, d4_4, d4_5, d4_6, d4_7, d4_8 } }\n\n/* Creates a EFI_GUID pointer suitable for EFI APIs. Use of const allows the compiler to merge multiple\n * uses (although, currently compilers do that regardless). Most EFI APIs declare their EFI_GUID input\n * as non-const, but almost all of them are in fact const. */\n#define MAKE_GUID_PTR(name) ((EFI_GUID *) &(const EFI_GUID) name##_GUID)\n\n#define EFI_GLOBAL_VARIABLE \\\n        GUID_DEF(0x8be4df61, 0x93ca, 0x11d2, 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c)\n#define EFI_IMAGE_SECURITY_DATABASE_GUID \\\n        GUID_DEF(0xd719b2cb, 0x3d3a, 0x4596, 0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f)\n\n#define EFI_CERT_X509_GUID \\\n        GUID_DEF(0xa5c059a1, 0x94e4, 0x4aa7, 0x87, 0xb5, 0xab, 0x15, 0x5c, 0x2b, 0xf0, 0x72)\n#define EFI_CERT_TYPE_PKCS7_GUID \\\n        GUID_DEF(0x4aafd29d, 0x68df, 0x49ee, 0x8a, 0xa9, 0x34, 0x7d, 0x37, 0x56, 0x65, 0xa7)\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "62μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "109μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "93684μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "33μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "285μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "94173μs",
      "parallelizable_steps": [],
      "critical_path_length": "94031μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 69,
        "complexity_score": 1.4492753623188406
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 69,
        "complexity_score": 1.4492753623188406,
        "content_hash": "75f2ed21a326f94b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/efi-fundamental.h"
      }
    },
    "source_hash": "cc263d6cf8dd"
  },
  {
    "instruction": "Analyze and decompose this tcp_udp code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netfilter/xt_tcpudp.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _XT_TCPUDP_H\n#define _XT_TCPUDP_H\n\n#include <linux/types.h>\n\n/* TCP matching stuff */\nstruct xt_tcp {\n\t__u16 spts[2];\t\t\t/* Source port range. */\n\t__u16 dpts[2];\t\t\t/* Destination port range. */\n\t__u8 option;\t\t\t/* TCP Option iff non-zero*/\n\t__u8 flg_mask;\t\t\t/* TCP flags mask byte */\n\t__u8 flg_cmp;\t\t\t/* TCP flags compare byte */\n\t__u8 invflags;\t\t\t/* Inverse flags */\n};\n\n/* Values for \"inv\" field in struct ipt_tcp. */\n#define XT_TCP_INV_SRCPT\t0x01\t/* Invert the sense of source ports. */\n#define XT_TCP_INV_DSTPT\t0x02\t/* Invert the sense of dest ports. */\n#define XT_TCP_INV_FLAGS\t0x04\t/* Invert the sense of TCP flags. */\n#define XT_TCP_INV_OPTION\t0x08\t/* Invert the sense of option test. */\n#define XT_TCP_INV_MASK\t\t0x0F\t/* All possible flags. */\n\n/* UDP matching stuff */\nstruct xt_udp {\n\t__u16 spts[2];\t\t\t/* Source port range. */\n\t__u16 dpts[2];\t\t\t/* Destination port range. */\n\t__u8 invflags;\t\t\t/* Inverse flags */\n};\n\n/* Values for \"invflags\" field in struct ipt_udp. */\n#define XT_UDP_INV_SRCPT\t0x01\t/* Invert the sense of source ports. */\n#define XT_UDP_INV_DSTPT\t0x02\t/* Invert the sense of dest ports. */\n#define XT_UDP_INV_MASK\t0x03\t/* All possible flags. */\n\n\n#endif\n",
    "output": {
      "operation": "Tcp Udp Implementation",
      "category": "tcp_udp",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "464μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "281μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "37238μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "205μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "76μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "38264μs",
      "parallelizable_steps": [],
      "critical_path_length": "37778μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 2.3333333333333335
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "tcp_udp",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 2.3333333333333335,
        "content_hash": "419648f64f462d15"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netfilter/xt_tcpudp.h"
      }
    },
    "source_hash": "9f95edf76eb1"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-cryptolib.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"openssl-util.h\"\n#include \"tests.h\"\n\nTEST(string_hashsum) {\n        _cleanup_free_ char *out1 = NULL, *out2 = NULL, *out3 = NULL, *out4 = NULL;\n\n        ASSERT_OK(string_hashsum(\"asdf\", 4, \"SHA224\", &out1));\n        /* echo -n 'asdf' | sha224sum - */\n        ASSERT_STREQ(out1, \"7872a74bcbf298a1e77d507cd95d4f8d96131cbbd4cdfc571e776c8a\");\n\n        ASSERT_OK(string_hashsum(\"asdf\", 4, \"SHA256\", &out2));\n        /* echo -n 'asdf' | sha256sum - */\n        ASSERT_STREQ(out2, \"f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b\");\n\n        ASSERT_OK(string_hashsum(\"\", 0, \"SHA224\", &out3));\n        /* echo -n '' | sha224sum - */\n        ASSERT_STREQ(out3, \"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\");\n\n        ASSERT_OK(string_hashsum(\"\", 0, \"SHA256\", &out4));\n        /* echo -n '' | sha256sum - */\n        ASSERT_STREQ(out4, \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\");\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "86μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "167290μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "147μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "221μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "69946μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "95μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "237785μs",
      "parallelizable_steps": [],
      "critical_path_length": "167606μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 0.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 0.5,
        "content_hash": "8d2d2f16bd99037d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-cryptolib.c"
      }
    },
    "source_hash": "a539c8fcd447"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/fuzz-dhcp-client.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/socket.h>\n\n#include \"dhcp-network.h\"\n#include \"fuzz.h\"\n#include \"network-internal.h\"\n#include \"sd-dhcp-client.c\"\n#include \"tmpfile-util.h\"\n\nint dhcp_network_bind_raw_socket(\n                int ifindex,\n                union sockaddr_union *link,\n                uint32_t id,\n                const struct hw_addr_data *hw_addr,\n                const struct hw_addr_data *bcast_addr,\n                uint16_t arp_type,\n                uint16_t port,\n                bool so_priority_set,\n                int so_priority) {\n\n        int fd;\n        fd = socket(AF_INET, SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0);\n        if (fd < 0)\n                return -errno;\n\n        return fd;\n}\n\nint dhcp_network_send_raw_socket(int s, const union sockaddr_union *link, const void *packet, size_t len) {\n        return len;\n}\n\nint dhcp_network_bind_udp_socket(int ifindex, be32_t address, uint16_t port, int ip_service_type) {\n        int fd;\n\n        fd = socket(AF_INET, SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0);\n        if (fd < 0)\n                return -errno;\n\n        return fd;\n}\n\nint dhcp_network_send_udp_socket(int s, be32_t address, uint16_t port, const void *packet, size_t len) {\n        return len;\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        uint8_t mac_addr[] = {'A', 'B', 'C', '1', '2', '3'};\n        uint8_t bcast_addr[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n        _cleanup_(sd_dhcp_client_unrefp) sd_dhcp_client *client = NULL;\n        _cleanup_(sd_event_unrefp) sd_event *e = NULL;\n        _cleanup_(sd_dhcp_lease_unrefp) sd_dhcp_lease *lease = NULL;\n        _cleanup_(unlink_tempfilep) char lease_file[] = \"/tmp/fuzz-dhcp-client.XXXXXX\";\n        _cleanup_close_ int fd = -1;\n        int res, r;\n\n        assert_se(setenv(\"SYSTEMD_NETWORK_TEST_MODE\", \"1\", 1) >= 0);\n\n        fuzz_setup_logging();\n\n        r = sd_dhcp_client_new(&client, false);\n        assert_se(r >= 0);\n        assert_se(client);\n\n        assert_se(sd_event_new(&e) >= 0);\n\n        r = sd_dhcp_client_attach_event(client, e, 0);\n        assert_se(r >= 0);\n\n        assert_se(sd_dhcp_client_set_ifindex(client, 42) >= 0);\n        assert_se(sd_dhcp_client_set_mac(client, mac_addr, bcast_addr, ETH_ALEN, ARPHRD_ETHER) >= 0);\n\n        res = sd_dhcp_client_start(client);\n        assert_se(IN_SET(res, 0, -EINPROGRESS));\n        client->xid = 2;\n        client->state = DHCP_STATE_SELECTING;\n\n        if (client_handle_offer_or_rapid_ack(client, (DHCPMessage*) data, size, NULL) < 0)\n                goto end;\n\n        fd = mkostemp_safe(lease_file);\n        assert_se(fd >= 0);\n\n        r = dhcp_lease_save(client->lease, lease_file);\n        assert_se(r >= 0);\n\n        r = dhcp_lease_load(&lease, lease_file);\n        assert_se(r >= 0);\n\nend:\n        assert_se(sd_dhcp_client_stop(client) >= 0);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "143μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "87μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "66918μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "239μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "128μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "67515μs",
      "parallelizable_steps": [],
      "critical_path_length": "67189μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 71,
        "complexity_score": 0.9859154929577464
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 71,
        "complexity_score": 0.9859154929577464,
        "content_hash": "d5f3c33a1cf4e903"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/fuzz-dhcp-client.c"
      }
    },
    "source_hash": "99ec1ccd38a5"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/sha1-fundamental.h\n\nCode:\n/* SPDX-License-Identifier: LicenseRef-alg-sha1-public-domain */\n\n/*\n * This is an implementation of the National Institute of Standards\n * and Technology US Secure Hash Algorithm 1 (SHA1).\n *\n * Public api for steve reid's public domain SHA-1 implementation.\n * This file is in the public domain.\n */\n#pragma once\n\n#include <stddef.h>\n#include <stdint.h>\n\n#define SHA1_DIGEST_SIZE 20\n\n/* Structure to save state of computation between the single steps.  */\nstruct sha1_ctx {\n        uint32_t state[5];\n        uint32_t count[2];\n        uint8_t buffer[64];\n};\n\n/* Initialize structure containing state of computation.\n   (RFC 3174, 6.1)  */\nvoid sha1_init_ctx(struct sha1_ctx *ctx);\n\n/* Starting with the result of former calls of this function (or the\n   initialization function) update the context for the next LEN bytes\n   starting at BUFFER.  LEN does not need to be a multiple of 64.  */\nvoid sha1_process_bytes(const void *buffer, size_t size, struct sha1_ctx *ctx);\n\n/* Process the remaining bytes in the buffer and write the finalized\n   hash to RESBUF, which should point to 20 bytes of storage.  All\n   data written to CTX is erased before returning from the function.  */\nvoid *sha1_finish_ctx(struct sha1_ctx *ctx, uint8_t result[static SHA1_DIGEST_SIZE]);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "394μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "238μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "204404μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "565μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "119μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "205720μs",
      "parallelizable_steps": [],
      "critical_path_length": "204917μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 29,
        "complexity_score": 2.0689655172413794
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 29,
        "complexity_score": 2.0689655172413794,
        "content_hash": "0fa5c8ed642c384c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/sha1-fundamental.h"
      }
    },
    "source_hash": "21ac123d8fbf"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/import/pull-common.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"import-common.h\"\n#include \"import-util.h\"\n#include \"pull-job.h\"\n\ntypedef struct CurlGlue CurlGlue;\ntypedef struct PullJob PullJob;\n\nint pull_find_old_etags(const char *url, const char *root, int dt, const char *prefix, const char *suffix, char ***etags);\n\nint pull_make_path(const char *url, const char *etag, const char *image_root, const char *prefix, const char *suffix, char **ret);\n\nint pull_make_auxiliary_job(PullJob **ret, const char *url, int (*strip_suffixes)(const char *name, char **ret), const char *suffix, ImportVerify verify, CurlGlue *glue, PullJobOpenDisk on_open_disk, PullJobFinished on_finished, void *userdata);\nint pull_make_verification_jobs(PullJob **ret_checksum_job, PullJob **ret_signature_job, ImportVerify verify, const char *checksum, const char *url, CurlGlue *glue, PullJobFinished on_finished, void *userdata);\n\nint pull_verify(ImportVerify verify, const char *checksum, PullJob *main_job, PullJob *checksum_job, PullJob *signature_job, PullJob *settings_job, PullJob *roothash_job, PullJob *roothash_signature_job, PullJob *verity_job);\n\ntypedef enum VerificationStyle {\n        VERIFICATION_PER_FILE,      /* SUSE-style \".sha256\" files with detached gpg signature */\n        VERIFICATION_PER_DIRECTORY, /* Ubuntu-style SHA256SUM files with detached SHA256SUM.gpg signatures */\n        _VERIFICATION_STYLE_MAX,\n        _VERIFICATION_STYLE_INVALID = -EINVAL,\n} VerificationStyle;\n\nint verification_style_from_url(const char *url, VerificationStyle *style);\n\ntypedef enum SignatureStyle {\n        SIGNATURE_GPG_PER_FILE,      /* \".sha256\" files with detached .gpg signature */\n        SIGNATURE_ASC_PER_FILE,      /* SUSE-style \".sha256\" files with detached .asc signature */\n        SIGNATURE_GPG_PER_DIRECTORY, /* Ubuntu-style SHA256SUM files with detached SHA256SUM.gpg signatures */\n        SIGNATURE_ASC_PER_DIRECTORY, /* SUSE-style SHA256SUM files with detached SHA256SUM.asc signatures */\n        _SIGNATURE_STYLE_MAX,\n        _SIGNATURE_STYLE_INVALID = -EINVAL,\n} SignatureStyle;\n\nint signature_style_from_url(const char *url, SignatureStyle *style, char **ret_filename);\n\nint pull_job_restart_with_sha256sum(PullJob *job, char **ret);\nint pull_job_restart_with_signature(PullJob *job, char **ret);\n\nbool pull_validate_local(const char *name, ImportFlags flags);\n\nint pull_url_needs_checksum(const char *url);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "55μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "16μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "149253μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "551μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "150163μs",
      "parallelizable_steps": [],
      "critical_path_length": "149859μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 7.878787878787879
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 7.878787878787879,
        "content_hash": "8a2c2f323e8aee62"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/import/pull-common.h"
      }
    },
    "source_hash": "a935eee7f14d"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp-duid-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-dhcp-duid.h\"\n#include \"sd-id128.h\"\n\n#include \"ether-addr-util.h\"\n#include \"forward.h\"\n#include \"sparse-endian.h\"\n\n#define SYSTEMD_PEN    43793\n\ntypedef enum DUIDType {\n        DUID_TYPE_LLT      = SD_DUID_TYPE_LLT,\n        DUID_TYPE_EN       = SD_DUID_TYPE_EN,\n        DUID_TYPE_LL       = SD_DUID_TYPE_LL,\n        DUID_TYPE_UUID     = SD_DUID_TYPE_UUID,\n        _DUID_TYPE_MAX,\n        _DUID_TYPE_INVALID = -EINVAL,\n} DUIDType;\n\n/* RFC 8415 section 11.1:\n * A DUID consists of a 2-octet type code represented in network byte order, followed by a variable number of\n * octets that make up the actual identifier. The length of the DUID (not including the type code) is at\n * least 1 octet and at most 128 octets. */\n#define MIN_DUID_DATA_LEN 1\n#define MAX_DUID_DATA_LEN 128\n#define MIN_DUID_LEN (sizeof(be16_t) + MIN_DUID_DATA_LEN)\n#define MAX_DUID_LEN (sizeof(be16_t) + MAX_DUID_DATA_LEN)\n\n/* https://tools.ietf.org/html/rfc3315#section-9.1 */\nstruct duid {\n        be16_t type;\n        union {\n                struct {\n                        /* DUID_TYPE_LLT */\n                        be16_t htype;\n                        be32_t time;\n                        uint8_t haddr[HW_ADDR_MAX_SIZE];\n                } _packed_ llt;\n                struct {\n                        /* DUID_TYPE_EN */\n                        be32_t pen;\n                        /* The maximum length of vendor ID is not provided in RFC 8415, but we use 8 bytes.\n                         * See https://datatracker.ietf.org/doc/html/rfc8415#section-11.3 */\n                        uint8_t id[8];\n                } _packed_ en;\n                struct {\n                        /* DUID_TYPE_LL */\n                        be16_t htype;\n                        uint8_t haddr[HW_ADDR_MAX_SIZE];\n                } _packed_ ll;\n                struct {\n                        /* DUID_TYPE_UUID */\n                        sd_id128_t uuid;\n                } _packed_ uuid;\n                uint8_t data[MAX_DUID_DATA_LEN];\n        };\n} _packed_;\n\nassert_cc(sizeof(struct duid) == MAX_DUID_LEN);\n\ntypedef struct sd_dhcp_duid {\n        size_t size;\n        union {\n                struct duid duid;\n                uint8_t raw[MAX_DUID_LEN];\n        };\n} sd_dhcp_duid;\n\nstatic inline bool duid_size_is_valid(size_t size) {\n        return size >= MIN_DUID_LEN && size <= MAX_DUID_LEN;\n}\n\nstatic inline bool duid_data_size_is_valid(size_t size) {\n        return size >= MIN_DUID_DATA_LEN && size <= MAX_DUID_DATA_LEN;\n}\n\nconst char* duid_type_to_string(DUIDType t) _const_;\nint dhcp_duid_to_string_internal(uint16_t type, const void *data, size_t data_size, char **ret);\n\nint dhcp_identifier_set_iaid(\n                sd_device *dev,\n                const struct hw_addr_data *hw_addr,\n                bool legacy_unstable_byteorder,\n                void *ret);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "159μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "123673μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "385μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "85772μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "189μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "210497μs",
      "parallelizable_steps": [],
      "critical_path_length": "124247μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 0.5405405405405406
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 0.5405405405405406,
        "content_hash": "9c93f42597333238"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp-duid-internal.h"
      }
    },
    "source_hash": "65144d5c6bca"
  },
  {
    "instruction": "Study and decompose this proxy_tunneling code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/ip6_tunnel.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _IP6_TUNNEL_H\n#define _IP6_TUNNEL_H\n\n#include <linux/types.h>\n#include <linux/if.h>\t\t/* For IFNAMSIZ. */\n#include <linux/in6.h>\t\t/* For struct in6_addr. */\n\n#define IPV6_TLV_TNL_ENCAP_LIMIT 4\n#define IPV6_DEFAULT_TNL_ENCAP_LIMIT 4\n\n/* don't add encapsulation limit if one isn't present in inner packet */\n#define IP6_TNL_F_IGN_ENCAP_LIMIT 0x1\n/* copy the traffic class field from the inner packet */\n#define IP6_TNL_F_USE_ORIG_TCLASS 0x2\n/* copy the flowlabel from the inner packet */\n#define IP6_TNL_F_USE_ORIG_FLOWLABEL 0x4\n/* being used for Mobile IPv6 */\n#define IP6_TNL_F_MIP6_DEV 0x8\n/* copy DSCP from the outer packet */\n#define IP6_TNL_F_RCV_DSCP_COPY 0x10\n/* copy fwmark from inner packet */\n#define IP6_TNL_F_USE_ORIG_FWMARK 0x20\n/* allow remote endpoint on the local node */\n#define IP6_TNL_F_ALLOW_LOCAL_REMOTE 0x40\n\nstruct ip6_tnl_parm {\n\tchar name[IFNAMSIZ];\t/* name of tunnel device */\n\tint link;\t\t/* ifindex of underlying L2 interface */\n\t__u8 proto;\t\t/* tunnel protocol */\n\t__u8 encap_limit;\t/* encapsulation limit for tunnel */\n\t__u8 hop_limit;\t\t/* hop limit for tunnel */\n\t__be32 flowinfo;\t/* traffic class and flowlabel for tunnel */\n\t__u32 flags;\t\t/* tunnel flags */\n\tstruct in6_addr laddr;\t/* local tunnel end-point address */\n\tstruct in6_addr raddr;\t/* remote tunnel end-point address */\n};\n\nstruct ip6_tnl_parm2 {\n\tchar name[IFNAMSIZ];\t/* name of tunnel device */\n\tint link;\t\t/* ifindex of underlying L2 interface */\n\t__u8 proto;\t\t/* tunnel protocol */\n\t__u8 encap_limit;\t/* encapsulation limit for tunnel */\n\t__u8 hop_limit;\t\t/* hop limit for tunnel */\n\t__be32 flowinfo;\t/* traffic class and flowlabel for tunnel */\n\t__u32 flags;\t\t/* tunnel flags */\n\tstruct in6_addr laddr;\t/* local tunnel end-point address */\n\tstruct in6_addr raddr;\t/* remote tunnel end-point address */\n\n\t__be16\t\t\ti_flags;\n\t__be16\t\t\to_flags;\n\t__be32\t\t\ti_key;\n\t__be32\t\t\to_key;\n};\n\n#endif\n",
    "output": {
      "operation": "Proxy Tunneling Implementation",
      "category": "proxy_tunneling",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "699μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "354μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "278960μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1360μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "722μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "282095μs",
      "parallelizable_steps": [],
      "critical_path_length": "280381μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 4.081632653061225
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "proxy_tunneling",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 4.081632653061225,
        "content_hash": "e8dec4d84ffc451e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/ip6_tunnel.h"
      },
      "variation": true
    },
    "source_hash": "a1188c5c922f"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/sbat.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#ifdef SBAT_DISTRO\n#  include \"version.h\"\n#  define SBAT_MAGIC \"sbat,1,SBAT Version,sbat,1,https://github.com/rhboot/shim/blob/main/SBAT.md\\n\"\n#  define SBAT_BOOT_SECTION_TEXT \\\n        SBAT_MAGIC \\\n        SBAT_PROJECT \"-boot\" \",1,The systemd Developers,\" SBAT_PROJECT \",\" PROJECT_VERSION \",\" PROJECT_URL \"\\n\" \\\n        SBAT_PROJECT \"-boot\" \".\" SBAT_DISTRO \",\" STRINGIFY(SBAT_DISTRO_GENERATION) \",\" SBAT_DISTRO_SUMMARY \",\" SBAT_DISTRO_PKGNAME \",\" SBAT_DISTRO_VERSION \",\" SBAT_DISTRO_URL \"\\n\"\n#  define SBAT_STUB_SECTION_TEXT \\\n        SBAT_MAGIC \\\n        SBAT_PROJECT \"-stub\" \",1,The systemd Developers,\" SBAT_PROJECT \",\" PROJECT_VERSION \",\" PROJECT_URL \"\\n\" \\\n        SBAT_PROJECT \"-stub\" \".\" SBAT_DISTRO \",\" STRINGIFY(SBAT_DISTRO_GENERATION) \",\" SBAT_DISTRO_SUMMARY \",\" SBAT_DISTRO_PKGNAME \",\" SBAT_DISTRO_VERSION \",\" SBAT_DISTRO_URL \"\\n\"\n#endif\n\n#ifdef SBAT_DISTRO\n#  define DECLARE_SBAT(text) DECLARE_NOALLOC_SECTION(\".sbat\", text)\n#  define DECLARE_SBAT_PADDED(text) DECLARE_NOALLOC_SECTION_PADDED(\".sbat\", text)\n#else\n#  define DECLARE_SBAT(text)\n#  define DECLARE_SBAT_PADDED(text)\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "371μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1080080μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "830μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1452μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "41144μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1107μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1124984μs",
      "parallelizable_steps": [],
      "critical_path_length": "1082639μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 3.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 3.5,
        "content_hash": "2770a5867f10243c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/sbat.h"
      }
    },
    "source_hash": "3e17af4f0ec6"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/daemon-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-daemon.h\"\n\n#include \"alloc-util.h\"\n#include \"daemon-util.h\"\n#include \"fd-util.h\"\n#include \"log.h\"\n#include \"string-util.h\"\n#include \"time-util.h\"\n\nint notify_remove_fd_warn(const char *name) {\n        int r;\n\n        assert(name);\n\n        r = sd_notifyf(/* unset_environment = */ false,\n                       \"FDSTOREREMOVE=1\\n\"\n                       \"FDNAME=%s\", name);\n        if (r < 0)\n                return log_warning_errno(r,\n                                         \"Failed to remove file descriptor \\\"%s\\\" from the store, ignoring: %m\",\n                                         name);\n\n        return 0;\n}\n\nint notify_remove_fd_warnf(const char *format, ...) {\n        _cleanup_free_ char *p = NULL;\n        va_list ap;\n        int r;\n\n        assert(format);\n\n        va_start(ap, format);\n        r = vasprintf(&p, format, ap);\n        va_end(ap);\n        if (r < 0)\n                return log_oom();\n\n        return notify_remove_fd_warn(p);\n}\n\nint close_and_notify_warn(int fd, const char *name) {\n        if (name)\n                (void) notify_remove_fd_warn(name);\n\n        return safe_close(fd);\n}\n\nint notify_push_fd(int fd, const char *name) {\n        _cleanup_free_ char *state = NULL;\n\n        assert(fd >= 0);\n        assert(name);\n\n        state = strjoin(\"FDSTORE=1\\n\"\n                        \"FDNAME=\", name);\n        if (!state)\n                return -ENOMEM;\n\n        /* Remove existing fds with the same name in fdstore. */\n        (void) notify_remove_fd_warn(name);\n\n        return sd_pid_notify_with_fds(0, /* unset_environment = */ false, state, &fd, 1);\n}\n\nint notify_push_fdf(int fd, const char *format, ...) {\n        _cleanup_free_ char *name = NULL;\n        va_list ap;\n        int r;\n\n        assert(fd >= 0);\n        assert(format);\n\n        va_start(ap, format);\n        r = vasprintf(&name, format, ap);\n        va_end(ap);\n        if (r < 0)\n                return -ENOMEM;\n\n        return notify_push_fd(fd, name);\n}\n\nint notify_reloading_full(const char *status) {\n        int r;\n\n        r = sd_notifyf(/* unset_environment = */ false,\n                       \"RELOADING=1\\n\"\n                       \"MONOTONIC_USEC=\" USEC_FMT\n                       \"%s%s\",\n                       now(CLOCK_MONOTONIC),\n                       status ? \"\\nSTATUS=\" : \"\", strempty(status));\n        if (r < 0)\n                return log_debug_errno(r, \"Failed to notify service manager for reloading status: %m\");\n\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "284μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "731μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "151395μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1243μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "303μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "153956μs",
      "parallelizable_steps": [],
      "critical_path_length": "151982μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 4.324324324324325
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 4.324324324324325,
        "content_hash": "f53b52e430325ff2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/daemon-util.c"
      }
    },
    "source_hash": "b541f1ae9171"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/fido_id/fuzz-fido-id-desc.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <linux/hid.h>\n\n#include \"fido_id_desc.h\"\n#include \"fuzz.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        fuzz_setup_logging();\n\n        if (outside_size_range(size, 0, HID_MAX_DESCRIPTOR_SIZE))\n                return 0;\n\n        (void) is_fido_security_token_desc(data, size);\n\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "290μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "281μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "36452μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "561μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "14μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "37598μs",
      "parallelizable_steps": [],
      "critical_path_length": "36756μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183,
        "content_hash": "ebae74c5255ef36d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/fido_id/fuzz-fido-id-desc.c"
      }
    },
    "source_hash": "fa004a8834c8"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolvectl.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum ExecutionMode {\n        MODE_RESOLVE_HOST,\n        MODE_RESOLVE_RECORD,\n        MODE_RESOLVE_SERVICE,\n        MODE_RESOLVE_OPENPGP,\n        MODE_RESOLVE_TLSA,\n        MODE_STATISTICS,\n        MODE_RESET_STATISTICS,\n        MODE_FLUSH_CACHES,\n        MODE_RESET_SERVER_FEATURES,\n        MODE_STATUS,\n        MODE_SET_LINK,\n        MODE_REVERT_LINK,\n        _MODE_INVALID = -EINVAL,\n} ExecutionMode;\n\nextern ExecutionMode arg_mode;\nextern char **arg_set_dns;\nextern char **arg_set_domain;\nextern bool arg_disable_default_route;\nextern bool arg_ifindex_permissive;\n\nint ifname_mangle_full(const char *s, bool drop_protocol_specifier);\nstatic inline int ifname_mangle(const char *s) {\n        return ifname_mangle_full(s, false);\n}\nstatic inline int ifname_resolvconf_mangle(const char *s) {\n        return ifname_mangle_full(s, true);\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "124μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "230μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "73254μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "388μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "116μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "74112μs",
      "parallelizable_steps": [],
      "critical_path_length": "73494μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4951c567dffc0b6c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolvectl.h"
      }
    },
    "source_hash": "39db00bd564c"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-delegate-bus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\nextern const BusObjectImplementation dns_delegate_object;\n\nchar* dns_delegate_bus_path(const DnsDelegate *d);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "659μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "141μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "190850μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "713615μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "687μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "192μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "906144μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "713948μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "4714aa5b512db8de"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-delegate-bus.h"
      }
    },
    "source_hash": "372557bcc7ff"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/fuzz-dns-packet.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"fuzz.h\"\n#include \"resolved-dns-packet.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_(dns_packet_unrefp) DnsPacket *p = NULL;\n\n        if (outside_size_range(size, 0, DNS_PACKET_SIZE_MAX))\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(dns_packet_new(&p, DNS_PROTOCOL_DNS, 0, DNS_PACKET_SIZE_MAX) >= 0);\n        p->size = 0; /* by default append starts after the header, undo that */\n        assert_se(dns_packet_append_blob(p, data, size, NULL) >= 0);\n        if (size < DNS_PACKET_HEADER_SIZE) {\n                /* make sure we pad the packet back up to the minimum header size */\n                assert_se(p->allocated >= DNS_PACKET_HEADER_SIZE);\n                memzero(DNS_PACKET_DATA(p) + size, DNS_PACKET_HEADER_SIZE - size);\n                p->size = DNS_PACKET_HEADER_SIZE;\n        }\n        (void) dns_packet_extract(p);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "142μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "61μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "98495μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "113470μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "142μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "41μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "212351μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "113572μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 1.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 1.5,
        "content_hash": "1b59101bcb65d334"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/fuzz-dns-packet.c"
      }
    },
    "source_hash": "413b3105b007"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/network-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\nsize_t serialize_in_addrs(FILE *f,\n                          const struct in_addr *addresses,\n                          size_t size,\n                          bool *with_leading_space,\n                          bool (*predicate)(const struct in_addr *addr));\nint deserialize_in_addrs(struct in_addr **addresses, const char *string);\nvoid serialize_in6_addrs(FILE *f, const struct in6_addr *addresses,\n                         size_t size,\n                         bool *with_leading_space);\nint deserialize_in6_addrs(struct in6_addr **addresses, const char *string);\n\nint serialize_dnr(FILE *f, const sd_dns_resolver *dnr, size_t n_dnr, bool *with_leading_space);\nint deserialize_dnr(sd_dns_resolver **ret, const char *string);\n\n/* don't include \"dhcp-lease-internal.h\" as it causes conflicts between netinet/ip.h and linux/ip.h */\nstruct sd_dhcp_route;\nstruct sd_dhcp_lease;\n\nvoid serialize_dhcp_routes(FILE *f, const char *key, struct sd_dhcp_route **routes, size_t size);\nint deserialize_dhcp_routes(struct sd_dhcp_route **ret, size_t *ret_size, const char *string);\n\n/* It is not necessary to add deserialize_dhcp_option(). Use unhexmem() instead. */\nint serialize_dhcp_option(FILE *f, const char *key, const void *data, size_t size);\n\nint dhcp_lease_save(sd_dhcp_lease *lease, const char *lease_file);\nint dhcp_lease_load(sd_dhcp_lease **ret, const char *lease_file);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "376μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "254μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "194871μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "126μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "379μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "196006μs",
      "parallelizable_steps": [],
      "critical_path_length": "195626μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 24,
        "complexity_score": 2.0833333333333335
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 24,
        "complexity_score": 2.0833333333333335,
        "content_hash": "ca20cf6be30e0f65"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/network-internal.h"
      }
    },
    "source_hash": "0c756a2d50c4"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fido2-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdio.h>\n\n#include \"alloc-util.h\"\n#include \"fido2-util.h\"\n#include \"fileio.h\"\n#include \"iovec-util.h\"\n#include \"libfido2-util.h\"\n#include \"log.h\"\n#include \"random-util.h\"\n\nint fido2_generate_salt(struct iovec *ret_salt) {\n        _cleanup_(iovec_done) struct iovec salt = {};\n        int r;\n\n        r = crypto_random_bytes_allocate_iovec(FIDO2_SALT_SIZE, &salt);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to generate FIDO2 salt: %m\");\n\n        *ret_salt = TAKE_STRUCT(salt);\n        return 0;\n}\n\nint fido2_read_salt_file(const char *filename, uint64_t offset, const char *client, const char *node, struct iovec *ret_salt) {\n        _cleanup_(iovec_done_erase) struct iovec salt = {};\n        _cleanup_free_ char *bind_name = NULL;\n        int r;\n\n        /* If we read the salt via AF_UNIX, make the client recognizable */\n        if (asprintf(&bind_name, \"@%\" PRIx64\"/%s-fido2-salt/%s\", random_u64(), client, node) < 0)\n                return log_oom();\n\n        r = read_full_file_full(\n                        AT_FDCWD, filename,\n                        offset == 0 ? UINT64_MAX : offset,\n                        /* size= */ FIDO2_SALT_SIZE,\n                        READ_FULL_FILE_SECURE|READ_FULL_FILE_WARN_WORLD_READABLE|\n                        READ_FULL_FILE_CONNECT_SOCKET|READ_FULL_FILE_FAIL_WHEN_LARGER,\n                        bind_name, (char**) &salt.iov_base, &salt.iov_len);\n        if (r == -E2BIG || (r >= 0 && salt.iov_len != FIDO2_SALT_SIZE))\n                return log_error_errno(r < 0 ? r : SYNTHETIC_ERRNO(EINVAL),\n                                       \"FIDO2 salt file must contain exactly %u bytes.\", FIDO2_SALT_SIZE);\n        if (r < 0)\n                return log_error_errno(r, \"Reading FIDO2 salt file '%s' failed: %m\", filename);\n\n        *ret_salt = TAKE_STRUCT(salt);\n        return 0;\n}\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "238μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "249μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "62882μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "505μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "205μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "64079μs",
      "parallelizable_steps": [],
      "critical_path_length": "63325μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 1.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 1.5,
        "content_hash": "a5480c3d8c2c390f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fido2-util.c"
      }
    },
    "source_hash": "f7601a5aafef"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemctl/systemctl-set-property.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-error.h\"\n#include \"bus-locator.h\"\n#include \"bus-unit-util.h\"\n#include \"bus-util.h\"\n#include \"errno-util.h\"\n#include \"strv.h\"\n#include \"systemctl.h\"\n#include \"systemctl-set-property.h\"\n#include \"systemctl-util.h\"\n#include \"unit-def.h\"\n#include \"unit-name.h\"\n\nstatic int set_property_one(sd_bus *bus, const char *name, char **properties) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *m = NULL;\n        int r;\n\n        r = bus_message_new_method_call(bus, &m, bus_systemd_mgr, \"SetUnitProperties\");\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        UnitType t = unit_name_to_type(name);\n        if (t < 0)\n                return log_error_errno(t, \"Invalid unit type: %s\", name);\n\n        r = sd_bus_message_append(m, \"sb\", name, arg_runtime);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_message_open_container(m, SD_BUS_TYPE_ARRAY, \"(sv)\");\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = bus_append_unit_property_assignment_many(m, t, properties);\n        if (r < 0)\n                return r;\n\n        r = sd_bus_message_close_container(m);\n        if (r < 0)\n                return bus_log_create_error(r);\n\n        r = sd_bus_call(bus, m, 0, &error, NULL);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to set unit properties on %s: %s\",\n                                       name, bus_error_message(&error, r));\n\n        return 0;\n}\n\nint verb_set_property(int argc, char *argv[], void *userdata) {\n        sd_bus *bus;\n        _cleanup_strv_free_ char **names = NULL;\n        int r;\n\n        r = acquire_bus(BUS_MANAGER, &bus);\n        if (r < 0)\n                return r;\n\n        polkit_agent_open_maybe();\n\n        r = expand_unit_names(bus, STRV_MAKE(argv[1]), NULL, &names, NULL);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to expand '%s' into names: %m\", argv[1]);\n\n        r = 0;\n        STRV_FOREACH(name, names)\n                RET_GATHER(r, set_property_one(bus, *name, strv_skip(argv, 2)));\n        return r;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "373μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "355μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "169786μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "64μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "285μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "170863μs",
      "parallelizable_steps": [],
      "critical_path_length": "170444μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.9298245614035086
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.9298245614035086,
        "content_hash": "26b06476eb743fb8"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemctl/systemctl-set-property.c"
      }
    },
    "source_hash": "e5effb20a6ff"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/meson-extract-unit-files.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\nimport json\nimport re\nimport subprocess\nimport sys\n\ndef main():\n    build_dir = sys.argv[1]\n\n    out = subprocess.run([\"meson\", \"introspect\", \"--installed\", build_dir],\n                         stdout=subprocess.PIPE, check=True)\n    files = json.loads(out.stdout)\n    for file in sorted(files.values()):\n        if re.search(\"^/usr/lib/systemd/(system|user)/\", file) and not file.endswith(\".conf\"):\n            print(file)\n\nif __name__ == \"__main__\":\n    main()\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "124μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "202μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "41417μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "814μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "339μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "42896μs",
      "parallelizable_steps": [],
      "critical_path_length": "41880μs",
      "metadata": {
        "functions_found": [
          "main"
        ],
        "classes_found": [],
        "imports": [
          "json",
          "re",
          "subprocess",
          "sys"
        ],
        "lines_of_code": 16,
        "complexity_score": 3.125
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [
          "main"
        ],
        "classes": [],
        "imports": [
          "json",
          "re",
          "subprocess",
          "sys"
        ],
        "lines_of_code": 16,
        "complexity_score": 3.125,
        "content_hash": "b885023841014d19"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/meson-extract-unit-files.py"
      }
    },
    "source_hash": "17f1ebcc9405"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/coredump-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum CoredumpFilter {\n        COREDUMP_FILTER_PRIVATE_ANONYMOUS = 0,\n        COREDUMP_FILTER_SHARED_ANONYMOUS,\n        COREDUMP_FILTER_PRIVATE_FILE_BACKED,\n        COREDUMP_FILTER_SHARED_FILE_BACKED,\n        COREDUMP_FILTER_ELF_HEADERS,\n        COREDUMP_FILTER_PRIVATE_HUGE,\n        COREDUMP_FILTER_SHARED_HUGE,\n        COREDUMP_FILTER_PRIVATE_DAX,\n        COREDUMP_FILTER_SHARED_DAX,\n        _COREDUMP_FILTER_MAX,\n        _COREDUMP_FILTER_INVALID = -EINVAL,\n} CoredumpFilter;\n\n#define COREDUMP_FILTER_MASK_DEFAULT (1u << COREDUMP_FILTER_PRIVATE_ANONYMOUS | \\\n                                      1u << COREDUMP_FILTER_SHARED_ANONYMOUS | \\\n                                      1u << COREDUMP_FILTER_ELF_HEADERS | \\\n                                      1u << COREDUMP_FILTER_PRIVATE_HUGE)\n\n/* The kernel doesn't like UINT64_MAX and returns ERANGE, use UINT32_MAX to support future new flags */\n#define COREDUMP_FILTER_MASK_ALL UINT32_MAX\n\ntypedef enum SuidDumpMode {\n        SUID_DUMP_DISABLE = 0,  /* PR_SET_DUMPABLE(2const) */\n        SUID_DUMP_USER    = 1,  /* PR_SET_DUMPABLE(2const) */\n        SUID_DUMP_SAFE    = 2,  /* https://www.kernel.org/doc/html/latest/admin-guide/sysctl/fs.html#suid-dumpable */\n        _SUID_DUMP_MODE_MAX,\n} SuidDumpMode;\n\nint set_dumpable(SuidDumpMode mode);\n\nconst char* coredump_filter_to_string(CoredumpFilter i) _const_;\nCoredumpFilter coredump_filter_from_string(const char *s) _pure_;\nint coredump_filter_mask_from_string(const char *s, uint64_t *ret);\n\nint parse_auxv(int log_level,\n               uint8_t elf_class,\n               const void *auxv,\n               size_t size_bytes,\n               int *at_secure,\n               uid_t *uid,\n               uid_t *euid,\n               gid_t *gid,\n               gid_t *egid);\n\nint set_coredump_filter(uint64_t value);\nvoid disable_coredumps(void);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "26μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "57451μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "19μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "78μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "73523μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "8μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "131105μs",
      "parallelizable_steps": [],
      "critical_path_length": "73568μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.46511627906976744
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.46511627906976744,
        "content_hash": "9768807c83d9fe52"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/coredump-util.h"
      }
    },
    "source_hash": "cdbf58741cec"
  },
  {
    "instruction": "Decompose the network operation: QUIC Connection Establishment",
    "input": "Analyze the step-by-step process for: QUIC Connection Establishment",
    "output": {
      "operation": "QUIC Connection Establishment",
      "category": "quic_http3",
      "steps": [
        {
          "step": 1,
          "action": "Generate connection ID and initial keys",
          "expected_time": "695μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Send Initial packet with TLS ClientHello",
          "expected_time": "521409μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Receive and process server Initial packet",
          "expected_time": "257691μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Complete TLS handshake over QUIC",
          "expected_time": "1107μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish 1-RTT protected connection",
          "expected_time": "440091μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1220993μs",
      "parallelizable_steps": [],
      "critical_path_length": "698477μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "quic_http3",
      "complexity": "high",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "a33ba919b2c2"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-server-lease.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpserverleasehfoo\n#define foosddhcpserverleasehfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp_server_lease sd_dhcp_server_lease;\n\nsd_dhcp_server_lease *sd_dhcp_server_lease_ref(sd_dhcp_server_lease *lease);\nsd_dhcp_server_lease *sd_dhcp_server_lease_unref(sd_dhcp_server_lease *lease);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp_server_lease, sd_dhcp_server_lease_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "972μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1060628μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "3052μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2737μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "778558μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1727μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1847674μs",
      "parallelizable_steps": [],
      "critical_path_length": "1065092μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 23,
        "complexity_score": 4.3478260869565215
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 23,
        "complexity_score": 4.3478260869565215,
        "content_hash": "228ff38a1cdd496d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-server-lease.h"
      }
    },
    "source_hash": "b914ed7a2d08"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/genetlink.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef __LINUX_GENERIC_NETLINK_H\n#define __LINUX_GENERIC_NETLINK_H\n\n#include <linux/types.h>\n#include <linux/netlink.h>\n\n#define GENL_NAMSIZ\t16\t/* length of family name */\n\n#define GENL_MIN_ID\tNLMSG_MIN_TYPE\n#define GENL_MAX_ID\t1023\n\nstruct genlmsghdr {\n\t__u8\tcmd;\n\t__u8\tversion;\n\t__u16\treserved;\n};\n\n#define GENL_HDRLEN\tNLMSG_ALIGN(sizeof(struct genlmsghdr))\n\n#define GENL_ADMIN_PERM\t\t0x01\n#define GENL_CMD_CAP_DO\t\t0x02\n#define GENL_CMD_CAP_DUMP\t0x04\n#define GENL_CMD_CAP_HASPOL\t0x08\n#define GENL_UNS_ADMIN_PERM\t0x10\n\n/*\n * List of reserved static generic netlink identifiers:\n */\n#define GENL_ID_CTRL\t\tNLMSG_MIN_TYPE\n#define GENL_ID_VFS_DQUOT\t(NLMSG_MIN_TYPE + 1)\n#define GENL_ID_PMCRAID\t\t(NLMSG_MIN_TYPE + 2)\n/* must be last reserved + 1 */\n#define GENL_START_ALLOC\t(NLMSG_MIN_TYPE + 3)\n\n/**************************************************************************\n * Controller\n **************************************************************************/\n\nenum {\n\tCTRL_CMD_UNSPEC,\n\tCTRL_CMD_NEWFAMILY,\n\tCTRL_CMD_DELFAMILY,\n\tCTRL_CMD_GETFAMILY,\n\tCTRL_CMD_NEWOPS,\n\tCTRL_CMD_DELOPS,\n\tCTRL_CMD_GETOPS,\n\tCTRL_CMD_NEWMCAST_GRP,\n\tCTRL_CMD_DELMCAST_GRP,\n\tCTRL_CMD_GETMCAST_GRP, /* unused */\n\tCTRL_CMD_GETPOLICY,\n\t__CTRL_CMD_MAX,\n};\n\n#define CTRL_CMD_MAX (__CTRL_CMD_MAX - 1)\n\nenum {\n\tCTRL_ATTR_UNSPEC,\n\tCTRL_ATTR_FAMILY_ID,\n\tCTRL_ATTR_FAMILY_NAME,\n\tCTRL_ATTR_VERSION,\n\tCTRL_ATTR_HDRSIZE,\n\tCTRL_ATTR_MAXATTR,\n\tCTRL_ATTR_OPS,\n\tCTRL_ATTR_MCAST_GROUPS,\n\tCTRL_ATTR_POLICY,\n\tCTRL_ATTR_OP_POLICY,\n\tCTRL_ATTR_OP,\n\t__CTRL_ATTR_MAX,\n};\n\n#define CTRL_ATTR_MAX (__CTRL_ATTR_MAX - 1)\n\nenum {\n\tCTRL_ATTR_OP_UNSPEC,\n\tCTRL_ATTR_OP_ID,\n\tCTRL_ATTR_OP_FLAGS,\n\t__CTRL_ATTR_OP_MAX,\n};\n\n#define CTRL_ATTR_OP_MAX (__CTRL_ATTR_OP_MAX - 1)\n\nenum {\n\tCTRL_ATTR_MCAST_GRP_UNSPEC,\n\tCTRL_ATTR_MCAST_GRP_NAME,\n\tCTRL_ATTR_MCAST_GRP_ID,\n\t__CTRL_ATTR_MCAST_GRP_MAX,\n};\n\n#define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)\n\nenum {\n\tCTRL_ATTR_POLICY_UNSPEC,\n\tCTRL_ATTR_POLICY_DO,\n\tCTRL_ATTR_POLICY_DUMP,\n\n\t__CTRL_ATTR_POLICY_DUMP_MAX,\n\tCTRL_ATTR_POLICY_DUMP_MAX = __CTRL_ATTR_POLICY_DUMP_MAX - 1\n};\n\n#define CTRL_ATTR_POLICY_MAX (__CTRL_ATTR_POLICY_DUMP_MAX - 1)\n\n#endif /* __LINUX_GENERIC_NETLINK_H */\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "24μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "52μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "39870μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "63μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "66μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "40075μs",
      "parallelizable_steps": [],
      "critical_path_length": "39960μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 83,
        "complexity_score": 0.6024096385542168
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 83,
        "complexity_score": 0.6024096385542168,
        "content_hash": "cc8fbcf614fd5c99"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/genetlink.h"
      }
    },
    "source_hash": "d94e540fdad0"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-sd-hwdb.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-hwdb.h\"\n\n#include \"errno-util.h\"\n#include \"hwdb-internal.h\"\n#include \"nulstr-util.h\"\n#include \"tests.h\"\n\nTEST(failed_enumerate) {\n        _cleanup_(sd_hwdb_unrefp) sd_hwdb *hwdb = NULL;\n        const char *key, *value;\n\n        assert_se(sd_hwdb_new(&hwdb) == 0);\n\n        assert_se(sd_hwdb_seek(hwdb, \"no-such-modalias-should-exist\") == 0);\n\n        assert_se(sd_hwdb_enumerate(hwdb, &key, &value) == 0);\n        ASSERT_RETURN_EXPECTED_SE(sd_hwdb_enumerate(hwdb, &key, NULL) == -EINVAL);\n        ASSERT_RETURN_EXPECTED_SE(sd_hwdb_enumerate(hwdb, NULL, &value) == -EINVAL);\n}\n\n#define DELL_MODALIAS \\\n        \"evdev:atkbd:dmi:bvnXXX:bvrYYY:bdZZZ:svnDellXXX:pnYYY:\"\n\nTEST(basic_enumerate) {\n        _cleanup_(sd_hwdb_unrefp) sd_hwdb *hwdb = NULL;\n        const char *key, *value;\n        size_t len1 = 0, len2 = 0;\n        int r;\n\n        assert_se(sd_hwdb_new(&hwdb) == 0);\n\n        assert_se(sd_hwdb_seek(hwdb, DELL_MODALIAS) == 0);\n\n        for (;;) {\n                r = sd_hwdb_enumerate(hwdb, &key, &value);\n                assert_se(IN_SET(r, 0, 1));\n                if (r == 0)\n                        break;\n                assert_se(key);\n                assert_se(value);\n                log_debug(\"A: \\\"%s\\\" → \\\"%s\\\"\", key, value);\n                len1 += strlen(key) + strlen(value);\n        }\n\n        SD_HWDB_FOREACH_PROPERTY(hwdb, DELL_MODALIAS, key, value) {\n                log_debug(\"B: \\\"%s\\\" → \\\"%s\\\"\", key, value);\n                len2 += strlen(key) + strlen(value);\n        }\n\n        assert_se(len1 == len2);\n}\n\nTEST(sd_hwdb_new_from_path) {\n        _cleanup_(sd_hwdb_unrefp) sd_hwdb *hwdb = NULL;\n        int r;\n\n        ASSERT_RETURN_EXPECTED_SE(sd_hwdb_new_from_path(NULL, &hwdb) == -EINVAL);\n        ASSERT_RETURN_EXPECTED_SE(sd_hwdb_new_from_path(\"\", &hwdb) == -EINVAL);\n        assert_se(sd_hwdb_new_from_path(\"/path/that/should/not/exist\", &hwdb) < 0);\n\n        NULSTR_FOREACH(hwdb_bin_path, HWDB_BIN_PATHS) {\n                r = sd_hwdb_new_from_path(hwdb_bin_path, &hwdb);\n                if (r >= 0)\n                        break;\n        }\n\n        assert_se(r >= 0);\n}\n\nstatic int intro(void) {\n        _cleanup_(sd_hwdb_unrefp) sd_hwdb *hwdb = NULL;\n        int r;\n\n        r = sd_hwdb_new(&hwdb);\n        if (r == -ENOENT || ERRNO_IS_PRIVILEGE(r))\n                return log_tests_skipped_errno(r, \"cannot open hwdb\");\n\n        return EXIT_SUCCESS;\n}\n\nDEFINE_TEST_MAIN_WITH_INTRO(LOG_DEBUG, intro);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "48μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "59μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "112738μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "341μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "113239μs",
      "parallelizable_steps": [],
      "critical_path_length": "112839μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 1.2903225806451613
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 1.2903225806451613,
        "content_hash": "9f74702b890abb9c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-sd-hwdb.c"
      }
    },
    "source_hash": "72d9c3c9dec6"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/af-list.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <string.h>\n#include <sys/socket.h>\n\n#include \"af-list.h\"\n#include \"string-util.h\"\n\nstatic const struct af_name* lookup_af(register const char *str, register GPERF_LEN_TYPE len);\n\n#include \"af-from-name.inc\"\n#include \"af-to-name.inc\"\n\nconst char* af_to_name(int id) {\n\n        if (id <= 0)\n                return NULL;\n\n        if ((size_t) id >= ELEMENTSOF(af_names))\n                return NULL;\n\n        return af_names[id];\n}\n\nconst char* af_to_name_short(int id) {\n        const char *f;\n\n        if (id == AF_UNSPEC)\n                return \"*\";\n\n        f = af_to_name(id);\n        if (!f)\n                return \"unknown\";\n\n        assert(startswith(f, \"AF_\"));\n        return f + 3;\n}\n\nint af_from_name(const char *name) {\n        const struct af_name *sc;\n\n        assert(name);\n\n        sc = lookup_af(name, strlen(name));\n        if (!sc)\n                return -EINVAL;\n\n        return sc->id;\n}\n\nint af_max(void) {\n        return ELEMENTSOF(af_names);\n}\n\nconst char* af_to_ipv4_ipv6(int id) {\n        /* Pretty often we want to map the address family to the typically used protocol name for IPv4 +\n         * IPv6. Let's add special helpers for that. */\n        return id == AF_INET ? \"ipv4\" :\n                id == AF_INET6 ? \"ipv6\" : NULL;\n}\n\nint af_from_ipv4_ipv6(const char *af) {\n        return streq_ptr(af, \"ipv4\") ? AF_INET :\n                streq_ptr(af, \"ipv6\") ? AF_INET6 : AF_UNSPEC;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "373μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "97μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "38941μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "299866μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "186093μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "386848μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "185μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "912403μs",
      "parallelizable_steps": [],
      "critical_path_length": "686811μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 1.9565217391304348
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 1.9565217391304348,
        "content_hash": "e2e0fe764be9fb22"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/af-list.c"
      }
    },
    "source_hash": "20f00e848030"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/format-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"cgroup-util.h\"\n#include \"forward.h\"\n#include \"stdio-util.h\"\n\nassert_cc(sizeof(pid_t) == sizeof(int32_t));\n#define PID_PRI PRIi32\n#define PID_FMT \"%\" PID_PRI\n\nassert_cc(sizeof(uid_t) == sizeof(uint32_t));\n#define UID_FMT \"%\" PRIu32\n\nassert_cc(sizeof(gid_t) == sizeof(uint32_t));\n#define GID_FMT \"%\" PRIu32\n\n/* Note: the lifetime of the compound literal is the immediately surrounding block,\n * see C11 §6.5.2.5, and\n * https://stackoverflow.com/questions/34880638/compound-literal-lifetime-and-if-blocks */\n#define FORMAT_UID(uid) \\\n        snprintf_ok((char[DECIMAL_STR_MAX(uid_t)]){}, DECIMAL_STR_MAX(uid_t), UID_FMT, uid)\n#define FORMAT_GID(gid) \\\n        snprintf_ok((char[DECIMAL_STR_MAX(gid_t)]){}, DECIMAL_STR_MAX(gid_t), GID_FMT, gid)\n\n#if SIZEOF_TIME_T == 8\n#  define PRI_TIME PRIi64\n#elif SIZEOF_TIME_T == 4\n#  define PRI_TIME \"li\"\n#else\n#  error Unknown time_t size\n#endif\n\n#if SIZEOF_TIMEX_MEMBER == 8\n#  define PRI_TIMEX PRIi64\n#elif SIZEOF_TIMEX_MEMBER == 4\n#  define PRI_TIMEX \"li\"\n#else\n#  error Unknown timex member size\n#endif\n\n#if SIZEOF_RLIM_T == 8\n#  define RLIM_FMT \"%\" PRIu64\n#elif SIZEOF_RLIM_T == 4\n#  define RLIM_FMT \"%\" PRIu32\n#else\n#  error Unknown rlim_t size\n#endif\n\n#if SIZEOF_DEV_T == 8\n#  define DEV_FMT \"%\" PRIu64\n#elif SIZEOF_DEV_T == 4\n#  define DEV_FMT \"%\" PRIu32\n#else\n#  error Unknown dev_t size\n#endif\n\n#if SIZEOF_INO_T == 8\n#  define INO_FMT \"%\" PRIu64\n#elif SIZEOF_INO_T == 4\n#  define INO_FMT \"%\" PRIu32\n#else\n#  error Unknown ino_t size\n#endif\n\ntypedef enum {\n        FORMAT_BYTES_USE_IEC     = 1 << 0,\n        FORMAT_BYTES_BELOW_POINT = 1 << 1,\n        FORMAT_BYTES_TRAILING_B  = 1 << 2,\n} FormatBytesFlag;\n\n#define FORMAT_BYTES_MAX 16U\n\nchar* format_bytes_full(char *buf, size_t l, uint64_t t, FormatBytesFlag flag) _warn_unused_result_;\n\n_warn_unused_result_\nstatic inline char* format_bytes(char *buf, size_t l, uint64_t t) {\n        return format_bytes_full(buf, l, t, FORMAT_BYTES_USE_IEC | FORMAT_BYTES_BELOW_POINT | FORMAT_BYTES_TRAILING_B);\n}\n\n/* Note: the lifetime of the compound literal is the immediately surrounding block,\n * see C11 §6.5.2.5, and\n * https://stackoverflow.com/questions/34880638/compound-literal-lifetime-and-if-blocks */\n#define FORMAT_BYTES(t) format_bytes((char[FORMAT_BYTES_MAX]){}, FORMAT_BYTES_MAX, t)\n#define FORMAT_BYTES_FULL(t, flag) format_bytes_full((char[FORMAT_BYTES_MAX]){}, FORMAT_BYTES_MAX, t, flag)\n\n#define FORMAT_BYTES_CGROUP_PROTECTION(t) (t == CGROUP_LIMIT_MAX ? \"infinity\" : FORMAT_BYTES(t))\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "2304μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "414162μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "142μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "4861μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "738773μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1697μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1161939μs",
      "parallelizable_steps": [],
      "critical_path_length": "741219μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 71,
        "complexity_score": 6.619718309859155
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 71,
        "complexity_score": 6.619718309859155,
        "content_hash": "3bd194a888e57d7f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/format-util.h"
      }
    },
    "source_hash": "aa6b683d186a"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udev-builtin-btrfs.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <fcntl.h>\n#include <linux/btrfs.h>\n#include <sys/ioctl.h>\n\n#include \"device-util.h\"\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"string-util.h\"\n#include \"udev-builtin.h\"\n\nstatic int builtin_btrfs(UdevEvent *event, int argc, char *argv[]) {\n        sd_device *dev = ASSERT_PTR(ASSERT_PTR(event)->dev);\n        int r;\n\n        if (!IN_SET(argc, 2, 3) || !streq(argv[1], \"ready\"))\n                return log_device_error_errno(dev, SYNTHETIC_ERRNO(EINVAL), \"Invalid arguments.\");\n\n        const char *node;\n        r = sd_device_get_devname(dev, &node);\n        if (r < 0)\n                return log_device_error_errno(dev, r, \"Failed to get device node: %m\");\n\n        if (argc == 3 && !streq(argv[2], node))\n                return log_device_debug_errno(dev, SYNTHETIC_ERRNO(EINVAL), \"Device node '%s' is not owned by the device, it must be '%s'.\", argv[2], node);\n\n        if (strlen(node) >= sizeof_field(struct btrfs_ioctl_vol_args, name))\n                return log_device_debug_errno(dev, SYNTHETIC_ERRNO(EINVAL), \"Device name too long for BTRFS_IOC_DEVICES_READY call: %s\", node);\n\n        if (event->event_mode != EVENT_UDEV_WORKER) {\n                log_device_debug(dev, \"Running in test mode, skipping execution of 'btrfs' builtin command.\");\n                return 0;\n        }\n\n        _cleanup_close_ int fd = open(\"/dev/btrfs-control\", O_RDWR|O_CLOEXEC|O_NOCTTY);\n        if (fd < 0) {\n                if (ERRNO_IS_DEVICE_ABSENT_OR_EMPTY(errno)) {\n                        /* Driver not installed? Then we aren't ready. This is useful in initrds that lack\n                         * btrfs.ko. After the host transition (where btrfs.ko will hopefully become\n                         * available) the device can be retriggered and will then be considered ready. */\n                        udev_builtin_add_property(event, \"ID_BTRFS_READY\", \"0\");\n                        return 0;\n                }\n\n                return log_device_debug_errno(dev, errno, \"Failed to open %s: %m\", \"/dev/btrfs-control\");\n        }\n\n        struct btrfs_ioctl_vol_args args = {};\n        strncpy(args.name, node, sizeof(args.name)-1);\n        r = ioctl(fd, BTRFS_IOC_DEVICES_READY, &args);\n        if (r < 0)\n                return log_device_debug_errno(dev, errno, \"Failed to call BTRFS_IOC_DEVICES_READY: %m\");\n\n        udev_builtin_add_property(event, \"ID_BTRFS_READY\", one_zero(r == 0));\n        return 0;\n}\n\nconst UdevBuiltin udev_builtin_btrfs = {\n        .name = \"btrfs\",\n        .cmd = builtin_btrfs,\n        .help = \"btrfs volume management\",\n};\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "177μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "360μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "106049μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "323275μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "341902μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "51514μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "147551μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "86μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "970914μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "595502μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.0,
        "content_hash": "aeed37d21c7ea08a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udev-builtin-btrfs.c"
      }
    },
    "source_hash": "97f26d3f8def"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-cache.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\ntypedef struct DnsCache {\n        Hashmap *by_key;\n        Prioq *by_expiry;\n        unsigned n_hit;\n        unsigned n_miss;\n} DnsCache;\n\nvoid dns_cache_flush(DnsCache *c);\nvoid dns_cache_prune(DnsCache *c);\n\nint dns_cache_put(\n                DnsCache *c,\n                DnsCacheMode cache_mode,\n                DnsProtocol protocol,\n                DnsResourceKey *key,\n                int rcode,\n                DnsAnswer *answer,\n                DnsPacket *full_packet,\n                uint64_t query_flags,\n                DnssecResult dnssec_result,\n                uint32_t nsec_ttl,\n                int owner_family,\n                const union in_addr_union *owner_address,\n                usec_t stale_retention_usec);\n\nint dns_cache_lookup(\n                DnsCache *c,\n                DnsResourceKey *key,\n                uint64_t query_flags,\n                int *ret_rcode,\n                DnsAnswer **ret_answer,\n                DnsPacket **ret_full_packet,\n                uint64_t *ret_query_flags,\n                DnssecResult *ret_dnssec_result);\n\nint dns_cache_check_conflicts(DnsCache *cache, DnsResourceRecord *rr, int owner_family, const union in_addr_union *owner_address);\n\nvoid dns_cache_dump(DnsCache *cache, FILE *f);\nint dns_cache_dump_to_json(DnsCache *cache, sd_json_variant **ret);\n\nbool dns_cache_is_empty(DnsCache *cache);\n\nunsigned dns_cache_size(DnsCache *cache);\n\nint dns_cache_export_shared_to_packet(DnsCache *cache, DnsPacket *p, usec_t ts, unsigned max_rr);\n\nbool dns_cache_expiry_in_one_second(DnsCache *c, usec_t t);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "79μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "6μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "80318μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "40618μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "15μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "121089μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "80371μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805,
        "content_hash": "2115440d2cb0f1db"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-cache.h"
      }
    },
    "source_hash": "5999c06fa513"
  },
  {
    "instruction": "Analyze and break down this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "689μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "593μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "469μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "271399μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "279μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "391μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "273820μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "272383μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "b73cab1e3368"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/tc/tc.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"hashmap.h\"\n#include \"networkd-link.h\"\n#include \"networkd-network.h\"\n#include \"qdisc.h\"\n#include \"tc.h\"\n#include \"tclass.h\"\n\nint link_request_traffic_control(Link *link) {\n        TClass *tclass;\n        QDisc *qdisc;\n        int r;\n\n        assert(link);\n        assert(link->network);\n\n        link->tc_configured = false;\n\n        HASHMAP_FOREACH(qdisc, link->network->qdiscs_by_section) {\n                r = link_request_qdisc(link, qdisc);\n                if (r < 0)\n                        return log_link_warning_errno(link, r, \"Failed to request QDisc: %m\");\n        }\n\n        HASHMAP_FOREACH(tclass, link->network->tclasses_by_section) {\n                r = link_request_tclass(link, tclass);\n                if (r < 0)\n                        return log_link_warning_errno(link, r, \"Failed to request TClass: %m\");\n        }\n\n        if (link->tc_messages == 0) {\n                link->tc_configured = true;\n                link_check_ready(link);\n        } else {\n                log_link_debug(link, \"Setting traffic control\");\n                link_set_state(link, LINK_STATE_CONFIGURING);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "166μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "64μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "57917μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "390μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "105μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "58642μs",
      "parallelizable_steps": [],
      "critical_path_length": "58188μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 1.8181818181818183,
        "content_hash": "a3e5ef4210f10cc3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/tc/tc.c"
      }
    },
    "source_hash": "cb3c38790820"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-zone.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-forward.h\"\n\ntypedef struct DnsZone {\n        Hashmap *by_key;\n        Hashmap *by_name;\n} DnsZone;\n\n/* RFC 4795 Section 2.8. suggests a TTL of 30s by default */\n#define LLMNR_DEFAULT_TTL (30)\n\n/* RFC 6762 Section 10. suggests a TTL of 120s by default */\n#define MDNS_DEFAULT_TTL (120)\n\ntypedef enum DnsZoneItemState {\n        DNS_ZONE_ITEM_PROBING,\n        DNS_ZONE_ITEM_ESTABLISHED,\n        DNS_ZONE_ITEM_VERIFYING,\n        DNS_ZONE_ITEM_WITHDRAWN,\n} DnsZoneItemState;\n\ntypedef struct DnsZoneItem {\n        DnsScope *scope;\n        DnsResourceRecord *rr;\n\n        DnsZoneItemState state;\n\n        unsigned block_ready;\n\n        bool probing_enabled;\n\n        LIST_FIELDS(DnsZoneItem, by_key);\n        LIST_FIELDS(DnsZoneItem, by_name);\n\n        DnsTransaction *probe_transaction;\n} DnsZoneItem;\n\nvoid dns_zone_flush(DnsZone *z);\n\nint dns_zone_put(DnsZone *z, DnsScope *s, DnsResourceRecord *rr, bool probe);\nDnsZoneItem* dns_zone_get(DnsZone *z, DnsResourceRecord *rr);\nvoid dns_zone_remove_rr(DnsZone *z, DnsResourceRecord *rr);\nint dns_zone_remove_rrs_by_key(DnsZone *z, DnsResourceKey *key);\n\nint dns_zone_lookup(DnsZone *z, DnsResourceKey *key, int ifindex, DnsAnswer **answer, DnsAnswer **soa, bool *tentative);\n\nvoid dns_zone_item_conflict(DnsZoneItem *i);\nvoid dns_zone_item_notify(DnsZoneItem *i);\n\nint dns_zone_check_conflicts(DnsZone *zone, DnsResourceRecord *rr);\nint dns_zone_verify_conflicts(DnsZone *zone, DnsResourceKey *key);\n\nvoid dns_zone_verify_all(DnsZone *zone);\n\nvoid dns_zone_item_probe_stop(DnsZoneItem *i);\n\nvoid dns_zone_dump(DnsZone *zone, FILE *f);\nbool dns_zone_is_empty(DnsZone *zone);\nbool dns_zone_contains_name(DnsZone *z, const char *name);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "198μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "49μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "161802μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "213815μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "287μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "0μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "376151μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "213864μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.8604651162790697
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.8604651162790697,
        "content_hash": "5a6e1195fa1874c2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-zone.h"
      }
    },
    "source_hash": "f065c414e271"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/pcapng.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/*\n * For details about the file format see RFC:\n *   https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html\n *  and\n *    https://github.com/pcapng/pcapng/\n */\nenum pcapng_block_types {\n        PCAPNG_INTERFACE_BLOCK = 1,\n        PCAPNG_PACKET_BLOCK,\t\t/* Obsolete */\n        PCAPNG_SIMPLE_PACKET_BLOCK,\n        PCAPNG_NAME_RESOLUTION_BLOCK,\n        PCAPNG_INTERFACE_STATS_BLOCK,\n        PCAPNG_ENHANCED_PACKET_BLOCK,\n\n        PCAPNG_SECTION_BLOCK   = 0x0A0D0D0A,\n};\n\nstruct pcapng_option {\n        uint16_t code;\n        uint16_t length;\n        uint8_t data[];\n};\n\n#define PCAPNG_BYTE_ORDER_MAGIC 0x1A2B3C4D\n#define PCAPNG_MAJOR_VERS 1\n#define PCAPNG_MINOR_VERS 0\n\nenum pcapng_opt {\n        PCAPNG_OPT_END     = 0,\n        PCAPNG_OPT_COMMENT = 1,\n};\n\nstruct pcapng_section {\n        uint32_t block_type;\n        uint32_t block_length;\n        uint32_t byte_order_magic;\n        uint16_t major_version;\n        uint16_t minor_version;\n        uint64_t section_length;\n};\n\nenum pcapng_section_opt {\n        PCAPNG_SHB_HARDWARE = 2,\n        PCAPNG_SHB_OS       = 3,\n        PCAPNG_SHB_USERAPPL = 4,\n};\n\nstruct pcapng_interface_block {\n        uint32_t block_type;\t/* 1 */\n        uint32_t block_length;\n        uint16_t link_type;\n        uint16_t reserved;\n        uint32_t snap_len;\n};\n\nenum pcapng_interface_options {\n        PCAPNG_IFB_NAME\t = 2,\n        PCAPNG_IFB_DESCRIPTION,\n        PCAPNG_IFB_IPV4ADDR,\n        PCAPNG_IFB_IPV6ADDR,\n        PCAPNG_IFB_MACADDR,\n        PCAPNG_IFB_EUIADDR,\n        PCAPNG_IFB_SPEED,\n        PCAPNG_IFB_TSRESOL,\n        PCAPNG_IFB_TZONE,\n        PCAPNG_IFB_FILTER,\n        PCAPNG_IFB_OS,\n        PCAPNG_IFB_FCSLEN,\n        PCAPNG_IFB_TSOFFSET,\n        PCAPNG_IFB_HARDWARE,\n};\n\nstruct pcapng_enhance_packet_block {\n        uint32_t block_type;\t/* 6 */\n        uint32_t block_length;\n        uint32_t interface_id;\n        uint32_t timestamp_hi;\n        uint32_t timestamp_lo;\n        uint32_t capture_length;\n        uint32_t original_length;\n};\n\n/* Flags values */\n#define PCAPNG_IFB_INBOUND   0b01\n#define PCAPNG_IFB_OUTBOUND  0b10\n\nenum pcapng_epb_options {\n        PCAPNG_EPB_FLAGS = 2,\n        PCAPNG_EPB_HASH,\n        PCAPNG_EPB_DROPCOUNT,\n        PCAPNG_EPB_PACKETID,\n        PCAPNG_EPB_QUEUE,\n        PCAPNG_EPB_VERDICT,\n};\n\nstruct pcapng_statistics_block {\n        uint32_t block_type;\t/* 5 */\n        uint32_t block_length;\n        uint32_t interface_id;\n        uint32_t timestamp_hi;\n        uint32_t timestamp_lo;\n};\n\nenum pcapng_isb_options {\n        PCAPNG_ISB_STARTTIME = 2,\n        PCAPNG_ISB_ENDTIME,\n        PCAPNG_ISB_IFRECV,\n        PCAPNG_ISB_IFDROP,\n        PCAPNG_ISB_FILTERACCEPT,\n        PCAPNG_ISB_OSDROP,\n        PCAPNG_ISB_USRDELIV,\n};\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "447μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "823270μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "424μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1388μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "81264μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "797μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "907590μs",
      "parallelizable_steps": [],
      "critical_path_length": "825455μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 102,
        "complexity_score": 2.1568627450980395
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 102,
        "complexity_score": 2.1568627450980395,
        "content_hash": "2a468150112dc4d3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/pcapng.h"
      }
    },
    "source_hash": "0ac9d2050473"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/utf8.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n#define UTF8_REPLACEMENT_CHARACTER \"\\xef\\xbf\\xbd\"\n#define UTF8_BYTE_ORDER_MARK \"\\xef\\xbb\\xbf\"\n\nbool unichar_is_valid(char32_t c) _const_;\n\nchar* utf8_is_valid_n(const char *str, size_t len_bytes) _pure_;\nstatic inline char* utf8_is_valid(const char *str) {\n        return utf8_is_valid_n(str, SIZE_MAX);\n}\n\nchar* ascii_is_valid_n(const char *str, size_t len) _pure_;\nstatic inline char* ascii_is_valid(const char *str) {\n        return ascii_is_valid_n(str, SIZE_MAX);\n}\n\nint utf8_to_ascii(const char *str, char replacement_char, char **ret);\n\nbool utf8_is_printable_newline(const char* str, size_t length, bool allow_newline) _pure_;\n#define utf8_is_printable(str, length) utf8_is_printable_newline(str, length, true)\n\nchar* utf8_escape_invalid(const char *s);\nchar* utf8_escape_non_printable_full(const char *str, size_t console_width, bool force_ellipsis);\nstatic inline char* utf8_escape_non_printable(const char *str) {\n        return utf8_escape_non_printable_full(str, SIZE_MAX, false);\n}\n\nsize_t utf8_encode_unichar(char *out_utf8, char32_t g);\nsize_t utf16_encode_unichar(char16_t *out, char32_t c);\n\nchar* utf16_to_utf8(const char16_t *s, size_t length /* bytes! */);\nchar16_t *utf8_to_utf16(const char *s, size_t length);\n\nsize_t char16_strlen(const char16_t *s) _pure_; /* returns the number of 16-bit words in the string (not bytes!) */\nsize_t char16_strsize(const char16_t *s) _pure_;\n\nint utf8_encoded_valid_unichar(const char *str, size_t length) _pure_;\nint utf8_encoded_to_unichar(const char *str, char32_t *ret_unichar);\n\nstatic inline bool utf16_is_surrogate(char16_t c) {\n        return c >= 0xd800U && c <= 0xdfffU;\n}\n\nstatic inline bool utf16_is_trailing_surrogate(char16_t c) {\n        return c >= 0xdc00U && c <= 0xdfffU;\n}\n\nstatic inline char32_t utf16_surrogate_pair_to_unichar(char16_t lead, char16_t trail) {\n        return ((((char32_t) lead - 0xd800U) << 10) + ((char32_t) trail - 0xdc00U) + 0x10000U);\n}\n\nsize_t utf8_n_codepoints(const char *str) _pure_;\nint utf8_char_console_width(const char *str) _pure_;\nsize_t utf8_console_width(const char *str) _pure_;\n\nsize_t utf8_last_length(const char *s, size_t n) _pure_;\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "128μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "94μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "54195μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "148μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "76μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "54641μs",
      "parallelizable_steps": [],
      "critical_path_length": "54399μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.6976744186046512
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.6976744186046512,
        "content_hash": "8a0a3dd5d46e8caa"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/utf8.h"
      }
    },
    "source_hash": "90bcf256ae9f"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journalctl-varlink.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-varlink.h\"\n\nint varlink_connect_journal(sd_varlink **ret);\n\nint action_flush_to_var(void);\nint action_relinquish_var(void);\nint action_rotate(void);\nint action_vacuum(void);\nint action_rotate_and_vacuum(void);\nint action_sync(void);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "51μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "29μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "43973μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "61μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "153μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "44267μs",
      "parallelizable_steps": [],
      "critical_path_length": "44177μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 1.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 1.0,
        "content_hash": "5a225a35155516f5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journalctl-varlink.h"
      }
    },
    "source_hash": "bdbc59a67656"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: man/notify-selfcontained-example.py\n\nCode:\n#!/usr/bin/python\n# SPDX-License-Identifier: MIT-0\n#\n# Implement the systemd notify protocol without external dependencies.\n# Supports both readiness notification on startup and on reloading,\n# according to the protocol defined at:\n# https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html\n# This protocol is guaranteed to be stable as per:\n# https://systemd.io/PORTABILITY_AND_STABILITY/\n\nimport errno\nimport os\nimport signal\nimport socket\nimport sys\nimport time\n\nreloading = False\nterminating = False\n\ndef notify(message):\n    if not message:\n        raise ValueError(\"notify() requires a message\")\n\n    socket_path = os.environ.get(\"NOTIFY_SOCKET\")\n    if not socket_path:\n        return\n\n    if socket_path[0] not in (\"/\", \"@\"):\n        raise OSError(errno.EAFNOSUPPORT, \"Unsupported socket type\")\n\n    # Handle abstract socket.\n    if socket_path[0] == \"@\":\n        socket_path = \"\\0\" + socket_path[1:]\n\n    with socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM | socket.SOCK_CLOEXEC) as sock:\n        sock.connect(socket_path)\n        sock.sendall(message)\n\ndef notify_ready():\n    notify(b\"READY=1\")\n\ndef notify_reloading():\n    microsecs = time.clock_gettime_ns(time.CLOCK_MONOTONIC) // 1000\n    notify(f\"RELOADING=1\\nMONOTONIC_USEC={microsecs}\".encode())\n\ndef notify_stopping():\n    notify(b\"STOPPING=1\")\n\ndef reload(signum, frame):\n    global reloading\n    reloading = True\n\ndef terminate(signum, frame):\n    global terminating\n    terminating = True\n\ndef main():\n    print(\"Doing initial setup\")\n    global reloading, terminating\n\n    # Set up signal handlers.\n    print(\"Setting up signal handlers\")\n    signal.signal(signal.SIGHUP, reload)\n    signal.signal(signal.SIGINT, terminate)\n    signal.signal(signal.SIGTERM, terminate)\n\n    # Do any other setup work here.\n\n    # Once all setup is done, signal readiness.\n    print(\"Done setting up\")\n    notify_ready()\n\n    print(\"Starting loop\")\n    while not terminating:\n        if reloading:\n            print(\"Reloading\")\n            reloading = False\n\n            # Support notifying the manager when reloading configuration.\n            # This allows accurate state tracking as well as automatically\n            # enabling 'systemctl reload' without needing to manually\n            # specify an ExecReload= line in the unit file.\n\n            notify_reloading()\n\n            # Do some reconfiguration work here.\n\n            print(\"Done reloading\")\n            notify_ready()\n\n        # Do the real work here ...\n\n        print(\"Sleeping for five seconds\")\n        time.sleep(5)\n\n    print(\"Terminating\")\n    notify_stopping()\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(line_buffering=True)\n    print(\"Starting app\")\n    main()\n    print(\"Stopped app\")\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "228μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "364μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "2543μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "408127μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "93215μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "498700μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "124μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1003301μs",
      "parallelizable_steps": [],
      "critical_path_length": "907191μs",
      "metadata": {
        "functions_found": [
          "notify",
          "notify_ready",
          "notify_reloading",
          "notify_stopping",
          "reload",
          "terminate",
          "main"
        ],
        "classes_found": [],
        "imports": [
          "errno",
          "os",
          "signal",
          "socket",
          "sys",
          "time"
        ],
        "lines_of_code": 79,
        "complexity_score": 3.79746835443038
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "notify",
          "notify_ready",
          "notify_reloading",
          "notify_stopping",
          "reload",
          "terminate",
          "main"
        ],
        "classes": [],
        "imports": [
          "errno",
          "os",
          "signal",
          "socket",
          "sys",
          "time"
        ],
        "lines_of_code": 79,
        "complexity_score": 3.79746835443038,
        "content_hash": "c14e5dc489020b54"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "man/notify-selfcontained-example.py"
      }
    },
    "source_hash": "406eb3d3715b"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/tc/qdisc.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright © 2019 VMware, Inc. */\n#pragma once\n\n#include \"networkd-forward.h\"\n#include \"networkd-util.h\"\n\ntypedef enum QDiscKind {\n        QDISC_KIND_BFIFO,\n        QDISC_KIND_CAKE,\n        QDISC_KIND_CODEL,\n        QDISC_KIND_DRR,\n        QDISC_KIND_ETS,\n        QDISC_KIND_FQ,\n        QDISC_KIND_FQ_CODEL,\n        QDISC_KIND_FQ_PIE,\n        QDISC_KIND_GRED,\n        QDISC_KIND_HHF,\n        QDISC_KIND_HTB,\n        QDISC_KIND_MQ,\n        QDISC_KIND_MULTIQ,\n        QDISC_KIND_NETEM,\n        QDISC_KIND_PFIFO,\n        QDISC_KIND_PFIFO_FAST,\n        QDISC_KIND_PFIFO_HEAD_DROP,\n        QDISC_KIND_PIE,\n        QDISC_KIND_QFQ,\n        QDISC_KIND_SFB,\n        QDISC_KIND_SFQ,\n        QDISC_KIND_TBF,\n        QDISC_KIND_TEQL,\n        _QDISC_KIND_MAX,\n        _QDISC_KIND_INVALID = -EINVAL,\n} QDiscKind;\n\ntypedef struct QDisc {\n        Link *link;\n        Network *network;\n        ConfigSection *section;\n        NetworkConfigSource source;\n        NetworkConfigState state;\n\n        unsigned n_ref;\n\n        uint32_t handle;\n        uint32_t parent;\n\n        char *tca_kind;\n        QDiscKind kind;\n} QDisc;\n\ntypedef struct QDiscVTable {\n        size_t object_size;\n        const char *tca_kind;\n        /* called in qdisc_new() */\n        int (*init)(QDisc *qdisc);\n        int (*fill_message)(Link *link, QDisc *qdisc, sd_netlink_message *m);\n        int (*verify)(QDisc *qdisc);\n        int (*is_ready)(QDisc *qdisc, Link *link);\n} QDiscVTable;\n\nextern const QDiscVTable * const qdisc_vtable[_QDISC_KIND_MAX];\n\n#define QDISC_VTABLE(q) ((q)->kind != _QDISC_KIND_INVALID ? qdisc_vtable[(q)->kind] : NULL)\n\n/* For casting a qdisc into the various qdisc kinds */\n#define DEFINE_QDISC_CAST(UPPERCASE, MixedCase)                           \\\n        static inline MixedCase* UPPERCASE(QDisc *q) {                    \\\n                if (_unlikely_(!q || q->kind != QDISC_KIND_##UPPERCASE))  \\\n                        return NULL;                                      \\\n                                                                          \\\n                return (MixedCase*) q;                                    \\\n        }\n\nDEFINE_NETWORK_CONFIG_STATE_FUNCTIONS(QDisc, qdisc);\n\nQDisc* qdisc_ref(QDisc *qdisc);\nQDisc* qdisc_unref(QDisc *qdisc);\nint qdisc_new_static(QDiscKind kind, Network *network, const char *filename, unsigned section_line, QDisc **ret);\n\nvoid qdisc_mark_recursive(QDisc *qdisc);\nvoid link_qdisc_drop_marked(Link *link);\n\nint link_find_qdisc(Link *link, uint32_t handle, const char *kind, QDisc **qdisc);\n\nint link_request_qdisc(Link *link, const QDisc *qdisc);\n\nvoid network_drop_invalid_qdisc(Network *network);\n\nint manager_rtnl_process_qdisc(sd_netlink *rtnl, sd_netlink_message *message, Manager *m);\n\nDEFINE_SECTION_CLEANUP_FUNCTIONS(QDisc, qdisc_unref);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_qdisc_parent);\nCONFIG_PARSER_PROTOTYPE(config_parse_qdisc_handle);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "230μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "15μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "41617μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "210μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "228μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "42300μs",
      "parallelizable_steps": [],
      "critical_path_length": "42075μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 76,
        "complexity_score": 1.1842105263157894
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 76,
        "complexity_score": 1.1842105263157894,
        "content_hash": "f1733613df9dce72"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/tc/qdisc.h"
      }
    },
    "source_hash": "bd0ae6dcb4ab"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netfilter/nf_nat.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _NETFILTER_NF_NAT_H\n#define _NETFILTER_NF_NAT_H\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_conntrack_tuple_common.h>\n\n#define NF_NAT_RANGE_MAP_IPS\t\t\t(1 << 0)\n#define NF_NAT_RANGE_PROTO_SPECIFIED\t\t(1 << 1)\n#define NF_NAT_RANGE_PROTO_RANDOM\t\t(1 << 2)\n#define NF_NAT_RANGE_PERSISTENT\t\t\t(1 << 3)\n#define NF_NAT_RANGE_PROTO_RANDOM_FULLY\t\t(1 << 4)\n#define NF_NAT_RANGE_PROTO_OFFSET\t\t(1 << 5)\n#define NF_NAT_RANGE_NETMAP\t\t\t(1 << 6)\n\n#define NF_NAT_RANGE_PROTO_RANDOM_ALL\t\t\\\n\t(NF_NAT_RANGE_PROTO_RANDOM | NF_NAT_RANGE_PROTO_RANDOM_FULLY)\n\n#define NF_NAT_RANGE_MASK\t\t\t\t\t\\\n\t(NF_NAT_RANGE_MAP_IPS | NF_NAT_RANGE_PROTO_SPECIFIED |\t\\\n\t NF_NAT_RANGE_PROTO_RANDOM | NF_NAT_RANGE_PERSISTENT |\t\\\n\t NF_NAT_RANGE_PROTO_RANDOM_FULLY | NF_NAT_RANGE_PROTO_OFFSET | \\\n\t NF_NAT_RANGE_NETMAP)\n\nstruct nf_nat_ipv4_range {\n\tunsigned int\t\t\tflags;\n\t__be32\t\t\t\tmin_ip;\n\t__be32\t\t\t\tmax_ip;\n\tunion nf_conntrack_man_proto\tmin;\n\tunion nf_conntrack_man_proto\tmax;\n};\n\nstruct nf_nat_ipv4_multi_range_compat {\n\tunsigned int\t\t\trangesize;\n\tstruct nf_nat_ipv4_range\trange[1];\n};\n\nstruct nf_nat_range {\n\tunsigned int\t\t\tflags;\n\tunion nf_inet_addr\t\tmin_addr;\n\tunion nf_inet_addr\t\tmax_addr;\n\tunion nf_conntrack_man_proto\tmin_proto;\n\tunion nf_conntrack_man_proto\tmax_proto;\n};\n\nstruct nf_nat_range2 {\n\tunsigned int\t\t\tflags;\n\tunion nf_inet_addr\t\tmin_addr;\n\tunion nf_inet_addr\t\tmax_addr;\n\tunion nf_conntrack_man_proto\tmin_proto;\n\tunion nf_conntrack_man_proto\tmax_proto;\n\tunion nf_conntrack_man_proto\tbase_proto;\n};\n\n#endif /* _NETFILTER_NF_NAT_H */\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "113μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "173μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "50757μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "353μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "164μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "51560μs",
      "parallelizable_steps": [],
      "critical_path_length": "51034μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 1.3043478260869565
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 1.3043478260869565,
        "content_hash": "bbe0932d10f8eb9e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netfilter/nf_nat.h"
      }
    },
    "source_hash": "3bc6107558e3"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-execve.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"exec-util.h\"\n#include \"fd-util.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"strv.h\"\n#include \"tests.h\"\n\n/* This program can be used to call programs through fexecve / execveat(…, \"\", …, AT_EMPTY_PATH),\n * when compiled with -Dfexecve=true, and the fallback paths, when -Dfexecve=false.\n *\n * Example:\n * $ strace -e execveat build/test-execve /bin/grep Name /proc/self/status\n * execveat(3, \"\", [\"/bin/grep\", \"Name\", \"/proc/self/status\"], NULL, AT_EMPTY_PATH) = 0\n * Name:   3\n *\n * FIXME: use the new kernel api to set COMM properly when the kernel makes that available.\n * C.f. ceedbf8185fc7593366679f02d31da63af8c4bd1.\n */\n\nstatic int run(int argc, char **argv) {\n        int r;\n\n        test_setup_logging(LOG_DEBUG);\n\n        char **args = strv_skip(argv, 1) ?: STRV_MAKE(\"/bin/true\");\n\n        _cleanup_close_ int fd = open(args[0], O_RDONLY | O_CLOEXEC);\n        if (fd < 0)\n                return log_error_errno(errno, \"open(%s) failed: %m\", args[0]);\n\n        r = fexecve_or_execve(fd, args[0], args, NULL);\n        assert_se(r < 0);\n        return log_error_errno(r, \"fexecve_or_execve(%s) failed: %m\", args[0]);\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "94μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "160μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "28165μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "202μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "146μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "28767μs",
      "parallelizable_steps": [],
      "critical_path_length": "28405μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 1.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 1.0,
        "content_hash": "0f4fe083bd8fb896"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-execve.c"
      }
    },
    "source_hash": "0a91a848ae93"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/bareudp.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright © 2020 VMware, Inc. */\n#pragma once\n\n#include \"forward.h\"\n#include \"netdev.h\"\n\ntypedef enum BareUDPProtocol {\n        BARE_UDP_PROTOCOL_IPV4    = ETH_P_IP,\n        BARE_UDP_PROTOCOL_IPV6    = ETH_P_IPV6,\n        BARE_UDP_PROTOCOL_MPLS_UC = ETH_P_MPLS_UC,\n        BARE_UDP_PROTOCOL_MPLS_MC = ETH_P_MPLS_MC,\n        _BARE_UDP_PROTOCOL_MAX,\n        _BARE_UDP_PROTOCOL_INVALID = -EINVAL,\n} BareUDPProtocol;\n\ntypedef struct BareUDP {\n        NetDev meta;\n\n        BareUDPProtocol iftype;\n        uint16_t dest_port;\n        uint16_t min_port;\n} BareUDP;\n\nDEFINE_NETDEV_CAST(BAREUDP, BareUDP);\nextern const NetDevVTable bare_udp_vtable;\n\nconst char* bare_udp_protocol_to_string(BareUDPProtocol d) _const_;\nBareUDPProtocol bare_udp_protocol_from_string(const char *d) _pure_;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_bare_udp_iftype);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "114μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "121μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "129985μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "76μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "87μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "130383μs",
      "parallelizable_steps": [],
      "critical_path_length": "130186μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 24,
        "complexity_score": 1.6666666666666665
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 24,
        "complexity_score": 1.6666666666666665,
        "content_hash": "1ff60f801ef0ecda"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/bareudp.h"
      }
    },
    "source_hash": "01b7e4930aeb"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp6-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n/***\n  Copyright © 2014-2015 Intel Corporation. All rights reserved.\n***/\n\n#include <net/ethernet.h>\n#include <netinet/in.h>\n\n#include \"sd-dhcp6-client.h\"\n\n#include \"dhcp-duid-internal.h\"\n#include \"dhcp6-option.h\"\n#include \"dhcp6-protocol.h\"\n#include \"forward.h\"\n#include \"network-common.h\"\n#include \"sparse-endian.h\"\n\n/* what to request from the server, addresses (IA_NA) and/or prefixes (IA_PD) */\ntypedef enum DHCP6RequestIA {\n        DHCP6_REQUEST_IA_NA = 1 << 0,\n        DHCP6_REQUEST_IA_TA = 1 << 1, /* currently not used */\n        DHCP6_REQUEST_IA_PD = 1 << 2,\n} DHCP6RequestIA;\n\nstruct sd_dhcp6_client {\n        unsigned n_ref;\n\n        int ifindex;\n        char *ifname;\n\n        struct in6_addr local_address;\n        struct hw_addr_data hw_addr;\n        uint16_t arp_type;\n\n        sd_event *event;\n        sd_event_source *receive_message;\n        sd_event_source *timeout_resend;\n        sd_event_source *timeout_expire;\n        sd_event_source *timeout_t1;\n        sd_event_source *timeout_t2;\n        int event_priority;\n        int fd;\n\n        sd_device *dev;\n\n        DHCP6State state;\n        bool information_request;\n        usec_t information_request_time_usec;\n        usec_t information_refresh_time_usec;\n        be32_t transaction_id;\n        usec_t transaction_start;\n        usec_t retransmit_time;\n        uint8_t retransmit_count;\n\n        bool iaid_set;\n        DHCP6IA ia_na;\n        DHCP6IA ia_pd;\n        DHCP6RequestIA request_ia;\n        sd_dhcp_duid duid;\n        be16_t *req_opts;\n        size_t n_req_opts;\n        char *fqdn;\n        char *mudurl;\n        char **user_class;\n        char **vendor_class;\n        OrderedHashmap *extra_options;\n        OrderedSet *vendor_options;\n        bool rapid_commit;\n\n        struct sd_dhcp6_lease *lease;\n\n        sd_dhcp6_client_callback_t callback;\n        void *userdata;\n        sd_dhcp6_client_callback_t state_callback;\n        void *state_userdata;\n        bool send_release;\n};\n\nint dhcp6_network_bind_udp_socket(int ifindex, const struct in6_addr *address);\nint dhcp6_network_send_udp_socket(int s, const struct in6_addr *address, const void *packet, size_t len);\n\nint dhcp6_client_send_message(sd_dhcp6_client *client);\nint dhcp6_client_set_transaction_id(sd_dhcp6_client *client, uint32_t transaction_id);\n\n#define log_dhcp6_client_errno(client, error, fmt, ...)         \\\n        log_interface_prefix_full_errno(                        \\\n                \"DHCPv6 client: \",                              \\\n                sd_dhcp6_client, client,                        \\\n                error, fmt, ##__VA_ARGS__)\n#define log_dhcp6_client(client, fmt, ...)                      \\\n        log_interface_prefix_full_errno_zerook(                 \\\n                \"DHCPv6 client: \",                              \\\n                sd_dhcp6_client, client,                        \\\n                0, fmt, ##__VA_ARGS__)\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "184μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "50874μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "358μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "27μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "51496μs",
      "parallelizable_steps": [],
      "critical_path_length": "50954μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 79,
        "complexity_score": 1.0126582278481013
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 79,
        "complexity_score": 1.0126582278481013,
        "content_hash": "b3d816bc7cf9881b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp6-internal.h"
      }
    },
    "source_hash": "9b8edbd4d535"
  },
  {
    "instruction": "Analyze and decompose this grpc code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/fib_rules.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef __LINUX_FIB_RULES_H\n#define __LINUX_FIB_RULES_H\n\n#include <linux/types.h>\n#include <linux/rtnetlink.h>\n\n/* rule is permanent, and cannot be deleted */\n#define FIB_RULE_PERMANENT\t0x00000001\n#define FIB_RULE_INVERT\t\t0x00000002\n#define FIB_RULE_UNRESOLVED\t0x00000004\n#define FIB_RULE_IIF_DETACHED\t0x00000008\n#define FIB_RULE_DEV_DETACHED\tFIB_RULE_IIF_DETACHED\n#define FIB_RULE_OIF_DETACHED\t0x00000010\n\n/* try to find source address in routing lookups */\n#define FIB_RULE_FIND_SADDR\t0x00010000\n\nstruct fib_rule_hdr {\n\t__u8\t\tfamily;\n\t__u8\t\tdst_len;\n\t__u8\t\tsrc_len;\n\t__u8\t\ttos;\n\n\t__u8\t\ttable;\n\t__u8\t\tres1;   /* reserved */\n\t__u8\t\tres2;\t/* reserved */\n\t__u8\t\taction;\n\n\t__u32\t\tflags;\n};\n\nstruct fib_rule_uid_range {\n\t__u32\t\tstart;\n\t__u32\t\tend;\n};\n\nstruct fib_rule_port_range {\n\t__u16\t\tstart;\n\t__u16\t\tend;\n};\n\nenum {\n\tFRA_UNSPEC,\n\tFRA_DST,\t/* destination address */\n\tFRA_SRC,\t/* source address */\n\tFRA_IIFNAME,\t/* interface name */\n#define FRA_IFNAME\tFRA_IIFNAME\n\tFRA_GOTO,\t/* target to jump to (FR_ACT_GOTO) */\n\tFRA_UNUSED2,\n\tFRA_PRIORITY,\t/* priority/preference */\n\tFRA_UNUSED3,\n\tFRA_UNUSED4,\n\tFRA_UNUSED5,\n\tFRA_FWMARK,\t/* mark */\n\tFRA_FLOW,\t/* flow/class id */\n\tFRA_TUN_ID,\n\tFRA_SUPPRESS_IFGROUP,\n\tFRA_SUPPRESS_PREFIXLEN,\n\tFRA_TABLE,\t/* Extended table id */\n\tFRA_FWMASK,\t/* mask for netfilter mark */\n\tFRA_OIFNAME,\n\tFRA_PAD,\n\tFRA_L3MDEV,\t/* iif or oif is l3mdev goto its table */\n\tFRA_UID_RANGE,\t/* UID range */\n\tFRA_PROTOCOL,   /* Originator of the rule */\n\tFRA_IP_PROTO,\t/* ip proto */\n\tFRA_SPORT_RANGE, /* sport */\n\tFRA_DPORT_RANGE, /* dport */\n\tFRA_DSCP,\t/* dscp */\n\tFRA_FLOWLABEL,\t/* flowlabel */\n\tFRA_FLOWLABEL_MASK,\t/* flowlabel mask */\n\tFRA_SPORT_MASK,\t/* sport mask */\n\tFRA_DPORT_MASK,\t/* dport mask */\n\tFRA_DSCP_MASK,\t/* dscp mask */\n\t__FRA_MAX\n};\n\n#define FRA_MAX (__FRA_MAX - 1)\n\nenum {\n\tFR_ACT_UNSPEC,\n\tFR_ACT_TO_TBL,\t\t/* Pass to fixed table */\n\tFR_ACT_GOTO,\t\t/* Jump to another rule */\n\tFR_ACT_NOP,\t\t/* No operation */\n\tFR_ACT_RES3,\n\tFR_ACT_RES4,\n\tFR_ACT_BLACKHOLE,\t/* Drop without notification */\n\tFR_ACT_UNREACHABLE,\t/* Drop with ENETUNREACH */\n\tFR_ACT_PROHIBIT,\t/* Drop with EACCES */\n\t__FR_ACT_MAX,\n};\n\n#define FR_ACT_MAX (__FR_ACT_MAX - 1)\n\n#endif\n",
    "output": {
      "operation": "Grpc Implementation",
      "category": "grpc",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "275μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "243μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "232325μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "267μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "91μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "233201μs",
      "parallelizable_steps": [],
      "critical_path_length": "232691μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 83,
        "complexity_score": 2.4096385542168672
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "grpc",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 83,
        "complexity_score": 2.4096385542168672,
        "content_hash": "45bd2189c7215aff"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/fib_rules.h"
      }
    },
    "source_hash": "9e4c2321a4ee"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/tpm2-pcr.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n/* The various TPM PCRs we measure into from sd-stub and sd-boot. */\n\nenum {\n        /* The following names for PCRs 0…7 are based on the names in the \"TCG PC Client Specific Platform\n         * Firmware Profile Specification\"\n         * (https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/) */\n        TPM2_PCR_PLATFORM_CODE       = 0,\n        TPM2_PCR_PLATFORM_CONFIG     = 1,\n        TPM2_PCR_EXTERNAL_CODE       = 2,\n        TPM2_PCR_EXTERNAL_CONFIG     = 3,\n        TPM2_PCR_BOOT_LOADER_CODE    = 4,\n        TPM2_PCR_BOOT_LOADER_CONFIG  = 5,\n        TPM2_PCR_HOST_PLATFORM       = 6,\n        TPM2_PCR_SECURE_BOOT_POLICY  = 7,\n\n        /* The following names for PCRs 9…15 are based on the \"Linux TPM PCR Registry\"\n        (https://uapi-group.org/specifications/specs/linux_tpm_pcr_registry/) */\n        TPM2_PCR_KERNEL_INITRD       = 9,\n        TPM2_PCR_IMA                 = 10,\n\n        /* systemd: This TPM PCR is where we extend the sd-stub \"payloads\" into, before using them. i.e. the kernel\n         * ELF image, embedded initrd, and so on. In contrast to PCR 4 (which also contains this data, given\n         * the whole surrounding PE image is measured into it) this should be reasonably pre-calculatable,\n         * because it *only* consists of static data from the kernel PE image. */\n        TPM2_PCR_KERNEL_BOOT         = 11,\n\n        /* systemd: This TPM PCR is where sd-stub extends the kernel command line and any passed credentials into. */\n        TPM2_PCR_KERNEL_CONFIG       = 12,\n\n        /* systemd: This TPM PCR is where we extend the initrd sysext images into which we pass to the booted kernel */\n        TPM2_PCR_SYSEXTS             = 13,\n        TPM2_PCR_SHIM_POLICY         = 14,\n\n        /* systemd: This TPM PCR is where we measure the root fs volume key (and maybe /var/'s) if it is split off */\n        TPM2_PCR_SYSTEM_IDENTITY     = 15,\n\n        /* As per \"TCG PC Client Specific Platform Firmware Profile Specification\" again, see above */\n        TPM2_PCR_DEBUG               = 16,\n        TPM2_PCR_APPLICATION_SUPPORT = 23,\n};\n\n/* The tag used for EV_EVENT_TAG event log records covering the boot loader config */\n#define LOADER_CONF_EVENT_TAG_ID UINT32_C(0xf5bc582a)\n\n/* The tag used for EV_EVENT_TAG event log records covering DeviceTree blobs */\n#define DEVICETREE_ADDON_EVENT_TAG_ID UINT32_C(0x6c46f751)\n\n/* The tag used for EV_EVENT_TAG event log records covering initrd addons */\n#define INITRD_ADDON_EVENT_TAG_ID UINT32_C(0x49dffe0f)\n\n/* The tag used for EV_EVENT_TAG event log records covering ucode addons (effectively initrds) */\n#define UCODE_ADDON_EVENT_TAG_ID UINT32_C(0xdac08e1a)\n\n/* The tag used for EV_EVENT_TAG event log records covering the selected UKI profile */\n#define UKI_PROFILE_EVENT_TAG_ID UINT32_C(0x13aed6db)\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "460μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "1062μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "10532μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "428μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "21μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "12503μs",
      "parallelizable_steps": [],
      "critical_path_length": "11013μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 5.555555555555555
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 5.555555555555555,
        "content_hash": "b4dafcd4a9245132"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/tpm2-pcr.h"
      }
    },
    "source_hash": "0decbb723728"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udev-error.c\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0-or-later */\n\n#include \"device-monitor-private.h\"\n#include \"device-private.h\"\n#include \"device-util.h\"\n#include \"errno-list.h\"\n#include \"errno-util.h\"\n#include \"signal-util.h\"\n#include \"udev-error.h\"\n\nint device_add_errno(sd_device *dev, int error) {\n        int r;\n\n        assert(dev);\n\n        if (error == 0)\n                return 0;\n\n        error = ABS(error);\n\n        r = device_add_property(dev, \"UDEV_WORKER_FAILED\", \"1\");\n        RET_GATHER(r, device_add_propertyf(dev, \"UDEV_WORKER_ERRNO\", \"%i\", error));\n\n        const char *str = errno_name_no_fallback(error);\n        if (str)\n                RET_GATHER(r, device_add_property(dev, \"UDEV_WORKER_ERRNO_NAME\", str));\n\n        return r;\n}\n\nint device_add_exit_status(sd_device *dev, int status) {\n        int r;\n\n        assert(dev);\n\n        if (status == 0)\n                return 0;\n\n        r = device_add_property(dev, \"UDEV_WORKER_FAILED\", \"1\");\n        return RET_GATHER(r, device_add_propertyf(dev, \"UDEV_WORKER_EXIT_STATUS\", \"%i\", status));\n}\n\nint device_add_signal(sd_device *dev, int signo) {\n        int r;\n\n        assert(dev);\n\n        r = device_add_property(dev, \"UDEV_WORKER_FAILED\", \"1\");\n        RET_GATHER(r, device_add_propertyf(dev, \"UDEV_WORKER_SIGNAL\", \"%i\", signo));\n\n        const char *str = signal_to_string(signo);\n        if (str)\n                RET_GATHER(r, device_add_property(dev, \"UDEV_WORKER_SIGNAL_NAME\", str));\n\n        return r;\n}\n\nint device_broadcast_on_error(sd_device *dev, sd_device_monitor *monitor) {\n        int r;\n\n        assert(dev);\n        assert(monitor);\n\n        /* delete state from disk */\n        (void) device_delete_db(dev);\n        (void) device_tag_index(dev, /* device_old = */ NULL, /* add = */ false);\n\n        r = device_monitor_send(monitor, /* destination = */ NULL, dev);\n        if (r < 0) {\n                uint64_t seqnum = 0;\n\n                (void) sd_device_get_seqnum(dev, &seqnum);\n                return log_device_warning_errno(dev, r, \"Failed to broadcast event (SEQNUM=%\"PRIu64\") to libudev listeners: %m\", seqnum);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "8μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "111μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "103482μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "161966μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "70134μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "193543μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "72649μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "12μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "601905μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "355632μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 1.1111111111111112
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 1.1111111111111112,
        "content_hash": "ba94e0349079144f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udev-error.c"
      }
    },
    "source_hash": "c71ee98cb39e"
  },
  {
    "instruction": "Decompose the network operation: QUIC Connection Establishment",
    "input": "Analyze the step-by-step process for: QUIC Connection Establishment",
    "output": {
      "operation": "QUIC Connection Establishment",
      "category": "quic_http3",
      "steps": [
        {
          "step": 1,
          "action": "Generate connection ID and initial keys",
          "expected_time": "695μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Send Initial packet with TLS ClientHello",
          "expected_time": "521409μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Receive and process server Initial packet",
          "expected_time": "257691μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Complete TLS handshake over QUIC",
          "expected_time": "1107μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish 1-RTT protected connection",
          "expected_time": "440091μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1220993μs",
      "parallelizable_steps": [],
      "critical_path_length": "698477μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "quic_http3",
      "complexity": "high",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "a33ba919b2c2"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/bpf/socket-bind/socket-bind-api.bpf.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n/* The SPDX header above is actually correct in claiming this was\n * LGPL-2.1-or-later, because it is. Since the kernel doesn't consider that\n * compatible with GPL we will claim this to be GPL however, which should be\n * fine given that LGPL-2.1-or-later downgrades to GPL if needed.\n */\n\n#include <linux/types.h>\n#include <stdint.h>\n\n/*\n * Bind rule is matched with socket fields accessible to cgroup/bind{4,6} hook\n * through bpf_sock_addr struct.\n * 'address_family' is expected to be one of AF_UNSPEC, AF_INET, AF_INET6 or the\n * magic SOCKET_BIND_RULE_AF_MATCH_NOTHING.\n * Matching by family is bypassed for rules with AF_UNSPEC set, which makes the\n * rest of a rule applicable for both IPv4 and IPv6 addresses.\n * If SOCKET_BIND_RULE_AF_MATCH_NOTHING is set the rule fails unconditionally\n * and other checks are skipped.\n * If matching by family is either successful or bypassed, a rule and a socket\n * are matched by ip protocol.\n * If 'protocol' is 0, matching is bypassed.\n * 'nr_ports' and 'port_min' fields specify a set of ports to match a user port\n * with.\n * If 'nr_ports' is 0, matching by port is bypassed, making that rule applicable\n * for all possible ports, e.g. [1, 65535] range. Thus a rule with\n * 'address_family', 'protocol' and 'nr_ports' equal to AF_UNSPEC, 0 and 0\n * correspondingly forms 'allow any' or 'deny any' cases.\n * For positive 'nr_ports', a user_port lying in a range from 'port_min' to'\n * 'port_min' + 'nr_ports' exclusively is considered to be a match. 'nr_ports'\n * equalling to 1 forms a rule for a single port.\n * Ports are in host order.\n *\n * Examples:\n * AF_UNSPEC, 1, 0, 7777: match IPv4 and IPv6 addresses with 7777 user port;\n *\n * AF_INET, 1023, 0, 1: match IPv4 addresses with user port in [1, 1023]\n * range inclusively;\n *\n * AF_INET6, 0, 0, 0: match IPv6 addresses;\n *\n * AF_UNSPEC, 0, 0, 0: match IPv4 and IPv6 addresses;\n *\n * AF_INET6, IPPROTO_TCP, 0, 0: match IPv6/TCP addresses.\n */\n\nstruct socket_bind_rule {\n        __u32 address_family;\n        __u32 protocol;\n        __u16 nr_ports;\n        __u16 port_min;\n};\n\n#define SOCKET_BIND_MAX_RULES 128\n#define SOCKET_BIND_RULE_AF_MATCH_NOTHING UINT32_MAX\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "302μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "21μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "587379μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "571683μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "317257μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "213196μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "26μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1689864μs",
      "parallelizable_steps": [],
      "critical_path_length": "904964μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 4.117647058823529
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 4.117647058823529,
        "content_hash": "e6716bf5d1797ab5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/bpf/socket-bind/socket-bind-api.bpf.h"
      }
    },
    "source_hash": "69c2e3751a51"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"main-func.h\"\n#include \"tests.h\"\n\nstatic int test_ref_unref(void) {\n        sd_bus_message *m = NULL;\n        sd_bus *bus = NULL;\n        int r;\n\n        /* This test will result in a memory leak in <= v240, but not on v241. Hence to be really useful it\n         * should be run through a leak tracker such as valgrind. */\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                return log_tests_skipped(\"Failed to connect to bus\");\n\n        /* Create a message and enqueue it (this shouldn't send it though as the connection setup is not complete yet) */\n        assert_se(sd_bus_message_new_method_call(bus, &m, \"foo.bar\", \"/foo\", \"quux.quux\", \"waldo\") >= 0);\n        assert_se(sd_bus_send(bus, m, NULL) >= 0);\n\n        /* Let's now unref the message first and the bus second. */\n        m = sd_bus_message_unref(m);\n        bus = sd_bus_unref(bus);\n\n        /* We should have a memory leak now on <= v240. Let's do this again, but destroy in the opposite\n         * order. On v240 that too should be a leak. */\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                return log_tests_skipped(\"Failed to connect to bus\");\n\n        assert_se(sd_bus_message_new_method_call(bus, &m, \"foo.bar\", \"/foo\", \"quux.quux\", \"waldo\") >= 0);\n        assert_se(sd_bus_send(bus, m, NULL) >= 0);\n\n        /* Let's now unref things in the opposite order */\n        bus = sd_bus_unref(bus);\n        m = sd_bus_message_unref(m);\n\n        return 0;\n}\n\nstatic int run(int argc, char *argv[]) {\n        int r;\n\n        test_setup_logging(LOG_INFO);\n\n        r = test_ref_unref();\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "88μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "39072μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "87613μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "55244μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "163955μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "177μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "346184μs",
      "parallelizable_steps": [],
      "critical_path_length": "251656μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 1.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 1.0,
        "content_hash": "4f245af99e7b24bb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c"
      }
    },
    "source_hash": "8d8e310b16ee"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/glob-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <dirent.h>\n#include <sys/stat.h>\n\n#include \"dirent-util.h\"\n#include \"errno-util.h\"\n#include \"glob-util.h\"\n#include \"string-util.h\"\n#include \"strv.h\"\n\nDEFINE_TRIVIAL_DESTRUCTOR(closedir_wrapper, void, closedir);\n\nint safe_glob_full(const char *path, int flags, opendir_t opendir_func, char ***ret) {\n        _cleanup_(globfree) glob_t g = {\n                .gl_closedir = closedir_wrapper,\n                .gl_readdir = (struct dirent* (*)(void *)) readdir_no_dot,\n                .gl_opendir = (void* (*)(const char *)) (opendir_func ?: opendir),\n                .gl_lstat = lstat,\n                .gl_stat = stat,\n        };\n        int r;\n\n        assert(path);\n\n        errno = 0;\n        r = glob(path, flags | GLOB_ALTDIRFUNC, NULL, &g);\n        if (r == GLOB_NOMATCH)\n                return -ENOENT;\n        if (r == GLOB_NOSPACE)\n                return -ENOMEM;\n        if (r != 0)\n                return errno_or_else(EIO);\n\n        if (strv_isempty(g.gl_pathv))\n                return -ENOENT;\n\n        if (ret) {\n                *ret = g.gl_pathv;\n                TAKE_STRUCT(g); /* To avoid the result being freed. */\n        }\n\n        return 0;\n}\n\nint glob_first(const char *path, char **ret) {\n        _cleanup_strv_free_ char **v = NULL;\n        int r;\n\n        assert(path);\n\n        r = safe_glob(path, GLOB_NOSORT|GLOB_BRACE, &v);\n        if (r == -ENOENT) {\n                if (ret)\n                        *ret = NULL;\n                return false;\n        }\n        if (r < 0)\n                return r;\n\n        assert(!strv_isempty(v));\n\n        if (ret) {\n                /* Free all results except for the first one. */\n                STRV_FOREACH(p, strv_skip(v, 1))\n                        *p = mfree(*p);\n\n                /* Then, take the first result. */\n                *ret = TAKE_PTR(*v);\n        }\n\n        return true;\n}\n\nint glob_extend(char ***strv, const char *path, int flags) {\n        char **v;\n        int r;\n\n        assert(path);\n\n        r = safe_glob(path, GLOB_NOSORT|GLOB_BRACE|flags, &v);\n        if (r < 0)\n                return r;\n\n        return strv_extend_strv_consume(strv, v, /* filter_duplicates = */ false);\n}\n\nint glob_non_glob_prefix(const char *path, char **ret) {\n        /* Return the path of the path that has no glob characters. */\n\n        size_t n = strcspn(path, GLOB_CHARS);\n\n        if (path[n] != '\\0')\n                while (n > 0 && path[n-1] != '/')\n                        n--;\n\n        if (n == 0)\n                return -ENOENT;\n\n        char *ans = strndup(path, n);\n        if (!ans)\n                return -ENOMEM;\n        *ret = ans;\n        return 0;\n}\n\nbool string_is_glob(const char *p) {\n        /* Check if a string contains any glob patterns. */\n        return !!strpbrk(p, GLOB_CHARS);\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "73μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "383μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "119291μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "772μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "109μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "120628μs",
      "parallelizable_steps": [],
      "critical_path_length": "119473μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 84,
        "complexity_score": 2.261904761904762
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 84,
        "complexity_score": 2.261904761904762,
        "content_hash": "98bc5fc15d5e4d8a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/glob-util.c"
      }
    },
    "source_hash": "faa36a1bb16c"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dhcp4-bus.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n#include \"sd-dhcp-client.h\"\n\n#include \"alloc-util.h\"\n#include \"bus-object.h\"\n#include \"dhcp-client-internal.h\"\n#include \"networkd-dhcp4-bus.h\"\n#include \"networkd-link-bus.h\"\n#include \"networkd-link.h\"\n#include \"networkd-manager.h\"\n\nstatic int property_get_dhcp_client_state(\n                sd_bus *bus,\n                const char *path,\n                const char *interface,\n                const char *property,\n                sd_bus_message *reply,\n                void *userdata,\n                sd_bus_error *error) {\n\n        Link *l = ASSERT_PTR(userdata);\n        sd_dhcp_client *c;\n\n        assert(reply);\n\n        c = l->dhcp_client;\n        if (!c)\n                return sd_bus_message_append(reply, \"s\", \"disabled\");\n\n        return sd_bus_message_append(reply, \"s\", dhcp_state_to_string(dhcp_client_get_state(c)));\n}\n\nstatic int dhcp_client_emit_changed(Link *link, char **properties) {\n        _cleanup_free_ char *path = NULL;\n\n        assert(link);\n\n        if (sd_bus_is_ready(link->manager->bus) <= 0)\n                return 0;\n\n        path = link_bus_path(link);\n        if (!path)\n                return log_oom();\n\n        return sd_bus_emit_properties_changed_strv(\n                        link->manager->bus,\n                        path,\n                        \"org.freedesktop.network1.DHCPv4Client\",\n                        properties);\n}\n\nint dhcp_client_callback_bus(sd_dhcp_client *c, int event, void *userdata) {\n        Link *l = ASSERT_PTR(userdata);\n\n        return dhcp_client_emit_changed(l, STRV_MAKE(\"State\"));\n}\n\nstatic const sd_bus_vtable dhcp_client_vtable[] = {\n        SD_BUS_VTABLE_START(0),\n\n        SD_BUS_PROPERTY(\"State\", \"s\", property_get_dhcp_client_state, 0, SD_BUS_VTABLE_PROPERTY_EMITS_CHANGE),\n\n        SD_BUS_VTABLE_END\n};\n\nconst BusObjectImplementation dhcp_client_object = {\n        \"/org/freedesktop/network1/link\",\n        \"org.freedesktop.network1.DHCPv4Client\",\n        .fallback_vtables = BUS_FALLBACK_VTABLES({dhcp_client_vtable, link_object_find}),\n        .node_enumerator = link_node_enumerator,\n};\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "7μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "120μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "18646μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "214μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "28μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "19015μs",
      "parallelizable_steps": [],
      "critical_path_length": "18681μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 0.7272727272727273
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 0.7272727272727273,
        "content_hash": "a85596de9c12887a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dhcp4-bus.c"
      }
    },
    "source_hash": "5c2e655ed92b"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/netdev-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\ntypedef enum NetDevLocalAddressType {\n        NETDEV_LOCAL_ADDRESS_IPV4LL,\n        NETDEV_LOCAL_ADDRESS_IPV6LL,\n        NETDEV_LOCAL_ADDRESS_DHCP4,\n        NETDEV_LOCAL_ADDRESS_DHCP6,\n        NETDEV_LOCAL_ADDRESS_SLAAC,\n        NETDEV_LOCAL_ADDRESS_DHCP_PD,\n        _NETDEV_LOCAL_ADDRESS_TYPE_MAX,\n        _NETDEV_LOCAL_ADDRESS_TYPE_INVALID = -EINVAL,\n} NetDevLocalAddressType;\n\nconst char* netdev_local_address_type_to_string(NetDevLocalAddressType t) _const_;\nNetDevLocalAddressType netdev_local_address_type_from_string(const char *s) _pure_;\n\nint link_get_local_address(\n                Link *link,\n                NetDevLocalAddressType type,\n                int family,\n                int *ret_family,\n                union in_addr_union *ret_address);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "111μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "59μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "27646μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "95μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "6μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "27917μs",
      "parallelizable_steps": [],
      "critical_path_length": "27763μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 0.9523809523809523
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 0.9523809523809523,
        "content_hash": "685cd9f14be3f6d0"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/netdev-util.h"
      }
    },
    "source_hash": "c36b3486110d"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-stub.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"in-addr-util.h\"\n#include \"resolved-forward.h\"\n\ntypedef enum DnsStubListenerMode {\n        DNS_STUB_LISTENER_NO,\n        DNS_STUB_LISTENER_UDP = 1 << 0,\n        DNS_STUB_LISTENER_TCP = 1 << 1,\n        DNS_STUB_LISTENER_YES = DNS_STUB_LISTENER_UDP | DNS_STUB_LISTENER_TCP,\n        _DNS_STUB_LISTENER_MODE_MAX,\n        _DNS_STUB_LISTENER_MODE_INVALID = -EINVAL,\n} DnsStubListenerMode;\n\ntypedef struct DnsStubListenerExtra {\n        Manager *manager;\n\n        DnsStubListenerMode mode;\n\n        int family;\n        union in_addr_union address;\n        uint16_t port;\n\n        sd_event_source *udp_event_source;\n        sd_event_source *tcp_event_source;\n\n        Hashmap *queries_by_packet;\n} DnsStubListenerExtra;\n\nextern const struct hash_ops dns_stub_listener_extra_hash_ops;\n\nint dns_stub_listener_extra_new(Manager *m, DnsStubListenerExtra **ret);\nDnsStubListenerExtra *dns_stub_listener_extra_free(DnsStubListenerExtra *p);\nstatic inline uint16_t dns_stub_listener_extra_port(DnsStubListenerExtra *p) {\n        assert(p);\n\n        return p->port > 0 ? p->port : 53;\n}\n\nvoid manager_dns_stub_stop(Manager *m);\nint manager_dns_stub_start(Manager *m);\n\nconst char* dns_stub_listener_mode_to_string(DnsStubListenerMode p) _const_;\nDnsStubListenerMode dns_stub_listener_mode_from_string(const char *s) _pure_;\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "27μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "10μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "110516μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "37446μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "20μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "148072μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "110569μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061,
        "content_hash": "279355c8749b5268"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-stub.h"
      }
    },
    "source_hash": "4d4a341898e4"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/dbus_exporter.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\nimport os\nfrom argparse import ArgumentParser\nfrom pathlib import Path\nfrom subprocess import PIPE, run\n\n\ndef extract_interfaces_xml(output_dir, executable):\n    # If proc is not mounted, set LD_ORIGIN_PATH so that shared/core libs can be found,\n    # as glibc looks at /proc/self/exe when resolving RPATH\n    env = os.environ.copy()\n    if not os.path.exists('/proc/self'):\n        env[\"LD_ORIGIN_PATH\"] = executable.parent.as_posix()\n\n    proc = run(\n        args=[executable.absolute(), '--bus-introspect', 'list'],\n        stdout=PIPE,\n        env=env,\n        check=True,\n        universal_newlines=True)\n\n    interface_names = (x.split()[1] for x in proc.stdout.splitlines())\n\n    for interface_name in interface_names:\n        proc = run(\n            args=[executable.absolute(), '--bus-introspect', interface_name],\n            stdout=PIPE,\n            env=env,\n            check=True,\n            universal_newlines=True)\n\n        interface_file_name = output_dir / (interface_name + '.xml')\n        interface_file_name.write_text(proc.stdout)\n        interface_file_name.chmod(0o644)\n\ndef main():\n    parser = ArgumentParser()\n    parser.add_argument('output',\n                        type=Path)\n    parser.add_argument('executables',\n                        nargs='+',\n                        type=Path)\n\n    args = parser.parse_args()\n\n    args.output.mkdir(exist_ok=True)\n    # Make sure we don't inherit any setgid/setuid bit or such.\n    args.output.chmod(mode=0o755)\n    for exe in args.executables:\n        extract_interfaces_xml(args.output, exe)\n\nif __name__ == '__main__':\n    main()\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "22μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "187μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "71327μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "305μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "216μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "72057μs",
      "parallelizable_steps": [],
      "critical_path_length": "71565μs",
      "metadata": {
        "functions_found": [
          "extract_interfaces_xml",
          "main"
        ],
        "classes_found": [],
        "imports": [
          "os",
          "argparse",
          "pathlib",
          "subprocess"
        ],
        "lines_of_code": 44,
        "complexity_score": 1.5909090909090908
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [
          "extract_interfaces_xml",
          "main"
        ],
        "classes": [],
        "imports": [
          "os",
          "argparse",
          "pathlib",
          "subprocess"
        ],
        "lines_of_code": 44,
        "complexity_score": 1.5909090909090908,
        "content_hash": "06bd411b2e1c8907"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/dbus_exporter.py"
      }
    },
    "source_hash": "d5a41bb1b4b5"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/replace-var.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"replace-var.h\"\n#include \"string-util.h\"\n\n/*\n * Generic infrastructure for replacing @FOO@ style variables in\n * strings. Will call a callback for each replacement.\n */\n\nstatic int get_variable(const char *b, char **r) {\n        size_t k;\n        char *t;\n\n        assert(b);\n        assert(r);\n\n        if (*b != '@')\n                return 0;\n\n        k = strspn(b + 1, UPPERCASE_LETTERS \"_\");\n        if (k <= 0 || b[k+1] != '@')\n                return 0;\n\n        t = strndup(b + 1, k);\n        if (!t)\n                return -ENOMEM;\n\n        *r = t;\n        return 1;\n}\n\nchar* replace_var(const char *text, char *(*lookup)(const char *variable, void *userdata), void *userdata) {\n        char *r, *t;\n        const char *f;\n        size_t l;\n\n        assert(text);\n        assert(lookup);\n\n        l = strlen(text);\n        r = new(char, l+1);\n        if (!r)\n                return NULL;\n\n        f = text;\n        t = r;\n        while (*f) {\n                _cleanup_free_ char *v = NULL, *n = NULL;\n                char *a;\n                int k;\n                size_t skip, d, nl;\n\n                k = get_variable(f, &v);\n                if (k < 0)\n                        goto oom;\n                if (k == 0) {\n                        *(t++) = *(f++);\n                        continue;\n                }\n\n                n = lookup(v, userdata);\n                if (!n)\n                        goto oom;\n\n                skip = strlen(v) + 2;\n\n                d = t - r;\n                nl = l - skip + strlen(n);\n                a = realloc(r, nl + 1);\n                if (!a)\n                        goto oom;\n\n                l = nl;\n                r = a;\n                t = r + d;\n\n                t = stpcpy(t, n);\n                f += skip;\n        }\n\n        *t = 0;\n        return r;\n\noom:\n        return mfree(r);\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "194μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "80μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "174513μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "396μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "175μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "175358μs",
      "parallelizable_steps": [],
      "critical_path_length": "174882μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 68,
        "complexity_score": 1.7647058823529413
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 68,
        "complexity_score": 1.7647058823529413,
        "content_hash": "68c8d795203505d3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/replace-var.c"
      }
    },
    "source_hash": "fadbd75c47a4"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/socket.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _LINUX_SOCKET_H\n#define _LINUX_SOCKET_H\n\n/*\n * Desired design of maximum size and alignment (see RFC2553)\n */\n#define _K_SS_MAXSIZE\t128\t/* Implementation specific max size */\n\ntypedef unsigned short __kernel_sa_family_t;\n\n/*\n * The definition uses anonymous union and struct in order to control the\n * default alignment.\n */\nstruct __kernel_sockaddr_storage {\n\tunion {\n\t\tstruct {\n\t\t\t__kernel_sa_family_t\tss_family; /* address family */\n\t\t\t/* Following field(s) are implementation specific */\n\t\t\tchar __data[_K_SS_MAXSIZE - sizeof(unsigned short)];\n\t\t\t\t/* space to achieve desired size, */\n\t\t\t\t/* _SS_MAXSIZE value minus size of ss_family */\n\t\t};\n\t\tvoid *__align; /* implementation specific desired alignment */\n\t};\n};\n\n#define SOCK_SNDBUF_LOCK\t1\n#define SOCK_RCVBUF_LOCK\t2\n\n#define SOCK_BUF_LOCK_MASK (SOCK_SNDBUF_LOCK | SOCK_RCVBUF_LOCK)\n\n#define SOCK_TXREHASH_DEFAULT\t255\n#define SOCK_TXREHASH_DISABLED\t0\n#define SOCK_TXREHASH_ENABLED\t1\n\n#endif /* _LINUX_SOCKET_H */\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "183μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "278μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "120455μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "836μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "182μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "121934μs",
      "parallelizable_steps": [],
      "critical_path_length": "120820μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 2.258064516129032
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 2.258064516129032,
        "content_hash": "f4331fd201269894"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/socket.h"
      }
    },
    "source_hash": "cb0fd2841005"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/machine/machine-dbus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"machine-forward.h\"\n\ntypedef enum {\n        MACHINE_COPY_REPLACE = 1 << 0, /* Public API via DBUS, do not change */\n        _MACHINE_COPY_FLAGS_MASK_PUBLIC = MACHINE_COPY_REPLACE,\n} MachineCopyFlags;\n\nextern const BusObjectImplementation machine_object;\n\nchar* machine_bus_path(Machine *s);\n\nint bus_machine_method_unregister(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_terminate(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_kill(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_get_addresses(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_get_ssh_info(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_get_os_release(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_open_pty(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_open_login(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_open_shell(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_bind_mount(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_copy(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_open_root_directory(sd_bus_message *message, void *userdata, sd_bus_error *error);\nint bus_machine_method_get_uid_shift(sd_bus_message *message, void *userdata, sd_bus_error *error);\n\nint machine_send_signal(Machine *m, bool new_machine);\nint machine_send_create_reply(Machine *m, sd_bus_error *error);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "188μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "17μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "51901μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "12μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "2μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "52120μs",
      "parallelizable_steps": [],
      "critical_path_length": "52091μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 24,
        "complexity_score": 1.25
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 24,
        "complexity_score": 1.25,
        "content_hash": "869ca6fae12e11f2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/machine/machine-dbus.h"
      }
    },
    "source_hash": "abdd2ab7a958"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/filesystems.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"stat-util.h\"\n\n#define FILESYSTEM_MAGIC_MAX 10\n\ntypedef enum FilesystemGroups {\n        /* Please leave BASIC_API first and KNOWN last, but sort the rest alphabetically */\n        FILESYSTEM_SET_BASIC_API,\n        FILESYSTEM_SET_ANONYMOUS,\n        FILESYSTEM_SET_APPLICATION,\n        FILESYSTEM_SET_AUXILIARY_API,\n        FILESYSTEM_SET_COMMON_BLOCK,\n        FILESYSTEM_SET_HISTORICAL_BLOCK,\n        FILESYSTEM_SET_NETWORK,\n        FILESYSTEM_SET_PRIVILEGED_API,\n        FILESYSTEM_SET_SECURITY,\n        FILESYSTEM_SET_TEMPORARY,\n        FILESYSTEM_SET_KNOWN,\n        _FILESYSTEM_SET_MAX,\n        _FILESYSTEM_SET_INVALID = -EINVAL,\n} FilesystemGroups;\n\ntypedef struct FilesystemSet {\n        const char *name;\n        const char *help;\n        const char *value;\n} FilesystemSet;\n\nextern const FilesystemSet filesystem_sets[];\n\nconst FilesystemSet *filesystem_set_find(const char *name);\n\nconst char* fs_type_to_string(statfs_f_type_t magic);\nint fs_type_from_string(const char *name, const statfs_f_type_t **ret);\nbool fs_in_group(const struct statfs *s, enum FilesystemGroups fs_group);\n\n/* gperf prototypes */\nconst struct FilesystemMagic* filesystems_gperf_lookup(const char *key, GPERF_LEN_TYPE length);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "119μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "2μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "8549μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "95μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "13μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "8778μs",
      "parallelizable_steps": [],
      "critical_path_length": "8681μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061,
        "content_hash": "0acbf1074eaa1b78"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/filesystems.h"
      }
    },
    "source_hash": "cc3a64b08f5c"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dns.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n#include \"networkd-util.h\"\n\ntypedef enum UseDomains {\n        USE_DOMAINS_NO,\n        USE_DOMAINS_YES,\n        USE_DOMAINS_ROUTE,\n        _USE_DOMAINS_MAX,\n        _USE_DOMAINS_INVALID = -EINVAL,\n} UseDomains;\n\nUseDomains link_get_use_domains(Link *link, NetworkConfigSource proto);\nbool link_get_use_dns(Link *link, NetworkConfigSource proto);\nbool link_get_use_dnr(Link *link, NetworkConfigSource proto);\n\nconst char* use_domains_to_string(UseDomains p) _const_;\nUseDomains use_domains_from_string(const char *s) _pure_;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_domains);\nCONFIG_PARSER_PROTOTYPE(config_parse_dns);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssec_negative_trust_anchors);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_use_dns);\nCONFIG_PARSER_PROTOTYPE(config_parse_use_domains);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "54μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "35μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "87215μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "185363μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "12μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "9μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "272688μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "185407μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 0.9523809523809523
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 0.9523809523809523,
        "content_hash": "bb5178522f96a20d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dns.h"
      }
    },
    "source_hash": "cc053696e8fa"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-route-nexthop.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"in-addr-util.h\"\n#include \"networkd-forward.h\"\n\ntypedef struct RouteNextHop {\n        int family; /* used in RTA_VIA (IPv4 only) */\n        union in_addr_union gw; /* RTA_GATEWAY or RTA_VIA (IPv4 only) */\n        uint32_t weight; /* rtnh_hops */\n        int ifindex; /* RTA_OIF(u32) or rtnh_ifindex */\n        char *ifname; /* only used by Route object owned by Network object */\n        /* unsupported attributes: RTA_FLOW (IPv4 only), RTA_ENCAP_TYPE, RTA_ENCAP. */\n} RouteNextHop;\n\n#define ROUTE_NEXTHOP_NULL ((const RouteNextHop) {})\n\nvoid route_detach_from_nexthop(Route *route);\nvoid route_attach_to_nexthop(Route *route);\n\nRouteNextHop* route_nexthop_free(RouteNextHop *nh);\nDEFINE_TRIVIAL_CLEANUP_FUNC(RouteNextHop*, route_nexthop_free);\n\nvoid route_nexthops_done(Route *route);\n\nvoid route_nexthops_hash_func(const Route *route, struct siphash *state);\nint route_nexthops_compare_func(const Route *a, const Route *b);\n\nint route_nexthops_copy(const Route *src, const RouteNextHop *nh, Route *dest);\nbool route_nexthops_needs_adjust(const Route *route);\nint route_adjust_nexthops(Route *route, Link *link);\n\nint route_nexthop_get_link(Manager *manager, const RouteNextHop *nh, Link **ret);\nint route_nexthops_is_ready_to_configure(const Route *route, Manager *manager);\n\nint route_nexthops_to_string(const Route *route, char **ret);\n\nint route_nexthops_set_netlink_message(const Route *route, sd_netlink_message *message);\nint route_nexthops_read_netlink_message(Route *route, sd_netlink_message *message);\n\nint route_section_verify_nexthops(Route *route);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_gateway);\nCONFIG_PARSER_PROTOTYPE(config_parse_route_nexthop);\nCONFIG_PARSER_PROTOTYPE(config_parse_multipath_route);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "310μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "235μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "89557μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "80μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "318μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "90500μs",
      "parallelizable_steps": [],
      "critical_path_length": "90185μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 2.1875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 2.1875,
        "content_hash": "a2b142af4af7ce1c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-route-nexthop.h"
      }
    },
    "source_hash": "b21e089442a6"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udev-builtin-net_driver.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"device-private.h\"\n#include \"device-util.h\"\n#include \"errno-util.h\"\n#include \"ethtool-util.h\"\n#include \"fd-util.h\"\n#include \"udev-builtin.h\"\n\nstatic int builtin_net_driver_set_driver(UdevEvent *event, int argc, char **argv) {\n        sd_device *dev = ASSERT_PTR(ASSERT_PTR(event)->dev);\n        _cleanup_close_ int ethtool_fd = -EBADF;\n        _cleanup_free_ char *driver = NULL;\n        const char *ifname;\n        int r;\n\n        r = device_get_ifname(dev, &ifname);\n        if (r < 0)\n                return log_device_warning_errno(dev, r, \"Failed to get network interface name: %m\");\n\n        r = ethtool_get_driver(&ethtool_fd, ifname, &driver);\n        if (ERRNO_IS_NEG_NOT_SUPPORTED(r)) {\n                log_device_debug_errno(dev, r, \"Querying driver name via ethtool API is not supported by device '%s', ignoring: %m\", ifname);\n                return 0;\n        }\n        if (r == -ENODEV) {\n                log_device_debug_errno(dev, r, \"Device already vanished, ignoring.\");\n                return 0;\n        }\n        if (r < 0)\n                return log_device_warning_errno(dev, r, \"Failed to get driver for '%s': %m\", ifname);\n\n        return udev_builtin_add_property(event, \"ID_NET_DRIVER\", driver);\n}\n\nconst UdevBuiltin udev_builtin_net_driver = {\n        .name = \"net_driver\",\n        .cmd = builtin_net_driver_set_driver,\n        .help = \"Set driver for network device\",\n        .run_once = true,\n};\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "134μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "448μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "585486μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "353556μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "36023μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "221506μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "136176μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "493μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1333822μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "757685μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.611111111111111
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.611111111111111,
        "content_hash": "6bc7c7fcf63a4ab5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udev-builtin-net_driver.c"
      }
    },
    "source_hash": "fe710895fbdd"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/tc/sfq.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright © 2019 VMware, Inc. */\n\n#include <linux/pkt_sched.h>\n#include \"sd-netlink.h\"\n\n#include \"log.h\"\n#include \"qdisc.h\"\n#include \"sfq.h\"\n#include \"string-util.h\"\n\nstatic int stochastic_fairness_queueing_fill_message(Link *link, QDisc *qdisc, sd_netlink_message *req) {\n        StochasticFairnessQueueing *sfq;\n        int r;\n\n        assert(link);\n        assert(qdisc);\n        assert(req);\n\n        assert_se(sfq = SFQ(qdisc));\n\n        const struct tc_sfq_qopt_v1 opt = {\n                .v0.perturb_period = sfq->perturb_period / USEC_PER_SEC,\n        };\n\n        r = sd_netlink_message_append_data(req, TCA_OPTIONS, &opt, sizeof(opt));\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nint config_parse_stochastic_fairness_queueing_perturb_period(\n                const char *unit,\n                const char *filename,\n                unsigned line,\n                const char *section,\n                unsigned section_line,\n                const char *lvalue,\n                int ltype,\n                const char *rvalue,\n                void *data,\n                void *userdata) {\n\n        _cleanup_(qdisc_unref_or_set_invalidp) QDisc *qdisc = NULL;\n        StochasticFairnessQueueing *sfq;\n        Network *network = ASSERT_PTR(data);\n        int r;\n\n        assert(filename);\n        assert(lvalue);\n        assert(rvalue);\n\n        r = qdisc_new_static(QDISC_KIND_SFQ, network, filename, section_line, &qdisc);\n        if (r == -ENOMEM)\n                return log_oom();\n        if (r < 0) {\n                log_syntax(unit, LOG_WARNING, filename, line, r,\n                           \"More than one kind of queueing discipline, ignoring assignment: %m\");\n                return 0;\n        }\n\n        sfq = SFQ(qdisc);\n\n        if (isempty(rvalue)) {\n                sfq->perturb_period = 0;\n\n                TAKE_PTR(qdisc);\n                return 0;\n        }\n\n        r = parse_sec(rvalue, &sfq->perturb_period);\n        if (r < 0) {\n                log_syntax(unit, LOG_WARNING, filename, line, r,\n                           \"Failed to parse '%s=', ignoring assignment: %s\",\n                           lvalue, rvalue);\n                return 0;\n        }\n\n        TAKE_PTR(qdisc);\n\n        return 0;\n}\n\nconst QDiscVTable sfq_vtable = {\n        .object_size = sizeof(StochasticFairnessQueueing),\n        .tca_kind = \"sfq\",\n        .fill_message = stochastic_fairness_queueing_fill_message,\n};\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "64μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "37μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "2024μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "312μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "5μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2442μs",
      "parallelizable_steps": [],
      "critical_path_length": "2093μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 70,
        "complexity_score": 0.8571428571428572
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 70,
        "complexity_score": 0.8571428571428572,
        "content_hash": "e989e1d740cd0e40"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/tc/sfq.c"
      }
    },
    "source_hash": "2479706581ce"
  },
  {
    "instruction": "Analyze and decompose this tcp_udp code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/icmp6-test-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/uio.h>\n#include <unistd.h>\n\n#include \"fd-util.h\"\n#include \"icmp6-test-util.h\"\n#include \"icmp6-util.h\"\n#include \"time-util.h\"\n\nint test_fd[2] = EBADF_PAIR;\n\nstatic struct in6_addr dummy_link_local = {\n        .s6_addr = {\n                0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                0x12, 0x34, 0x56, 0xff, 0xfe, 0x78, 0x9a, 0xbc,\n        },\n};\n\nint icmp6_bind(int ifindex, bool is_router) {\n        if (!is_router && socketpair(AF_UNIX, SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0, test_fd) < 0)\n                return -errno;\n\n        return test_fd[is_router];\n}\n\nint icmp6_send(int fd, const struct in6_addr *dst, const struct iovec *iov, size_t n_iov) {\n        return writev(fd, iov, n_iov);\n}\n\nint icmp6_receive(\n                int fd,\n                void *iov_base,\n                size_t iov_len,\n                struct in6_addr *ret_sender,\n                triple_timestamp *ret_timestamp) {\n\n        assert_se(read (fd, iov_base, iov_len) == (ssize_t) iov_len);\n\n        if (ret_timestamp)\n                triple_timestamp_now(ret_timestamp);\n\n        if (ret_sender)\n                *ret_sender = dummy_link_local;\n\n        return 0;\n}\n",
    "output": {
      "operation": "Tcp Udp Implementation",
      "category": "tcp_udp",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "258μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "18μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "112942μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "249μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "236μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "113703μs",
      "parallelizable_steps": [],
      "critical_path_length": "113436μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 1.4285714285714284
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "tcp_udp",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 1.4285714285714284,
        "content_hash": "4471b314cf314b70"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/icmp6-test-util.c"
      }
    },
    "source_hash": "3c6e7936cf36"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/mempolicy.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n/*\n * NUMA memory policies for Linux.\n * Copyright 2003,2004 Andi Kleen SuSE Labs\n */\n#ifndef _LINUX_MEMPOLICY_H\n#define _LINUX_MEMPOLICY_H\n\n#include <linux/errno.h>\n\n\n/*\n * Both the MPOL_* mempolicy mode and the MPOL_F_* optional mode flags are\n * passed by the user to either set_mempolicy() or mbind() in an 'int' actual.\n * The MPOL_MODE_FLAGS macro determines the legal set of optional mode flags.\n */\n\n/* Policies */\nenum {\n\tMPOL_DEFAULT,\n\tMPOL_PREFERRED,\n\tMPOL_BIND,\n\tMPOL_INTERLEAVE,\n\tMPOL_LOCAL,\n\tMPOL_PREFERRED_MANY,\n\tMPOL_WEIGHTED_INTERLEAVE,\n\tMPOL_MAX,\t/* always last member of enum */\n};\n\n/* Flags for set_mempolicy */\n#define MPOL_F_STATIC_NODES\t(1 << 15)\n#define MPOL_F_RELATIVE_NODES\t(1 << 14)\n#define MPOL_F_NUMA_BALANCING\t(1 << 13) /* Optimize with NUMA balancing if possible */\n\n/*\n * MPOL_MODE_FLAGS is the union of all possible optional mode flags passed to\n * either set_mempolicy() or mbind().\n */\n#define MPOL_MODE_FLAGS\t\t\t\t\t\t\t\\\n\t(MPOL_F_STATIC_NODES | MPOL_F_RELATIVE_NODES | MPOL_F_NUMA_BALANCING)\n\n/* Flags for get_mempolicy */\n#define MPOL_F_NODE\t(1<<0)\t/* return next IL mode instead of node mask */\n#define MPOL_F_ADDR\t(1<<1)\t/* look up vma using address */\n#define MPOL_F_MEMS_ALLOWED (1<<2) /* return allowed memories */\n\n/* Flags for mbind */\n#define MPOL_MF_STRICT\t(1<<0)\t/* Verify existing pages in the mapping */\n#define MPOL_MF_MOVE\t (1<<1)\t/* Move pages owned by this process to conform\n\t\t\t\t   to policy */\n#define MPOL_MF_MOVE_ALL (1<<2)\t/* Move every page to conform to policy */\n#define MPOL_MF_LAZY\t (1<<3)\t/* UNSUPPORTED FLAG: Lazy migrate on fault */\n#define MPOL_MF_INTERNAL (1<<4)\t/* Internal flags start here */\n\n#define MPOL_MF_VALID\t(MPOL_MF_STRICT   | \t\\\n\t\t\t MPOL_MF_MOVE     | \t\\\n\t\t\t MPOL_MF_MOVE_ALL)\n\n/*\n * Internal flags that share the struct mempolicy flags word with\n * \"mode flags\".  These flags are allocated from bit 0 up, as they\n * are never OR'ed into the mode in mempolicy API arguments.\n */\n#define MPOL_F_SHARED  (1 << 0)\t/* identify shared policies */\n#define MPOL_F_MOF\t(1 << 3) /* this policy wants migrate on fault */\n#define MPOL_F_MORON\t(1 << 4) /* Migrate On protnone Reference On Node */\n\n/*\n * These bit locations are exposed in the vm.zone_reclaim_mode sysctl\n * ABI.  New bits are OK, but existing bits can never change.\n */\n#define RECLAIM_ZONE\t(1<<0)\t/* Run shrink_inactive_list on the zone */\n#define RECLAIM_WRITE\t(1<<1)\t/* Writeout pages during reclaim */\n#define RECLAIM_UNMAP\t(1<<2)\t/* Unmap pages during reclaim */\n\n#endif /* _LINUX_MEMPOLICY_H */\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "456μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "30μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "190068μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "232μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "113μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "190899μs",
      "parallelizable_steps": [],
      "critical_path_length": "190637μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 64,
        "complexity_score": 2.34375
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 64,
        "complexity_score": 2.34375,
        "content_hash": "0eb9b6084cd0f3fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/mempolicy.h"
      }
    },
    "source_hash": "bc016d4236ef"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/daemon-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-daemon.h\" /* IWYU pragma: export */\n\n#include \"forward.h\"\n\n#define NOTIFY_READY_MESSAGE \"READY=1\\n\" \"STATUS=Processing requests...\"\n#define NOTIFY_STOPPING_MESSAGE \"STOPPING=1\\n\" \"STATUS=Shutting down...\"\n\nstatic inline const char* notify_start(const char *start, const char *stop) {\n        if (start)\n                (void) sd_notify(false, start);\n\n        return stop;\n}\n\n/* This is intended to be used with _cleanup_ attribute. */\nstatic inline void notify_on_cleanup(const char **p) {\n        if (*p)\n                (void) sd_notify(false, *p);\n}\n\nint notify_remove_fd_warn(const char *name);\nint notify_remove_fd_warnf(const char *format, ...) _printf_(1, 2);\nint close_and_notify_warn(int fd, const char *name);\nint notify_push_fd(int fd, const char *name);\nint notify_push_fdf(int fd, const char *format, ...) _printf_(2, 3);\n\nint notify_reloading_full(const char *status);\nstatic inline int notify_reloading(void) {\n        return notify_reloading_full(\"Reloading configuration...\");\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "984μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "1610μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "943694μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "1538925μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "191356μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "1214309μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "329741μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "232μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "4220851μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "2755076μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 8.4
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 8.4,
        "content_hash": "23a893eda50791c7"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/daemon-util.h"
      }
    },
    "source_hash": "390e7e99a340"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libudev/libudev-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"libudev.h\"\n\n#include \"forward.h\"\n#include \"device-nodes.h\"\n\n/**\n * SECTION:libudev-util\n * @short_description: utils\n *\n * Utilities useful when dealing with devices and device node names.\n */\n\n/**\n * udev_util_encode_string:\n * @str: input string to be encoded\n * @str_enc: output string to store the encoded input string\n * @len: maximum size of the output string, which may be\n *       four times as long as the input string\n *\n * Encode all potentially unsafe characters of a string to the\n * corresponding 2 char hex value prefixed by '\\x'.\n *\n * Returns: 0 if the entire string was copied, non-zero otherwise.\n **/\n_public_ int udev_util_encode_string(const char *str, char *str_enc, size_t len) {\n        return encode_devnode_name(str, str_enc, len);\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "93μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "237μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "157664μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "231μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "116μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "158341μs",
      "parallelizable_steps": [],
      "critical_path_length": "157873μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 1.6
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 1.6,
        "content_hash": "098f96bb9b5092a1"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libudev/libudev-util.c"
      }
    },
    "source_hash": "19603456e5d1"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/xfrm.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <linux/if_arp.h>\n\n#include \"sd-netlink.h\"\n\n#include \"missing-network.h\"\n#include \"networkd-link.h\"\n#include \"xfrm.h\"\n\nstatic int xfrm_fill_message_create(NetDev *netdev, Link *link, sd_netlink_message *message) {\n        assert(message);\n\n        Xfrm *x = XFRM(netdev);\n        int r;\n\n        assert(link || x->independent);\n\n        r = sd_netlink_message_append_u32(message, IFLA_XFRM_LINK, link ? link->ifindex : LOOPBACK_IFINDEX);\n        if (r < 0)\n                return r;\n\n        r = sd_netlink_message_append_u32(message, IFLA_XFRM_IF_ID, x->if_id);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nstatic int xfrm_verify(NetDev *netdev, const char *filename) {\n        assert(filename);\n\n        Xfrm *x = XFRM(netdev);\n\n        if (x->if_id == 0)\n                return log_netdev_warning_errno(netdev, SYNTHETIC_ERRNO(EINVAL),\n                                                \"%s: Xfrm interface ID cannot be zero.\", filename);\n        return 0;\n}\n\nconst NetDevVTable xfrm_vtable = {\n        .object_size = sizeof(Xfrm),\n        .sections = NETDEV_COMMON_SECTIONS \"Xfrm\\0\",\n        .fill_message_create = xfrm_fill_message_create,\n        .config_verify = xfrm_verify,\n        .create_type = NETDEV_CREATE_STACKED,\n        .iftype = ARPHRD_NONE,\n};\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "474μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "182μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "345370μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "324μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "371μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "346721μs",
      "parallelizable_steps": [],
      "critical_path_length": "346215μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 4.571428571428571
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 4.571428571428571,
        "content_hash": "b6d8f8ff0f785d28"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/xfrm.c"
      }
    },
    "source_hash": "0cf1d0d13191"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/test-network-tables.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <net/if.h>\n\n#include \"sd-dhcp-lease.h\"\n\n#include \"bond-util.h\"\n#include \"dhcp6-protocol.h\"\n#include \"ethtool-util.h\"\n#include \"ipvlan-util.h\"\n#include \"lldp-rx-internal.h\"\n#include \"macvlan-util.h\"\n#include \"ndisc-internal.h\"\n#include \"networkd-dns.h\"\n#include \"networkd-lldp-rx.h\"\n#include \"networkd-radv.h\"\n#include \"networkd-sysctl.h\"\n#include \"test-tables.h\"\n#include \"tests.h\"\n#include \"tunnel.h\"\n\nint main(int argc, char **argv) {\n        test_setup_logging(LOG_DEBUG);\n\n        test_table(BondAdSelect, bond_ad_select, NETDEV_BOND_AD_SELECT);\n        test_table(BondArpAllTargets, bond_arp_all_targets, NETDEV_BOND_ARP_ALL_TARGETS);\n        test_table(BondArpValidate, bond_arp_validate, NETDEV_BOND_ARP_VALIDATE);\n        test_table(BondFailOverMac, bond_fail_over_mac, NETDEV_BOND_FAIL_OVER_MAC);\n        test_table(BondLacpRate, bond_lacp_rate, NETDEV_BOND_LACP_RATE);\n        test_table(BondMode, bond_mode, NETDEV_BOND_MODE);\n        test_table(BondPrimaryReselect, bond_primary_reselect, NETDEV_BOND_PRIMARY_RESELECT);\n        test_table(BondXmitHashPolicy, bond_xmit_hash_policy, NETDEV_BOND_XMIT_HASH_POLICY);\n        test_table(DHCP6Status, dhcp6_message_status, DHCP6_STATUS);\n        test_table_sparse(DHCP6MessageType, dhcp6_message_type, DHCP6_MESSAGE_TYPE); /* enum starts from 1 */\n        test_table(UseDomains, use_domains, USE_DOMAINS);\n        test_table(Duplex, duplex, DUP);\n        test_table(TunnelMode, tunnel_mode, TUNNEL_MODE);\n        test_table(IPv6PrivacyExtensions, ipv6_privacy_extensions, IPV6_PRIVACY_EXTENSIONS);\n        test_table(IPVlanFlags, ipvlan_flags, NETDEV_IPVLAN_FLAGS);\n        test_table(LinkOperationalState, link_operstate, LINK_OPERSTATE);\n        /* test_table(link_state, LINK_STATE);  — not a reversible mapping */\n        test_table(LLDPMode, lldp_mode, LLDP_MODE);\n        test_table(NetDevKind, netdev_kind, NETDEV_KIND);\n        test_table(RADVPrefixDelegation, radv_prefix_delegation, RADV_PREFIX_DELEGATION);\n        test_table(sd_lldp_rx_event_t, lldp_rx_event, SD_LLDP_RX_EVENT);\n        test_table(sd_ndisc_event_t, ndisc_event, SD_NDISC_EVENT);\n        test_table(sd_dhcp_lease_server_type_t, dhcp_lease_server_type, SD_DHCP_LEASE_SERVER_TYPE);\n\n        test_table_sparse(IPVlanMode, ipvlan_mode, NETDEV_IPVLAN_MODE);\n        test_table_sparse(MacVlanMode, macvlan_mode, NETDEV_MACVLAN_MODE);\n        test_table_sparse(AddressFamily, address_family, ADDRESS_FAMILY);\n\n        assert_cc(sizeof(sd_lldp_rx_event_t) == sizeof(int64_t));\n        assert_cc(sizeof(sd_ndisc_event_t) == sizeof(int64_t));\n        assert_cc(sizeof(sd_dhcp_lease_server_type_t) == sizeof(int64_t));\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "13μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "65043μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "70006μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "24μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "0μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "135121μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "70019μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 0.4
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 0.4,
        "content_hash": "b8650a9bd1025767"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/test-network-tables.c"
      }
    },
    "source_hash": "54087255dc29"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/userdb/userdbd.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdlib.h>\n#include <sys/stat.h>\n\n#include \"sd-event.h\"\n\n#include \"daemon-util.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"signal-util.h\"\n#include \"userdbd-manager.h\"\n\n/* This service offers two Varlink services, both implementing io.systemd.UserDatabase:\n *\n *         → io.systemd.NameServiceSwitch: this is a compatibility interface for glibc NSS: it responds to\n *           name lookups by checking the classic NSS interfaces and responding that.\n *\n *         → io.systemd.Multiplexer: this multiplexes lookup requests to all Varlink services that have a\n *           socket in /run/systemd/userdb/. It's supposed to simplify clients that don't want to implement\n *           the full iterative logic on their own.\n *\n *         → io.systemd.DropIn: this makes JSON user/group records dropped into /run/userdb/ available as\n *           regular users.\n */\n\nstatic int run(int argc, char *argv[]) {\n        _cleanup_(manager_freep) Manager *m = NULL;\n        _unused_ _cleanup_(notify_on_cleanup) const char *notify_stop = NULL;\n        int r;\n\n        log_setup();\n\n        umask(0022);\n\n        if (argc != 1)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), \"This program takes no arguments.\");\n\n        if (setenv(\"SYSTEMD_BYPASS_USERDB\", \"io.systemd.NameServiceSwitch:io.systemd.Multiplexer:io.systemd.DropIn\", 1) < 0)\n                return log_error_errno(errno, \"Failed to set $SYSTEMD_BYPASS_USERDB: %m\");\n\n        assert_se(sigprocmask_many(SIG_BLOCK, NULL, SIGCHLD) >= 0);\n\n        r = manager_new(&m);\n        if (r < 0)\n                return log_error_errno(r, \"Could not create manager: %m\");\n\n        r = manager_startup(m);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to start up daemon: %m\");\n\n        notify_stop = notify_start(NOTIFY_READY_MESSAGE, NOTIFY_STOPPING_MESSAGE);\n\n        r = sd_event_loop(m->event);\n        if (r < 0)\n                return log_error_errno(r, \"Event loop failed: %m\");\n\n        return 0;\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "145μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "32μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "597125μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "168787μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "500577μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "49318μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "424μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1316408μs",
      "parallelizable_steps": [],
      "critical_path_length": "1098271μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.111111111111111
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.111111111111111,
        "content_hash": "d1b4825894218fa6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/userdb/userdbd.c"
      }
    },
    "source_hash": "3cd7b4fe557b"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: hwdb.d/acpi-update.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\nfrom csv import reader\n\n# pylint: disable=consider-using-with\n\ndef read_table(filename):\n    table = list(reader(open(filename, newline='')))\n    table = table[1:]  # Skip header\n    table.sort(key=lambda x: x[1])\n\n    for row in table:\n        # Some IDs end with whitespace, while they didn't in the old HTML table, so it's probably\n        # a mistake, strip it.\n        print(f'\\nacpi:{row[1].strip()}*:\\n ID_VENDOR_FROM_DATABASE={row[0].strip()}')\n\nprint('''\\\n# This file is part of systemd.\n#\n# Data imported from:\n#     https://uefi.org/uefi-pnp-export\n#     https://uefi.org/uefi-acpi-export''')\n\nread_table('acpi_id_registry.csv')\nread_table('pnp_id_registry.csv')\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "453μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "611850μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "485μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "948μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "496610μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "898μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1111244μs",
      "parallelizable_steps": [],
      "critical_path_length": "613696μs",
      "metadata": {
        "functions_found": [
          "read_table"
        ],
        "classes_found": [],
        "imports": [
          "csv"
        ],
        "lines_of_code": 20,
        "complexity_score": 3.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "read_table"
        ],
        "classes": [],
        "imports": [
          "csv"
        ],
        "lines_of_code": 20,
        "complexity_score": 3.5,
        "content_hash": "50317ad3489f99c1"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "hwdb.d/acpi-update.py"
      }
    },
    "source_hash": "eb04718bc8e7"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/all-units.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"automount.h\"  /* IWYU pragma: export */\n#include \"device.h\"     /* IWYU pragma: export */\n#include \"mount.h\"      /* IWYU pragma: export */\n#include \"path.h\"       /* IWYU pragma: export */\n#include \"scope.h\"      /* IWYU pragma: export */\n#include \"service.h\"    /* IWYU pragma: export */\n#include \"slice.h\"      /* IWYU pragma: export */\n#include \"socket.h\"     /* IWYU pragma: export */\n#include \"swap.h\"       /* IWYU pragma: export */\n#include \"target.h\"     /* IWYU pragma: export */\n#include \"timer.h\"      /* IWYU pragma: export */\n#include \"unit.h\"       /* IWYU pragma: export */\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "89μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "3249μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "20931μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "98680μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "31813μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "104μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "154919μs",
      "parallelizable_steps": [],
      "critical_path_length": "102122μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 0.7142857142857142
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 0.7142857142857142,
        "content_hash": "6f040d9ed0cccad2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/all-units.h"
      }
    },
    "source_hash": "ad6a3b93e9ca"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/generator/network-generator.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <stdio.h>\n\n#include \"ether-addr-util.h\"\n#include \"hashmap.h\"\n#include \"in-addr-util.h\"\n#include \"list.h\"\n\ntypedef enum DHCPType {\n        DHCP_TYPE_NONE,\n        DHCP_TYPE_OFF,   /* Same as DHCP_TYPE_NONE */\n        DHCP_TYPE_ON,\n        DHCP_TYPE_ANY,   /* Same as DHCP_TYPE_ON */\n        DHCP_TYPE_DHCP,  /* Actually means: DHCPv4 */\n        DHCP_TYPE_DHCP6,\n        DHCP_TYPE_AUTO6,\n        DHCP_TYPE_EITHER6,\n        DHCP_TYPE_IBFT,\n        DHCP_TYPE_LINK6,\n        DHCP_TYPE_LINK_LOCAL,\n        _DHCP_TYPE_MAX,\n        _DHCP_TYPE_INVALID = -EINVAL,\n} DHCPType;\n\ntypedef struct Address Address;\ntypedef struct Link Link;\ntypedef struct NetDev NetDev;\ntypedef struct Network Network;\ntypedef struct Route Route;\ntypedef struct Context Context;\n\nstruct Address {\n        Network *network;\n\n        union in_addr_union address, peer;\n        unsigned char prefixlen;\n        int family;\n\n        LIST_FIELDS(Address, addresses);\n};\n\nstruct Route {\n        Network *network;\n\n        union in_addr_union dest, gateway;\n        unsigned char prefixlen;\n        int family;\n\n        LIST_FIELDS(Route, routes);\n};\n\nstruct Network {\n        /* [Match] */\n        char *ifname;\n\n        /* [Link] */\n        struct ether_addr mac;\n        uint32_t mtu;\n\n        /* [Network] */\n        DHCPType dhcp_type;\n        char **dns;\n        char **vlan;\n        char *bridge;\n        char *bond;\n\n        /* [DHCP] */\n        char *hostname;\n        int dhcp_use_dns;\n\n        LIST_HEAD(Address, addresses);\n        LIST_HEAD(Route, routes);\n};\n\nstruct NetDev {\n        /* [NetDev] */\n        char *ifname;\n        char *kind;\n        uint32_t mtu;\n\n        /* [VLAN] */\n        uint16_t vlan_id;\n};\n\nstruct Link {\n        char *filename;\n\n        /* [Match] */\n        struct hw_addr_data mac;\n\n        /* [Link] */\n        char *ifname;\n        char **policies;\n        char **alt_policies;\n};\n\ntypedef struct Context {\n        Hashmap *networks_by_name;\n        Hashmap *netdevs_by_name;\n        Hashmap *links_by_filename;\n} Context;\n\nint parse_cmdline_item(const char *key, const char *value, void *data);\nint context_merge_networks(Context *context);\nvoid context_clear(Context *context);\n\nNetwork *network_get(Context *context, const char *ifname);\nvoid network_dump(Network *network, FILE *f);\nint network_format(Network *network, char **ret);\n\nNetDev *netdev_get(Context *context, const char *ifname);\nvoid netdev_dump(NetDev *netdev, FILE *f);\nint netdev_format(NetDev *netdev, char **ret);\n\nLink *link_get(Context *context, const char *filename);\nvoid link_dump(Link *link, FILE *f);\nint link_format(Link *link, char **ret);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "4μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "22μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "135988μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "36342μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "172μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "11μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "172539μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "136160μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 94,
        "complexity_score": 0.9574468085106382
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 94,
        "complexity_score": 0.9574468085106382,
        "content_hash": "050c7d8876ee6033"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/generator/network-generator.h"
      }
    },
    "source_hash": "a25f51ab5d8d"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/service-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\nint service_parse_argv(\n                const char *service,\n                const char *description,\n                const BusObjectImplementation* const* bus_objects,\n                int argc, char *argv[]);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "84μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "315μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "71487μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "706μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "178μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "72770μs",
      "parallelizable_steps": [],
      "critical_path_length": "71749μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 8,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 8,
        "complexity_score": 2.5,
        "content_hash": "9be0a4eee3899a96"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/service-util.h"
      }
    },
    "source_hash": "b9755afe83a1"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netfilter/nfnetlink_compat.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _NFNETLINK_COMPAT_H\n#define _NFNETLINK_COMPAT_H\n\n#include <linux/types.h>\n\n/* Old nfnetlink macros for userspace */\n\n/* nfnetlink groups: Up to 32 maximum */\n#define NF_NETLINK_CONNTRACK_NEW \t\t0x00000001\n#define NF_NETLINK_CONNTRACK_UPDATE\t\t0x00000002\n#define NF_NETLINK_CONNTRACK_DESTROY\t\t0x00000004\n#define NF_NETLINK_CONNTRACK_EXP_NEW\t\t0x00000008\n#define NF_NETLINK_CONNTRACK_EXP_UPDATE\t\t0x00000010\n#define NF_NETLINK_CONNTRACK_EXP_DESTROY\t0x00000020\n\n/* Generic structure for encapsulation optional netfilter information.\n * It is reminiscent of sockaddr, but with sa_family replaced\n * with attribute type.\n * ! This should someday be put somewhere generic as now rtnetlink and\n * ! nfnetlink use the same attributes methods. - J. Schulist.\n */\n\nstruct nfattr {\n\t__u16 nfa_len;\n\t__u16 nfa_type;\t/* we use 15 bits for the type, and the highest\n\t\t\t\t * bit to indicate whether the payload is nested */\n};\n\n/* FIXME: Apart from NFNL_NFA_NESTED shamelessly copy and pasted from\n * rtnetlink.h, it's time to put this in a generic file */\n\n#define NFNL_NFA_NEST\t0x8000\n#define NFA_TYPE(attr) \t((attr)->nfa_type & 0x7fff)\n\n#define NFA_ALIGNTO     4\n#define NFA_ALIGN(len)\t(((len) + NFA_ALIGNTO - 1) & ~(NFA_ALIGNTO - 1))\n#define NFA_OK(nfa,len)\t((len) > 0 && (nfa)->nfa_len >= sizeof(struct nfattr) \\\n\t&& (nfa)->nfa_len <= (len))\n#define NFA_NEXT(nfa,attrlen)\t((attrlen) -= NFA_ALIGN((nfa)->nfa_len), \\\n\t(struct nfattr *)(((char *)(nfa)) + NFA_ALIGN((nfa)->nfa_len)))\n#define NFA_LENGTH(len)\t(NFA_ALIGN(sizeof(struct nfattr)) + (len))\n#define NFA_SPACE(len)\tNFA_ALIGN(NFA_LENGTH(len))\n#define NFA_DATA(nfa)   ((void *)(((char *)(nfa)) + NFA_LENGTH(0)))\n#define NFA_PAYLOAD(nfa) ((int)((nfa)->nfa_len) - NFA_LENGTH(0))\n#define NFA_NEST(skb, type) \\\n({\tstruct nfattr *__start = (struct nfattr *)skb_tail_pointer(skb); \\\n\tNFA_PUT(skb, (NFNL_NFA_NEST | type), 0, NULL); \\\n\t__start;  })\n#define NFA_NEST_END(skb, start) \\\n({      (start)->nfa_len = skb_tail_pointer(skb) - (unsigned char *)(start); \\\n        (skb)->len; })\n#define NFA_NEST_CANCEL(skb, start) \\\n({      if (start) \\\n                skb_trim(skb, (unsigned char *) (start) - (skb)->data); \\\n        -1; })\n\n#define NFM_NFA(n)      ((struct nfattr *)(((char *)(n)) \\\n        + NLMSG_ALIGN(sizeof(struct nfgenmsg))))\n#define NFM_PAYLOAD(n)  NLMSG_PAYLOAD(n, sizeof(struct nfgenmsg))\n\n#endif /* _NFNETLINK_COMPAT_H */\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "407μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "47610μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "190557μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "343731μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "381814μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "57676μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "323μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1022171μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "572747μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154,
        "content_hash": "d7a122ec93ce932a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netfilter/nfnetlink_compat.h"
      }
    },
    "source_hash": "4f4c31c87c3a"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/generate-syscall-list.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\nimport sys\n\nfor line in open(sys.argv[1]):\n    print('\"{}\\\\0\"'.format(line.strip()))\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "564μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "232μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "432942μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1831μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "248μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "435817μs",
      "parallelizable_steps": [],
      "critical_path_length": "433754μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 5,
        "complexity_score": 6.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 5,
        "complexity_score": 6.0,
        "content_hash": "da9ca7e071cc81f4"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/generate-syscall-list.py"
      }
    },
    "source_hash": "ab68ad10eb2c"
  },
  {
    "instruction": "Analyze and decompose this proxy_tunneling code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/l2tp-tunnel.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/l2tp.h>\n\n#include \"in-addr-util.h\"\n#include \"forward.h\"\n#include \"netdev.h\"\n\ntypedef enum L2tpL2specType {\n        NETDEV_L2TP_L2SPECTYPE_NONE = L2TP_L2SPECTYPE_NONE,\n        NETDEV_L2TP_L2SPECTYPE_DEFAULT = L2TP_L2SPECTYPE_DEFAULT,\n        _NETDEV_L2TP_L2SPECTYPE_MAX,\n        _NETDEV_L2TP_L2SPECTYPE_INVALID = -EINVAL,\n} L2tpL2specType;\n\ntypedef enum L2tpEncapType {\n        NETDEV_L2TP_ENCAPTYPE_UDP = L2TP_ENCAPTYPE_UDP,\n        NETDEV_L2TP_ENCAPTYPE_IP = L2TP_ENCAPTYPE_IP,\n        _NETDEV_L2TP_ENCAPTYPE_MAX,\n        _NETDEV_L2TP_ENCAPTYPE_INVALID = -EINVAL,\n} L2tpEncapType;\n\ntypedef enum L2tpLocalAddressType {\n        NETDEV_L2TP_LOCAL_ADDRESS_AUTO,\n        NETDEV_L2TP_LOCAL_ADDRESS_STATIC,\n        NETDEV_L2TP_LOCAL_ADDRESS_DYNAMIC,\n        _NETDEV_L2TP_LOCAL_ADDRESS_MAX,\n        _NETDEV_L2TP_LOCAL_ADDRESS_INVALID = -EINVAL,\n} L2tpLocalAddressType;\n\ntypedef struct L2tpTunnel L2tpTunnel;\n\ntypedef struct L2tpSession {\n        L2tpTunnel *tunnel;\n        ConfigSection *section;\n\n        char *name;\n        int ifindex;\n\n        uint32_t session_id;\n        uint32_t peer_session_id;\n        L2tpL2specType l2tp_l2spec_type;\n} L2tpSession;\n\nstruct L2tpTunnel {\n        NetDev meta;\n\n        uint16_t l2tp_udp_sport;\n        uint16_t l2tp_udp_dport;\n\n        uint32_t tunnel_id;\n        uint32_t peer_tunnel_id;\n\n        int family;\n\n        bool udp_csum;\n        bool udp6_csum_rx;\n        bool udp6_csum_tx;\n\n        char *local_ifname;\n        L2tpLocalAddressType local_address_type;\n        union in_addr_union local;\n        union in_addr_union remote;\n\n        L2tpEncapType l2tp_encap_type;\n\n        OrderedHashmap *sessions_by_section;\n};\n\nDEFINE_NETDEV_CAST(L2TP, L2tpTunnel);\nextern const NetDevVTable l2tptnl_vtable;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_tunnel_local_address);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_tunnel_remote_address);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_tunnel_id);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_encap_type);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_session_l2spec);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_session_id);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_session_name);\n",
    "output": {
      "operation": "Proxy Tunneling Implementation",
      "category": "proxy_tunneling",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "54μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "108μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "52881μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "195μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "69μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "53307μs",
      "parallelizable_steps": [],
      "critical_path_length": "53004μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 0.6557377049180328
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "proxy_tunneling",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 0.6557377049180328,
        "content_hash": "b9e1e1b49471b218"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/l2tp-tunnel.h"
      }
    },
    "source_hash": "5b0900619a3e"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dnstls.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#if ENABLE_DNS_OVER_TLS\n\n#if !HAVE_OPENSSL\n#error This source file requires OpenSSL to be available.\n#endif\n\n#include <openssl/ssl.h>\n\n#include \"resolved-forward.h\"\n\ntypedef struct DnsTlsManagerData {\n        SSL_CTX *ctx;\n} DnsTlsManagerData;\n\ntypedef struct DnsTlsServerData {\n        SSL_SESSION *session;\n} DnsTlsServerData;\n\ntypedef struct DnsTlsStreamData {\n        int handshake;\n        bool shutdown;\n        SSL *ssl;\n        BUF_MEM *write_buffer;\n        size_t buffer_offset;\n} DnsTlsStreamData;\n\n#define DNSTLS_STREAM_CLOSED 1\n\nint dnstls_stream_connect_tls(DnsStream *stream, DnsServer *server);\nvoid dnstls_stream_free(DnsStream *stream);\nint dnstls_stream_on_io(DnsStream *stream, uint32_t revents);\nint dnstls_stream_shutdown(DnsStream *stream, int error);\nssize_t dnstls_stream_writev(DnsStream *stream, const struct iovec *iov, size_t iovcnt);\nssize_t dnstls_stream_read(DnsStream *stream, void *buf, size_t count);\n\nvoid dnstls_server_free(DnsServer *server);\n\nint dnstls_manager_init(Manager *manager);\nvoid dnstls_manager_free(Manager *manager);\n\n#endif /* ENABLE_DNS_OVER_TLS */\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "185μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "673778μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1079μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "761μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "134634μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "563μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "811000μs",
      "parallelizable_steps": [],
      "critical_path_length": "675102μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.875,
        "content_hash": "0235cc297b591136"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dnstls.h"
      }
    },
    "source_hash": "f99a4737780c"
  },
  {
    "instruction": "Analyze and decompose this grpc code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/boot/drivers.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"efi.h\"\n#include \"proto/loaded-image.h\"\n\nEFI_STATUS reconnect_all_drivers(void);\nEFI_STATUS load_drivers(\n                EFI_HANDLE parent_image,\n                EFI_LOADED_IMAGE_PROTOCOL *loaded_image,\n                EFI_FILE *root_dir);\n",
    "output": {
      "operation": "Grpc Implementation",
      "category": "grpc",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "172μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "146μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "692μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "240μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "33μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "1283μs",
      "parallelizable_steps": [],
      "critical_path_length": "897μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 9,
        "complexity_score": 1.1111111111111112
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "grpc",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 9,
        "complexity_score": 1.1111111111111112,
        "content_hash": "d50a269c1adb7b33"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/boot/drivers.h"
      }
    },
    "source_hash": "cab2278d6d38"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkctl-dump-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\nint dump_list(Table *table, const char *key, char * const *l);\nint ieee_oui(sd_hwdb *hwdb, const struct ether_addr *mac, char **ret);\nint dump_gateways(sd_netlink *rtnl, sd_hwdb *hwdb, Table *table, int ifindex);\nint dump_addresses(sd_netlink *rtnl, sd_dhcp_lease *lease, Table *table, int ifindex);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "271μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "478μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "285772μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "347μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "988μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "287856μs",
      "parallelizable_steps": [],
      "critical_path_length": "287031μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 5.7142857142857135
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 5.7142857142857135,
        "content_hash": "11c17eb93c6cc6e5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkctl-dump-util.h"
      }
    },
    "source_hash": "3869838a8e39"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/bus-locator.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef struct BusLocator {\n        const char *destination;\n        const char *path;\n        const char *interface;\n} BusLocator;\n\nextern const BusLocator* const bus_home_mgr;\nextern const BusLocator* const bus_hostname;\nextern const BusLocator* const bus_import_mgr;\nextern const BusLocator* const bus_locale;\nextern const BusLocator* const bus_login_mgr;\nextern const BusLocator* const bus_machine_mgr;\nextern const BusLocator* const bus_network_mgr;\nextern const BusLocator* const bus_oom_mgr;\nextern const BusLocator* const bus_portable_mgr;\nextern const BusLocator* const bus_resolve_mgr;\nextern const BusLocator* const bus_systemd_mgr;\nextern const BusLocator* const bus_sysupdate_mgr;\nextern const BusLocator* const bus_timedate;\nextern const BusLocator* const bus_timesync_mgr;\n\n/* Shorthand flavors of the sd-bus convenience helpers with destination,path,interface strings encapsulated\n * within a single struct. */\nint bus_call_method_async(sd_bus *bus, sd_bus_slot **ret_slot, const BusLocator *locator, const char *member, sd_bus_message_handler_t callback, void *userdata, const char *types, ...);\nint bus_call_method(sd_bus *bus, const BusLocator *locator, const char *member, sd_bus_error *reterr_error, sd_bus_message **ret_reply, const char *types, ...);\nint bus_get_property(sd_bus *bus, const BusLocator *locator, const char *member, sd_bus_error *reterr_error, sd_bus_message **ret_reply, const char *type);\nint bus_get_property_trivial(sd_bus *bus, const BusLocator *locator, const char *member, sd_bus_error *reterr_error, char type, void *ret);\nint bus_get_property_string(sd_bus *bus, const BusLocator *locator, const char *member, sd_bus_error *reterr_error, char **ret);\nint bus_get_property_strv(sd_bus *bus, const BusLocator *locator, const char *member, sd_bus_error *reterr_error, char ***ret);\nint bus_set_property(sd_bus *bus, const BusLocator *locator, const char *member, sd_bus_error *reterr_error, const char *type, ...);\nint bus_match_signal(sd_bus *bus, sd_bus_slot **ret_slot, const BusLocator *locator, const char *member, sd_bus_message_handler_t callback, void *userdata);\nint bus_match_signal_async(sd_bus *bus, sd_bus_slot **ret_slot, const BusLocator *locator, const char *member, sd_bus_message_handler_t callback, sd_bus_message_handler_t install_callback, void *userdata);\nint bus_message_new_method_call(sd_bus *bus, sd_bus_message **ret, const BusLocator *locator, const char *member);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "66μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "67μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "173376μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "148μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "254μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "173911μs",
      "parallelizable_steps": [],
      "critical_path_length": "173696μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.7647058823529413
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.7647058823529413,
        "content_hash": "b98a9f248b7b26ed"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/bus-locator.h"
      }
    },
    "source_hash": "6f505bca4f93"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: test/units/TEST-69-SHUTDOWN.py\n\nCode:\n#!/usr/bin/python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n# pylint: disable=broad-except\n\nimport logging\nimport sys\n\nimport pexpect\n\n\ndef main():\n    # TODO: drop once https://bugs.debian.org/1075733 is fixed\n    with open(\"/usr/lib/os-release\") as f:\n        for line in f:\n            if line.startswith(\"ID=\"):\n                if \"debian\" in line or \"ubuntu\" in line:\n                    sys.exit(77)\n\n    logger = logging.getLogger(\"test-shutdown\")\n\n    consoles = []\n    for _ in range(2):\n        # Use script to allocate a separate pseudo tty to run the login shell in.\n        console = pexpect.spawn(\n            \"script\", [\"--quiet\", \"--return\", \"--flush\", \"--command\", \"login -f root\", \"/dev/null\"],\n            logfile=sys.stdout,\n            env={\"TERM\": \"dumb\"},\n            encoding=\"utf-8\",\n            timeout=60,\n        )\n\n        logger.info(\"waiting for login prompt\")\n        console.expect(\".*# \", 10)\n\n        consoles += [console]\n\n    consoles[1].sendline(\"tty\")\n    consoles[1].expect(r\"/dev/(pts/\\d+)\")\n    pty = console.match.group(1)\n    logger.info(\"window 1 at tty %s\", pty)\n\n    logger.info(\"schedule reboot\")\n    consoles[1].sendline(\"shutdown -r\")\n    consoles[1].expect(\"Reboot scheduled for (?P<date>.*), use 'shutdown -c' to cancel\", 2)\n    date = consoles[1].match.group(\"date\")\n    logger.info(\"reboot scheduled for %s\", date)\n\n    logger.info(\"verify broadcast message\")\n    consoles[0].expect(f\"Broadcast message from root@H on {pty}\", 2)\n    consoles[0].expect(f\"The system will reboot at {date}!\", 2)\n\n    logger.info(\"check show output\")\n    consoles[1].sendline(\"shutdown --show\")\n    consoles[1].expect(f\"Reboot scheduled for {date}, use 'shutdown -c' to cancel\", 2)\n\n    logger.info(\"cancel shutdown\")\n    consoles[1].sendline(\"shutdown -c\")\n    consoles[0].expect(\"System shutdown has been cancelled\", 2)\n\n    consoles[0].sendline(\"> /testok\")\n\nif __name__ == \"__main__\":\n    main()\n\n# vim: sw=4 et\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "670μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "928359μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1167μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "219μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "65263μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1016μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "996694μs",
      "parallelizable_steps": [],
      "critical_path_length": "929594μs",
      "metadata": {
        "functions_found": [
          "main"
        ],
        "classes_found": [],
        "imports": [
          "logging",
          "sys",
          "pexpect"
        ],
        "lines_of_code": 49,
        "complexity_score": 2.8571428571428568
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "main"
        ],
        "classes": [],
        "imports": [
          "logging",
          "sys",
          "pexpect"
        ],
        "lines_of_code": 49,
        "complexity_score": 2.8571428571428568,
        "content_hash": "e1ba2e4951525dc0"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "test/units/TEST-69-SHUTDOWN.py"
      }
    },
    "source_hash": "d65082eefe6f"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/mkdir.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum MkdirFlags {\n        MKDIR_FOLLOW_SYMLINK  = 1 << 0,\n        MKDIR_IGNORE_EXISTING = 1 << 1,  /* Quietly accept a preexisting directory (or file) */\n        MKDIR_WARN_MODE       = 1 << 2,  /* Log at LOG_WARNING when mode doesn't match */\n} MkdirFlags;\n\nint mkdirat_errno_wrapper(int dirfd, const char *pathname, mode_t mode);\n\nint mkdirat_safe(int dir_fd, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags);\nstatic inline int mkdir_safe(const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags) {\n        return mkdirat_safe(AT_FDCWD, path, mode, uid, gid, flags);\n}\nint mkdirat_parents(int dir_fd, const char *path, mode_t mode);\nstatic inline int mkdir_parents(const char *path, mode_t mode) {\n        return mkdirat_parents(AT_FDCWD, path, mode);\n}\nint mkdir_parents_safe(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags);\nint mkdir_p(const char *path, mode_t mode);\nint mkdir_p_safe(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags);\nint mkdir_p_root_full(const char *root, const char *p, uid_t uid, gid_t gid, mode_t m, usec_t ts, char **subvolumes);\nstatic inline int mkdir_p_root(const char *root, const char *p, uid_t uid, gid_t gid, mode_t m) {\n        return mkdir_p_root_full(root, p, uid, gid, m, USEC_INFINITY, NULL);\n}\n\n/* The following are used to implement the mkdir_xyz_label() calls, don't use otherwise. */\ntypedef int (*mkdirat_func_t)(int dir_fd, const char *pathname, mode_t mode);\nint mkdirat_safe_internal(int dir_fd, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir);\nstatic inline int mkdir_safe_internal(const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir) {\n        return mkdirat_safe_internal(AT_FDCWD, path, mode, uid, gid, flags, _mkdir);\n}\nint mkdirat_parents_internal(int dir_fd, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdirat);\nint mkdir_parents_internal(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir);\nint mkdir_p_internal(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "29μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "46μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "93036μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "111581μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "53577μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "2723μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "95μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "261087μs",
      "parallelizable_steps": [],
      "critical_path_length": "146737μs",
      "metadata": {
        "functions_found": [
          "int"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "int"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061,
        "content_hash": "726313c814f3d5e2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/mkdir.h"
      }
    },
    "source_hash": "81b234a8a22d"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/bridge-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/if_bridge.h>\n\n#include \"forward.h\"\n\ntypedef enum BridgeState {\n        NETDEV_BRIDGE_STATE_DISABLED   = BR_STATE_DISABLED,\n        NETDEV_BRIDGE_STATE_LISTENING  = BR_STATE_LISTENING,\n        NETDEV_BRIDGE_STATE_LEARNING   = BR_STATE_LEARNING,\n        NETDEV_BRIDGE_STATE_FORWARDING = BR_STATE_FORWARDING,\n        NETDEV_BRIDGE_STATE_BLOCKING   = BR_STATE_BLOCKING,\n        _NETDEV_BRIDGE_STATE_MAX,\n        _NETDEV_BRIDGE_STATE_INVALID   = -EINVAL,\n} BridgeState;\n\nconst char* bridge_state_to_string(BridgeState d) _const_;\nBridgeState bridge_state_from_string(const char *d) _pure_;\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "530μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "55μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "61418μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "566μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "634μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "63203μs",
      "parallelizable_steps": [],
      "critical_path_length": "62582μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 3.333333333333333,
        "content_hash": "abc2707c48a72c86"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/bridge-util.h"
      }
    },
    "source_hash": "29679ee4aa38"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/analyze/analyze-blame.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"analyze.h\"\n#include \"analyze-blame.h\"\n#include \"analyze-time-data.h\"\n#include \"bus-util.h\"\n#include \"format-table.h\"\n#include \"runtime-scope.h\"\n\nint verb_blame(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        _cleanup_(unit_times_free_arrayp) UnitTimes *times = NULL;\n        _cleanup_(table_unrefp) Table *table = NULL;\n        TableCell *cell;\n        int n, r;\n\n        r = acquire_bus(&bus, NULL);\n        if (r < 0)\n                return bus_log_connect_error(r, arg_transport, arg_runtime_scope);\n\n        n = acquire_time_data(bus, /* require_finished = */ false, &times);\n        if (n <= 0)\n                return n;\n\n        table = table_new(\"time\", \"unit\");\n        if (!table)\n                return log_oom();\n\n        table_set_header(table, false);\n\n        assert_se(cell = table_get_cell(table, 0, 0));\n        r = table_set_ellipsize_percent(table, cell, 100);\n        if (r < 0)\n                return r;\n\n        r = table_set_align_percent(table, cell, 100);\n        if (r < 0)\n                return r;\n\n        assert_se(cell = table_get_cell(table, 0, 1));\n        r = table_set_ellipsize_percent(table, cell, 100);\n        if (r < 0)\n                return r;\n\n        r = table_set_sort(table, (size_t) 0);\n        if (r < 0)\n                return r;\n\n        r = table_set_reverse(table, 0, true);\n        if (r < 0)\n                return r;\n\n        for (UnitTimes *u = times; u->has_data; u++) {\n                if (u->time <= 0)\n                        continue;\n\n                r = table_add_many(table,\n                                   TABLE_TIMESPAN_MSEC, u->time,\n                                   TABLE_STRING, u->name);\n                if (r < 0)\n                        return table_log_add_error(r);\n        }\n\n        pager_open(arg_pager_flags);\n\n        r = table_print(table, NULL);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "388μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "211μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "7534μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "471μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "232μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "8836μs",
      "parallelizable_steps": [],
      "critical_path_length": "8154μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 2.5,
        "content_hash": "98c808fc7b6fea77"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/analyze/analyze-blame.c"
      }
    },
    "source_hash": "2853bfec7fe0"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/rc-local-generator/rc-local-generator.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <unistd.h>\n\n#include \"generator.h\"\n#include \"initrd-util.h\"\n#include \"log.h\"\n#include \"mkdir-label.h\"\n#include \"string-util.h\"\n\nstatic const char *arg_dest = NULL;\n\n/* So you are reading this, and might wonder: why is this implemented as a generator rather than as a plain, statically\n * enabled service that carries appropriate ConditionFileIsExecutable= lines? The answer is this: conditions bypass\n * execution of a service's binary, but they have no influence on unit dependencies. Thus, a service that is\n * conditioned out will still act as synchronization point in the dependency tree, and we'd rather not have that for\n * these two legacy scripts. */\n\nstatic int add_symlink(const char *service, const char *where) {\n        const char *from, *to;\n\n        assert(service);\n        assert(where);\n\n        from = strjoina(SYSTEM_DATA_UNIT_DIR \"/\", service);\n        to = strjoina(arg_dest, \"/\", where, \".wants/\", service);\n\n        (void) mkdir_parents_label(to, 0755);\n\n        if (symlink(from, to) < 0) {\n                if (errno == EEXIST)\n                        return 0;\n\n                return log_error_errno(errno, \"Failed to create symlink %s: %m\", to);\n        }\n\n        return 1;\n}\n\nstatic int check_executable(const char *path) {\n        assert(path);\n\n        if (access(path, X_OK) < 0) {\n                if (errno == ENOENT)\n                        return log_debug_errno(errno, \"%s does not exist, skipping.\", path);\n                if (errno == EACCES)\n                        return log_info_errno(errno, \"%s is not marked executable, skipping.\", path);\n\n                return log_warning_errno(errno, \"Couldn't determine if %s exists and is executable, skipping: %m\", path);\n        }\n\n        return 0;\n}\n\nstatic int run(const char *dest, const char *dest_early, const char *dest_late) {\n        int r = 0, k = 0;\n\n        assert_se(arg_dest = dest);\n\n        if (in_initrd()) {\n                log_debug(\"Skipping generator, running in the initrd.\");\n                return EXIT_SUCCESS;\n        }\n\n        if (check_executable(SYSTEM_SYSVRCLOCAL_PATH) >= 0) {\n                log_debug(\"Automatically adding rc-local.service.\");\n\n                r = add_symlink(\"rc-local.service\", \"multi-user.target\");\n        }\n\n        return r < 0 ? r : k;\n}\n\nDEFINE_MAIN_GENERATOR_FUNCTION(run);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "303μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "298μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "139534μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "103μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "130μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "140368μs",
      "parallelizable_steps": [],
      "critical_path_length": "139967μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 1.9230769230769231
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 1.9230769230769231,
        "content_hash": "283f0cfe697b8681"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/rc-local-generator/rc-local-generator.c"
      }
    },
    "source_hash": "9cfecf504d62"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/dynamic-user.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"core-forward.h\"\n\n/* Note that this object always allocates a pair of user and group under the same name, even if one of them isn't\n * used. This means, if you want to allocate a group and user pair, and they might have two different names, then you\n * need to allocated two of these objects. DynamicCreds below makes that easy. */\ntypedef struct DynamicUser {\n        Manager *manager;\n        unsigned n_ref;\n\n        /* An AF_UNIX socket pair that contains a datagram containing both the numeric ID assigned, as well as a lock\n         * file fd locking the user ID we picked. */\n        int storage_socket[2];\n\n        char name[];\n} DynamicUser;\n\ntypedef struct DynamicCreds {\n        /* A combination of a dynamic user and group */\n        DynamicUser *user;\n        DynamicUser *group;\n} DynamicCreds;\n\nint dynamic_user_serialize(Manager *m, FILE *f, FDSet *fds);\nint dynamic_user_serialize_one(DynamicUser *d, const char *key, FILE *f, FDSet *fds);\nvoid dynamic_user_deserialize_one(Manager *m, const char *value, FDSet *fds, DynamicUser **ret);\nDynamicUser* dynamic_user_free(DynamicUser *d);\nvoid dynamic_user_vacuum(Manager *m, bool close_user);\n\nint dynamic_user_current(DynamicUser *d, uid_t *ret);\nint dynamic_user_lookup_uid(Manager *m, uid_t uid, char **ret);\nint dynamic_user_lookup_name(Manager *m, const char *name, uid_t *ret);\n\nint dynamic_creds_make(Manager *m, const char *user, const char *group, DynamicCreds **ret);\nint dynamic_creds_realize(DynamicCreds *creds, char **suggested_paths, uid_t *uid, gid_t *gid);\n\nDynamicCreds *dynamic_creds_unref(DynamicCreds *creds);\nDynamicCreds *dynamic_creds_destroy(DynamicCreds *creds);\nvoid dynamic_creds_done(DynamicCreds *creds);\nvoid dynamic_creds_close(DynamicCreds *creds);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DynamicCreds*, dynamic_creds_unref);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DynamicCreds*, dynamic_creds_destroy);\n\nDynamicUser *dynamic_user_ref(DynamicUser *user);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "55μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "109μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "131035μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "263809μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "262440μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "200928μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "185μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "858561μs",
      "parallelizable_steps": [],
      "critical_path_length": "464846μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.3888888888888888
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.3888888888888888,
        "content_hash": "063eed7394c83a72"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/dynamic-user.h"
      }
    },
    "source_hash": "e12b1b0b08fa"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/nspawn/nspawn-network.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/if.h>\n\n#include \"forward.h\"\n\nint test_network_interfaces_initialized(char **iface_pairs);\nint resolve_network_interface_names(char **iface_pairs);\n\nint setup_veth(const char *machine_name, const PidRef *pid, char iface_name[IFNAMSIZ], bool bridge, const struct ether_addr *provided_mac);\nint setup_veth_extra(const char *machine_name, const PidRef *pid, char **pairs);\n\nint setup_bridge(const char *veth_name, const char *bridge_name, bool create);\nint remove_bridge(const char *bridge_name);\n\nint setup_macvlan(const char *machine_name, const PidRef *pid, char **iface_pairs);\nint remove_macvlan(int child_netns_fd, char **interface_pairs);\nint setup_ipvlan(const char *machine_name, const PidRef *pid, char **iface_pairs);\n\nint move_network_interfaces(int netns_fd, char **iface_pairs);\nint move_back_network_interfaces(int child_netns_fd, char **interface_pairs);\n\nint veth_extra_parse(char ***l, const char *p);\n\nint remove_veth_links(const char *primary, char **pairs);\n\nint interface_pair_parse(char ***l, const char *p);\nint macvlan_pair_parse(char ***l, const char *p);\nint ipvlan_pair_parse(char ***l, const char *p);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "773μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "350μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "158320μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1263μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "413μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "161119μs",
      "parallelizable_steps": [],
      "critical_path_length": "159506μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 5.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 5.0,
        "content_hash": "98180c1910acae4c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/nspawn/nspawn-network.h"
      }
    },
    "source_hash": "e61682bb9869"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/test-resolve-tables.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"dns-type.h\"\n#include \"resolved-dns-dnssec.h\"\n#include \"resolved-dns-packet.h\"\n#include \"test-tables.h\"\n#include \"tests.h\"\n\nint main(int argc, char **argv) {\n        uint16_t i;\n\n        test_setup_logging(LOG_DEBUG);\n\n        test_table(DnsProtocol, dns_protocol, DNS_PROTOCOL);\n        test_table(DnssecResult, dnssec_result, DNSSEC_RESULT);\n        test_table(DnssecVerdict, dnssec_verdict, DNSSEC_VERDICT);\n\n        test_table_sparse(int, dns_rcode, DNS_RCODE);\n        test_table_sparse(int, dns_type, DNS_TYPE);\n\n        log_info(\"/* DNS_TYPE */\");\n        for (i = 0; i < _DNS_TYPE_MAX; i++) {\n                const char *s;\n\n                s = dns_type_to_string(i);\n                assert_se(s == NULL || strlen(s) < _DNS_TYPE_STRING_MAX);\n\n                if (s)\n                        log_info(\"%-*s %s%s%s%s%s%s%s%s%s\",\n                                 (int) _DNS_TYPE_STRING_MAX - 1, s,\n                                 dns_type_is_pseudo(i) ? \"pseudo \" : \"\",\n                                 dns_type_is_valid_query(i) ? \"valid_query \" : \"\",\n                                 dns_type_is_valid_rr(i) ? \"is_valid_rr \" : \"\",\n                                 dns_type_may_redirect(i) ? \"may_redirect \" : \"\",\n                                 dns_type_is_dnssec(i) ? \"dnssec \" : \"\",\n                                 dns_type_is_obsolete(i) ? \"obsolete \" : \"\",\n                                 dns_type_may_wildcard(i) ? \"wildcard \" : \"\",\n                                 dns_type_apex_only(i) ? \"apex_only \" : \"\",\n                                 dns_type_needs_authentication(i) ? \"needs_authentication\" : \"\");\n        }\n\n        log_info(\"/* DNS_CLASS */\");\n        for (i = 0; i < _DNS_CLASS_MAX; i++) {\n                const char *s;\n\n                s = dns_class_to_string(i);\n                assert_se(s == NULL || strlen(s) < _DNS_CLASS_STRING_MAX);\n\n                if (s)\n                        log_info(\"%-*s %s%s\",\n                                 (int) _DNS_CLASS_STRING_MAX - 1, s,\n                                 dns_class_is_pseudo(i) ? \"is_pseudo \" : \"\",\n                                 dns_class_is_valid_rr(i) ? \"is_valid_rr \" : \"\");\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "78μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "33μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "217225μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "150559μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "112μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "46μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "368053μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "217337μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.1111111111111112
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.1111111111111112,
        "content_hash": "4a3db854b713b17d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/test-resolve-tables.c"
      }
    },
    "source_hash": "5738330aada6"
  },
  {
    "instruction": "Decompose the network operation: TCP 3-way handshake",
    "input": "Analyze the step-by-step process for: TCP 3-way handshake",
    "output": {
      "operation": "TCP 3-way handshake",
      "category": "tcp_connection_management",
      "steps": [
        {
          "step": 1,
          "action": "Client sends SYN packet with ISN",
          "expected_time": "807297μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Server receives SYN and allocates TCB",
          "expected_time": "466μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Server sends SYN-ACK response",
          "expected_time": "902071μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Client receives SYN-ACK and sends ACK",
          "expected_time": "392132μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Connection established and ready",
          "expected_time": "558μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2102524μs",
      "parallelizable_steps": [],
      "critical_path_length": "1709926μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "tcp_connection_management",
      "complexity": "medium",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "cd443f3d055c"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/resolve-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"conf-parser.h\"\n#include \"in-addr-util.h\"\n#include \"resolve-util.h\"\n#include \"string-table.h\"\n\nDEFINE_CONFIG_PARSE_ENUM(config_parse_resolve_support, resolve_support, ResolveSupport);\nDEFINE_CONFIG_PARSE_ENUM(config_parse_dnssec_mode, dnssec_mode, DnssecMode);\nDEFINE_CONFIG_PARSE_ENUM(config_parse_dns_over_tls_mode, dns_over_tls_mode, DnsOverTlsMode);\n\nstatic const char* const resolve_support_table[_RESOLVE_SUPPORT_MAX] = {\n        [RESOLVE_SUPPORT_NO] = \"no\",\n        [RESOLVE_SUPPORT_YES] = \"yes\",\n        [RESOLVE_SUPPORT_RESOLVE] = \"resolve\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(resolve_support, ResolveSupport, RESOLVE_SUPPORT_YES);\n\nstatic const char* const dnssec_mode_table[_DNSSEC_MODE_MAX] = {\n        [DNSSEC_NO] = \"no\",\n        [DNSSEC_ALLOW_DOWNGRADE] = \"allow-downgrade\",\n        [DNSSEC_YES] = \"yes\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(dnssec_mode, DnssecMode, DNSSEC_YES);\n\nstatic const char* const dns_over_tls_mode_table[_DNS_OVER_TLS_MODE_MAX] = {\n        [DNS_OVER_TLS_NO] = \"no\",\n        [DNS_OVER_TLS_OPPORTUNISTIC] = \"opportunistic\",\n        [DNS_OVER_TLS_YES] = \"yes\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(dns_over_tls_mode, DnsOverTlsMode, DNS_OVER_TLS_YES);\n\nbool dns_server_address_valid(int family, const union in_addr_union *sa) {\n\n        /* Refuses the 0 IP addresses as well as 127.0.0.53/127.0.0.54 (which is our own DNS stub) */\n\n        if (!in_addr_is_set(family, sa))\n                return false;\n\n        if (family == AF_INET && IN_SET(be32toh(sa->in.s_addr), INADDR_DNS_STUB, INADDR_DNS_PROXY_STUB))\n                return false;\n\n        return true;\n}\n\nDEFINE_CONFIG_PARSE_ENUM(config_parse_dns_cache_mode, dns_cache_mode, DnsCacheMode);\n\nstatic const char* const dns_cache_mode_table[_DNS_CACHE_MODE_MAX] = {\n        [DNS_CACHE_MODE_YES] = \"yes\",\n        [DNS_CACHE_MODE_NO] = \"no\",\n        [DNS_CACHE_MODE_NO_NEGATIVE] = \"no-negative\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(dns_cache_mode, DnsCacheMode, DNS_CACHE_MODE_YES);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "31μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "71μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "144719μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "166645μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "180μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "32μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "311678μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "166748μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732,
        "content_hash": "6280c558ebfb7f7f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/resolve-util.c"
      }
    },
    "source_hash": "a400ffeb8b5f"
  },
  {
    "instruction": "Analyze and break down this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "689μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "593μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "469μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "271399μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "279μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "391μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "273820μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "272383μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "b73cab1e3368"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/group-record.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"user-record.h\"\n\ntypedef struct GroupRecord {\n        unsigned n_ref;\n        UserRecordMask mask;\n        bool incomplete;\n\n        char *group_name;\n        char *realm;\n        char *group_name_and_realm_auto;\n        sd_id128_t uuid;\n\n        char *description;\n\n        UserDisposition disposition;\n        uint64_t last_change_usec;\n\n        gid_t gid;\n\n        char **members;\n\n        char *service;\n\n        /* The following exist mostly so that we can cover the full /etc/gshadow set of fields, we currently\n         * do not actually make use of these */\n        char **administrators;  /* maps to 'struct sgrp' .sg_adm field */\n        char **hashed_password; /* maps to 'struct sgrp' .sg_passwd field */\n\n        sd_json_variant *json;\n} GroupRecord;\n\nGroupRecord* group_record_new(void);\nGroupRecord* group_record_ref(GroupRecord *g);\nGroupRecord* group_record_unref(GroupRecord *g);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(GroupRecord*, group_record_unref);\n\nint group_record_load(GroupRecord *h, sd_json_variant *v, UserRecordLoadFlags flags);\nint group_record_build(GroupRecord **ret, ...);\n#define group_record_buildo(ret, ...)                                   \\\n        group_record_build((ret), SD_JSON_BUILD_OBJECT(__VA_ARGS__))\nint group_record_clone(GroupRecord *g, UserRecordLoadFlags flags, GroupRecord **ret);\n\nbool group_record_match(GroupRecord *h, const UserDBMatch *match);\n\nconst char* group_record_group_name_and_realm(GroupRecord *h);\nUserDisposition group_record_disposition(GroupRecord *h);\n\nbool group_record_matches_group_name(const GroupRecord *g, const char *groupname);\n\nbool group_record_is_root(const GroupRecord *g) _pure_;\nbool group_record_is_nobody(const GroupRecord *g) _pure_;\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "57μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "56μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "42444μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "32μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "25μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "42614μs",
      "parallelizable_steps": [],
      "critical_path_length": "42526μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.5128205128205128
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.5128205128205128,
        "content_hash": "7e280088f867cd63"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/group-record.h"
      }
    },
    "source_hash": "a1161eee9d05"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dhcp-server-static-lease.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#include <netinet/in.h>\n\n#include \"networkd-forward.h\"\n\ntypedef struct DHCPStaticLease {\n        Network *network;\n        ConfigSection *section;\n\n        struct in_addr address;\n        uint8_t *client_id;\n        size_t client_id_size;\n} DHCPStaticLease;\n\nvoid network_drop_invalid_static_leases(Network *network);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_static_lease_address);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_static_lease_hwaddr);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "27μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "70μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "47112μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "439μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "14μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "47662μs",
      "parallelizable_steps": [],
      "critical_path_length": "47153μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 1.4285714285714284
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 1.4285714285714284,
        "content_hash": "d00988b645870bc8"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dhcp-server-static-lease.h"
      }
    },
    "source_hash": "b4d8283bc83e"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/override/linux/nsfs.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include_next <linux/nsfs.h>    /* IWYU pragma: export */\n\n/* Root namespace inode numbers, as per include/linux/proc_ns.h in the kernel source tree, since v3.8:\n * https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=98f842e675f96ffac96e6c50315790912b2812be */\n\n#define PROC_IPC_INIT_INO    ((ino_t) UINT32_C(0xEFFFFFFF))\n#define PROC_UTS_INIT_INO    ((ino_t) UINT32_C(0xEFFFFFFE))\n#define PROC_USER_INIT_INO   ((ino_t) UINT32_C(0xEFFFFFFD))\n#define PROC_PID_INIT_INO    ((ino_t) UINT32_C(0xEFFFFFFC))\n#define PROC_CGROUP_INIT_INO ((ino_t) UINT32_C(0xEFFFFFFB))\n#define PROC_TIME_INIT_INO   ((ino_t) UINT32_C(0xEFFFFFFA))\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "105μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "147194μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "644μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "153μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "152490μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "327μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "300913μs",
      "parallelizable_steps": [],
      "critical_path_length": "153239μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 0.9090909090909092
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 0.9090909090909092,
        "content_hash": "b1775d05a9fcdc32"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/override/linux/nsfs.h"
      }
    },
    "source_hash": "aae1d5b296c1"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-address-generation.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nIPv6Token* ipv6_token_ref(IPv6Token *token);\nIPv6Token* ipv6_token_unref(IPv6Token *token);\n\nint dhcp_pd_generate_addresses(Link *link, const struct in6_addr *prefix, Hashmap **ret);\nint ndisc_generate_addresses(Link *link, const struct in6_addr *prefix, uint8_t prefixlen, Hashmap **ret);\nint radv_generate_addresses(Link *link, Set *tokens, const struct in6_addr *prefix, uint8_t prefixlen, Hashmap **ret);\n\nint regenerate_address(Address *address, Link *link);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_address_generation_type);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "43μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "8666μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "338μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "9124μs",
      "parallelizable_steps": [],
      "critical_path_length": "9047μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 2.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 2.0,
        "content_hash": "2aa9d9f41d70a367"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-address-generation.h"
      }
    },
    "source_hash": "5b59621f6e4f"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/ipvlan-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/if_link.h>\n\n#include \"forward.h\"\n\ntypedef enum IPVlanMode {\n        NETDEV_IPVLAN_MODE_L2 = IPVLAN_MODE_L2,\n        NETDEV_IPVLAN_MODE_L3 = IPVLAN_MODE_L3,\n        NETDEV_IPVLAN_MODE_L3S = IPVLAN_MODE_L3S,\n        _NETDEV_IPVLAN_MODE_MAX,\n        _NETDEV_IPVLAN_MODE_INVALID = -EINVAL,\n} IPVlanMode;\n\ntypedef enum IPVlanFlags {\n        NETDEV_IPVLAN_FLAGS_BRIGDE,\n        NETDEV_IPVLAN_FLAGS_PRIVATE = IPVLAN_F_PRIVATE,\n        NETDEV_IPVLAN_FLAGS_VEPA = IPVLAN_F_VEPA,\n        _NETDEV_IPVLAN_FLAGS_MAX,\n        _NETDEV_IPVLAN_FLAGS_INVALID = -EINVAL,\n} IPVlanFlags;\n\nconst char* ipvlan_mode_to_string(IPVlanMode d) _const_;\nIPVlanMode ipvlan_mode_from_string(const char *d) _pure_;\n\nconst char* ipvlan_flags_to_string(IPVlanFlags d) _const_;\nIPVlanFlags ipvlan_flags_from_string(const char *d) _pure_;\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "28μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "219μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "75255μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "452μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "218μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "76172μs",
      "parallelizable_steps": [],
      "critical_path_length": "75501μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 22,
        "complexity_score": 1.3636363636363635
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 22,
        "complexity_score": 1.3636363636363635,
        "content_hash": "c6d82004269d118d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/ipvlan-util.h"
      }
    },
    "source_hash": "d94d28afb8cc"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/sd-dns-resolver.h\n\nCode:\n#ifndef SD_DNS_RESOLVER_H\n#define SD_DNS_RESOLVER_H\n\n#include \"_sd-common.h\"\n\n#include \"forward.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dns_resolver sd_dns_resolver;\n\n/* https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids */\ntypedef enum sd_dns_alpn_flags {\n        /* There isn't really an alpn reserved for Do53 service, but designated resolvers may or may not offer\n         * Do53 service, so we should probably have a flag to represent this capability. Unfortunately DNR\n         * does not indicate the status to us. */\n        SD_DNS_ALPN_DO53           = 1 << 0,\n        /* SD_DNS_ALPN_HTTP_1_1,                \"http/1.1\" [RFC9112] */\n        SD_DNS_ALPN_HTTP_2_TLS     = 1 << 1, /* \"h2\"  [RFC9113] [RFC9461] */\n        /* SD_DNS_ALPN_HTTP_2_TCP,              \"h2c\" [RFC9113] */\n        SD_DNS_ALPN_HTTP_3         = 1 << 2, /* \"h3\"  [RFC9114] [RFC9461] */\n        SD_DNS_ALPN_DOT            = 1 << 3, /* \"dot\" [RFC7858] [RFC9461] */\n        SD_DNS_ALPN_DOQ            = 1 << 4, /* \"doq\" [RFC9250] [RFC9461] */\n\n        _SD_ENUM_FORCE_S64(SD_DNS_ALPN)\n} sd_dns_alpn_flags;\n\nint sd_dns_resolver_get_priority(sd_dns_resolver *res, uint16_t *ret_priority);\nint sd_dns_resolver_get_adn(sd_dns_resolver *res, const char **ret_adn);\nint sd_dns_resolver_get_inet_addresses(sd_dns_resolver *res, const struct in_addr **ret_addrs, size_t *n);\nint sd_dns_resolver_get_inet6_addresses(sd_dns_resolver *res, const struct in6_addr **ret_addrs, size_t *n);\nint sd_dns_resolver_get_alpn(sd_dns_resolver *res, sd_dns_alpn_flags *ret_alpn);\nint sd_dns_resolver_get_port(sd_dns_resolver *res, uint16_t *ret_port);\nint sd_dns_resolver_get_dohpath(sd_dns_resolver *res, const char **ret_dohpath);\n\nsd_dns_resolver *sd_dns_resolver_unref(sd_dns_resolver *res);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dns_resolver, sd_dns_resolver_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif /* SD_DNS_RESOLVER_H */\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "239μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "49μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "205431μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "274101μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "168μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "41μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "480029μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "274191μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 1.935483870967742
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 1.935483870967742,
        "content_hash": "96c4f6e70f8fe2aa"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/sd-dns-resolver.h"
      }
    },
    "source_hash": "0c2717ef1e6d"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/import/import-compress.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#if HAVE_BZIP2\n#include <bzlib.h>\n#endif\n#include <lzma.h>\n#include <zlib.h>\n#if HAVE_ZSTD\n#include <zstd.h>\n#endif\n\n#include \"forward.h\"\n\ntypedef enum ImportCompressType {\n        IMPORT_COMPRESS_UNKNOWN,\n        IMPORT_COMPRESS_UNCOMPRESSED,\n        IMPORT_COMPRESS_XZ,\n        IMPORT_COMPRESS_GZIP,\n        IMPORT_COMPRESS_BZIP2,\n        IMPORT_COMPRESS_ZSTD,\n        _IMPORT_COMPRESS_TYPE_MAX,\n        _IMPORT_COMPRESS_TYPE_INVALID = -EINVAL,\n} ImportCompressType;\n\ntypedef struct ImportCompress {\n        ImportCompressType type;\n        bool encoding;\n        union {\n                lzma_stream xz;\n                z_stream gzip;\n#if HAVE_BZIP2\n                bz_stream bzip2;\n#endif\n#if HAVE_ZSTD\n                ZSTD_CCtx *c_zstd;\n                ZSTD_DCtx *d_zstd;\n#endif\n        };\n} ImportCompress;\n\ntypedef int (*ImportCompressCallback)(const void *data, size_t size, void *userdata);\n\nvoid import_compress_free(ImportCompress *c);\n\nint import_uncompress_detect(ImportCompress *c, const void *data, size_t size);\nvoid import_uncompress_force_off(ImportCompress *c);\nint import_uncompress(ImportCompress *c, const void *data, size_t size, ImportCompressCallback callback, void *userdata);\n\nint import_compress_init(ImportCompress *c, ImportCompressType t);\nint import_compress(ImportCompress *c, const void *data, size_t size, void **buffer, size_t *buffer_size, size_t *buffer_allocated);\nint import_compress_finish(ImportCompress *c, void **buffer, size_t *buffer_size, size_t *buffer_allocated);\n\nconst char* import_compress_type_to_string(ImportCompressType t) _const_;\nImportCompressType import_compress_type_from_string(const char *s) _pure_;\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "58μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "221μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "177160μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "239μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "433μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "178111μs",
      "parallelizable_steps": [],
      "critical_path_length": "177651μs",
      "metadata": {
        "functions_found": [
          "int"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 2.391304347826087
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [
          "int"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 2.391304347826087,
        "content_hash": "d9a7198fba442656"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/import/import-compress.h"
      }
    },
    "source_hash": "148ae7040a9d"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dhcp4-bus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nextern const BusObjectImplementation dhcp_client_object;\n\nint dhcp_client_callback_bus(sd_dhcp_client *client, int event, void *userdata);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "773μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "71μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "311247μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1374μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "692μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "314157μs",
      "parallelizable_steps": [],
      "critical_path_length": "312712μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "411fe068afd8172f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dhcp4-bus.h"
      }
    },
    "source_hash": "7175529837b6"
  },
  {
    "instruction": "Decompose the network operation: QUIC Connection Establishment",
    "input": "Analyze the step-by-step process for: QUIC Connection Establishment",
    "output": {
      "operation": "QUIC Connection Establishment",
      "category": "quic_http3",
      "steps": [
        {
          "step": 1,
          "action": "Generate connection ID and initial keys",
          "expected_time": "695μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Send Initial packet with TLS ClientHello",
          "expected_time": "521409μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Receive and process server Initial packet",
          "expected_time": "257691μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Complete TLS handshake over QUIC",
          "expected_time": "1107μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish 1-RTT protected connection",
          "expected_time": "440091μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1220993μs",
      "parallelizable_steps": [],
      "critical_path_length": "698477μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "quic_http3",
      "complexity": "high",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "a33ba919b2c2"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netfilter/xt_addrtype.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _XT_ADDRTYPE_H\n#define _XT_ADDRTYPE_H\n\n#include <linux/types.h>\n\nenum {\n\tXT_ADDRTYPE_INVERT_SOURCE\t= 0x0001,\n\tXT_ADDRTYPE_INVERT_DEST\t\t= 0x0002,\n\tXT_ADDRTYPE_LIMIT_IFACE_IN\t= 0x0004,\n\tXT_ADDRTYPE_LIMIT_IFACE_OUT\t= 0x0008,\n};\n\n\n/* rtn_type enum values from rtnetlink.h, but shifted */\nenum {\n\tXT_ADDRTYPE_UNSPEC = 1 << 0,\n\tXT_ADDRTYPE_UNICAST = 1 << 1,\t/* 1 << RTN_UNICAST */\n\tXT_ADDRTYPE_LOCAL  = 1 << 2,\t/* 1 << RTN_LOCAL, etc */\n\tXT_ADDRTYPE_BROADCAST = 1 << 3,\n\tXT_ADDRTYPE_ANYCAST = 1 << 4,\n\tXT_ADDRTYPE_MULTICAST = 1 << 5,\n\tXT_ADDRTYPE_BLACKHOLE = 1 << 6,\n\tXT_ADDRTYPE_UNREACHABLE = 1 << 7,\n\tXT_ADDRTYPE_PROHIBIT = 1 << 8,\n\tXT_ADDRTYPE_THROW = 1 << 9,\n\tXT_ADDRTYPE_NAT = 1 << 10,\n\tXT_ADDRTYPE_XRESOLVE = 1 << 11,\n};\n\nstruct xt_addrtype_info_v1 {\n\t__u16\tsource;\t\t/* source-type mask */\n\t__u16\tdest;\t\t/* dest-type mask */\n\t__u32\tflags;\n};\n\n/* revision 0 */\nstruct xt_addrtype_info {\n\t__u16\tsource;\t\t/* source-type mask */\n\t__u16\tdest;\t\t/* dest-type mask */\n\t__u32\tinvert_source;\n\t__u32\tinvert_dest;\n};\n\n#endif\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "298μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "224μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "79345μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "380μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "76μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "80323μs",
      "parallelizable_steps": [],
      "critical_path_length": "79719μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 38,
        "complexity_score": 1.8421052631578947
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 38,
        "complexity_score": 1.8421052631578947,
        "content_hash": "88dc29c096a52d93"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netfilter/xt_addrtype.h"
      }
    },
    "source_hash": "0676cc7c9ac1"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-mdns.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\n#define MDNS_PORT 5353\n#define MDNS_ANNOUNCE_DELAY (1 * USEC_PER_SEC)\n\nint manager_mdns_ipv4_fd(Manager *m);\nint manager_mdns_ipv6_fd(Manager *m);\n\nvoid manager_mdns_stop(Manager *m);\nvoid manager_mdns_maybe_stop(Manager *m);\nint manager_mdns_start(Manager *m);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "287μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "85μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "228683μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "113107μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "124μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "18μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "342304μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "228807μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 2.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 2.0,
        "content_hash": "29fa74257078487a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-mdns.h"
      }
    },
    "source_hash": "42195564cbbe"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/fetch-mkosi.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"\nCheck out mkosi into specified location.\nWith -u, if changed, commit the latest hash.\n\"\"\"\n\nimport argparse\nimport shlex\nimport subprocess\nimport re\nfrom pathlib import Path\n\nURL = 'https://github.com/systemd/mkosi'\nBRANCH = 'main'  # We only want to ever use commits on upstream 'main' branch\nCONFIG = Path('mkosi/mkosi.conf')\nWORKFLOWS = [Path('.github/workflows') / f for f in ['mkosi.yml', 'coverage.yml', 'linter.yml']]\n\ndef parse_args():\n    p = argparse.ArgumentParser(\n        description=__doc__,\n    )\n    p.add_argument(\n        'dir',\n        type=Path,\n    )\n    p.add_argument(\n        '--update', '-u',\n        action='store_true',\n        default=False,\n    )\n    return p.parse_args()\n\ndef read_config():\n    print(f'Reading {CONFIG}…')\n    matches = [m.group(1)\n               for line in open(CONFIG)\n               if (m := re.match('^MinimumVersion=commit:([a-z0-9]{40})$',\n                                 line.strip()))]\n    assert len(matches) == 1\n    return matches[0]\n\ndef commit_file(files: list[Path], commit: str, changes: str):\n    message = '\\n'.join((\n        f'mkosi: update mkosi commit reference to {commit}',\n        '',\n        changes))\n\n    cmd = ['git', 'commit', '-m', message, *(str(file) for file in files)]\n    print(f\"+ {shlex.join(cmd)}\")\n    subprocess.check_call(cmd)\n\ndef checkout_mkosi(args):\n    if args.dir.exists():\n        print(f'{args.dir} already exists.')\n        return\n\n    cmd = [\n        'git', 'clone', URL,\n        f'--branch={BRANCH}',\n        args.dir.as_posix(),\n    ]\n    print(f\"+ {shlex.join(cmd)}\")\n    subprocess.check_call(cmd)\n\ndef update_mkosi(args):\n    old_commit = read_config()\n\n    cmd = ['git', '-C', args.dir.as_posix(), 'rev-parse', f'refs/remotes/origin/{BRANCH}']\n    print(f\"+ {shlex.join(cmd)}\")\n    new_commit = subprocess.check_output(cmd, text=True).strip()\n\n    if old_commit == new_commit:\n        print(f'mkosi: commit {new_commit!s} is still fresh')\n        return\n\n    cmd = ['git', '-C', args.dir.as_posix(), 'log', '--graph', '--first-parent', '--no-merges',\n           '--pretty=oneline', '--no-decorate', '--abbrev-commit', '--abbrev=10',\n           f'{old_commit}..{new_commit}']\n    print(f\"+ {shlex.join(cmd)}\")\n    changes = subprocess.check_output(cmd, text=True).strip()\n\n    for f in [CONFIG, *WORKFLOWS]:\n        s = f.read_text()\n        assert old_commit in s\n        print(f'mkosi: {f}: found old hash, updating…')\n        new = s.replace(old_commit, new_commit)\n        assert new != s\n        f.write_text(new)\n\n    commit_file([CONFIG, *WORKFLOWS], new_commit, changes)\n\nif __name__ == '__main__':\n    args = parse_args()\n    checkout_mkosi(args)\n    if args.update:\n        update_mkosi(args)\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "181μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "92971μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "30μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "820μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "238305μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "528μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "332835μs",
      "parallelizable_steps": [],
      "critical_path_length": "238516μs",
      "metadata": {
        "functions_found": [
          "parse_args",
          "read_config",
          "commit_file",
          "checkout_mkosi",
          "update_mkosi"
        ],
        "classes_found": [],
        "imports": [
          "argparse",
          "shlex",
          "subprocess",
          "re",
          "pathlib"
        ],
        "lines_of_code": 82,
        "complexity_score": 1.5853658536585367
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "parse_args",
          "read_config",
          "commit_file",
          "checkout_mkosi",
          "update_mkosi"
        ],
        "classes": [],
        "imports": [
          "argparse",
          "shlex",
          "subprocess",
          "re",
          "pathlib"
        ],
        "lines_of_code": 82,
        "complexity_score": 1.5853658536585367,
        "content_hash": "235cee2209dab01b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/fetch-mkosi.py"
      }
    },
    "source_hash": "37596dadc94d"
  },
  {
    "instruction": "Examine and structure this proxy_tunneling code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/l2tp-tunnel.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/l2tp.h>\n\n#include \"in-addr-util.h\"\n#include \"forward.h\"\n#include \"netdev.h\"\n\ntypedef enum L2tpL2specType {\n        NETDEV_L2TP_L2SPECTYPE_NONE = L2TP_L2SPECTYPE_NONE,\n        NETDEV_L2TP_L2SPECTYPE_DEFAULT = L2TP_L2SPECTYPE_DEFAULT,\n        _NETDEV_L2TP_L2SPECTYPE_MAX,\n        _NETDEV_L2TP_L2SPECTYPE_INVALID = -EINVAL,\n} L2tpL2specType;\n\ntypedef enum L2tpEncapType {\n        NETDEV_L2TP_ENCAPTYPE_UDP = L2TP_ENCAPTYPE_UDP,\n        NETDEV_L2TP_ENCAPTYPE_IP = L2TP_ENCAPTYPE_IP,\n        _NETDEV_L2TP_ENCAPTYPE_MAX,\n        _NETDEV_L2TP_ENCAPTYPE_INVALID = -EINVAL,\n} L2tpEncapType;\n\ntypedef enum L2tpLocalAddressType {\n        NETDEV_L2TP_LOCAL_ADDRESS_AUTO,\n        NETDEV_L2TP_LOCAL_ADDRESS_STATIC,\n        NETDEV_L2TP_LOCAL_ADDRESS_DYNAMIC,\n        _NETDEV_L2TP_LOCAL_ADDRESS_MAX,\n        _NETDEV_L2TP_LOCAL_ADDRESS_INVALID = -EINVAL,\n} L2tpLocalAddressType;\n\ntypedef struct L2tpTunnel L2tpTunnel;\n\ntypedef struct L2tpSession {\n        L2tpTunnel *tunnel;\n        ConfigSection *section;\n\n        char *name;\n        int ifindex;\n\n        uint32_t session_id;\n        uint32_t peer_session_id;\n        L2tpL2specType l2tp_l2spec_type;\n} L2tpSession;\n\nstruct L2tpTunnel {\n        NetDev meta;\n\n        uint16_t l2tp_udp_sport;\n        uint16_t l2tp_udp_dport;\n\n        uint32_t tunnel_id;\n        uint32_t peer_tunnel_id;\n\n        int family;\n\n        bool udp_csum;\n        bool udp6_csum_rx;\n        bool udp6_csum_tx;\n\n        char *local_ifname;\n        L2tpLocalAddressType local_address_type;\n        union in_addr_union local;\n        union in_addr_union remote;\n\n        L2tpEncapType l2tp_encap_type;\n\n        OrderedHashmap *sessions_by_section;\n};\n\nDEFINE_NETDEV_CAST(L2TP, L2tpTunnel);\nextern const NetDevVTable l2tptnl_vtable;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_tunnel_local_address);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_tunnel_remote_address);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_tunnel_id);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_encap_type);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_session_l2spec);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_session_id);\nCONFIG_PARSER_PROTOTYPE(config_parse_l2tp_session_name);\n",
    "output": {
      "operation": "Proxy Tunneling Implementation",
      "category": "proxy_tunneling",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "54μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "108μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "52881μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "195μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "69μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "53307μs",
      "parallelizable_steps": [],
      "critical_path_length": "53004μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 0.6557377049180328
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "proxy_tunneling",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 0.6557377049180328,
        "content_hash": "b9e1e1b49471b218"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/l2tp-tunnel.h"
      },
      "variation": true
    },
    "source_hash": "e2c17168f51f"
  },
  {
    "instruction": "Decompose and explain this proxy_tunneling code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/ip6_tunnel.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _IP6_TUNNEL_H\n#define _IP6_TUNNEL_H\n\n#include <linux/types.h>\n#include <linux/if.h>\t\t/* For IFNAMSIZ. */\n#include <linux/in6.h>\t\t/* For struct in6_addr. */\n\n#define IPV6_TLV_TNL_ENCAP_LIMIT 4\n#define IPV6_DEFAULT_TNL_ENCAP_LIMIT 4\n\n/* don't add encapsulation limit if one isn't present in inner packet */\n#define IP6_TNL_F_IGN_ENCAP_LIMIT 0x1\n/* copy the traffic class field from the inner packet */\n#define IP6_TNL_F_USE_ORIG_TCLASS 0x2\n/* copy the flowlabel from the inner packet */\n#define IP6_TNL_F_USE_ORIG_FLOWLABEL 0x4\n/* being used for Mobile IPv6 */\n#define IP6_TNL_F_MIP6_DEV 0x8\n/* copy DSCP from the outer packet */\n#define IP6_TNL_F_RCV_DSCP_COPY 0x10\n/* copy fwmark from inner packet */\n#define IP6_TNL_F_USE_ORIG_FWMARK 0x20\n/* allow remote endpoint on the local node */\n#define IP6_TNL_F_ALLOW_LOCAL_REMOTE 0x40\n\nstruct ip6_tnl_parm {\n\tchar name[IFNAMSIZ];\t/* name of tunnel device */\n\tint link;\t\t/* ifindex of underlying L2 interface */\n\t__u8 proto;\t\t/* tunnel protocol */\n\t__u8 encap_limit;\t/* encapsulation limit for tunnel */\n\t__u8 hop_limit;\t\t/* hop limit for tunnel */\n\t__be32 flowinfo;\t/* traffic class and flowlabel for tunnel */\n\t__u32 flags;\t\t/* tunnel flags */\n\tstruct in6_addr laddr;\t/* local tunnel end-point address */\n\tstruct in6_addr raddr;\t/* remote tunnel end-point address */\n};\n\nstruct ip6_tnl_parm2 {\n\tchar name[IFNAMSIZ];\t/* name of tunnel device */\n\tint link;\t\t/* ifindex of underlying L2 interface */\n\t__u8 proto;\t\t/* tunnel protocol */\n\t__u8 encap_limit;\t/* encapsulation limit for tunnel */\n\t__u8 hop_limit;\t\t/* hop limit for tunnel */\n\t__be32 flowinfo;\t/* traffic class and flowlabel for tunnel */\n\t__u32 flags;\t\t/* tunnel flags */\n\tstruct in6_addr laddr;\t/* local tunnel end-point address */\n\tstruct in6_addr raddr;\t/* remote tunnel end-point address */\n\n\t__be16\t\t\ti_flags;\n\t__be16\t\t\to_flags;\n\t__be32\t\t\ti_key;\n\t__be32\t\t\to_key;\n};\n\n#endif\n",
    "output": {
      "operation": "Proxy Tunneling Implementation",
      "category": "proxy_tunneling",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "699μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "354μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "278960μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "1360μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "722μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "282095μs",
      "parallelizable_steps": [],
      "critical_path_length": "280381μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 4.081632653061225
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "proxy_tunneling",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 4.081632653061225,
        "content_hash": "e8dec4d84ffc451e"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/ip6_tunnel.h"
      },
      "variation": true
    },
    "source_hash": "0455d85c824e"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/chid-fundamental.h\n\nCode:\n/* SPDX-License-Identifier: BSD-3-Clause */\n\n#pragma once\n\n#if SD_BOOT\n#  include \"efi.h\"\n#else\n#  include <uchar.h>\n#endif\n\n#include \"efi-fundamental.h\"\n\n#define CHID_TYPES_MAX 18\n/* Any chids starting from EXTRA_CHID_BASE are non-standard and are subject to change and renumeration at any time */\n#define EXTRA_CHID_BASE 15\n\ntypedef enum ChidSmbiosFields {\n        CHID_SMBIOS_MANUFACTURER,\n        CHID_SMBIOS_FAMILY,\n        CHID_SMBIOS_PRODUCT_NAME,\n        CHID_SMBIOS_PRODUCT_SKU,\n        CHID_SMBIOS_BASEBOARD_MANUFACTURER,\n        CHID_SMBIOS_BASEBOARD_PRODUCT,\n        CHID_SMBIOS_BIOS_VENDOR,\n        CHID_SMBIOS_BIOS_VERSION,\n        CHID_SMBIOS_BIOS_MAJOR,\n        CHID_SMBIOS_BIOS_MINOR,\n        CHID_SMBIOS_ENCLOSURE_TYPE,\n        CHID_EDID_PANEL,\n        _CHID_SMBIOS_FIELDS_MAX,\n} ChidSmbiosFields;\n\nextern const uint32_t chid_smbios_table[CHID_TYPES_MAX];\n\n/* CHID (also called HWID by fwupd) is described at https://github.com/fwupd/fwupd/blob/main/docs/hwids.md */\nvoid chid_calculate(const char16_t *const smbios_fields[static _CHID_SMBIOS_FIELDS_MAX], EFI_GUID ret_chids[static CHID_TYPES_MAX]);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "187μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "402899μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "433μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "618μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "63633μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "48μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "467818μs",
      "parallelizable_steps": [],
      "critical_path_length": "403565μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 29,
        "complexity_score": 1.0344827586206897
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 29,
        "complexity_score": 1.0344827586206897,
        "content_hash": "073683b4231e8278"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/chid-fundamental.h"
      }
    },
    "source_hash": "a9acf5413aa1"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dhcp6.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\ntypedef enum DHCP6ClientStartMode {\n        DHCP6_CLIENT_START_MODE_NO,\n        DHCP6_CLIENT_START_MODE_INFORMATION_REQUEST,\n        DHCP6_CLIENT_START_MODE_SOLICIT,\n        _DHCP6_CLIENT_START_MODE_MAX,\n        _DHCP6_CLIENT_START_MODE_INVALID = -EINVAL,\n} DHCP6ClientStartMode;\n\nbool link_dhcp6_with_address_enabled(Link *link);\nint dhcp6_check_ready(Link *link);\nint dhcp6_update_mac(Link *link);\nint dhcp6_start(Link *link);\nint dhcp6_start_on_ra(Link *link, bool information_request);\n\nint link_request_dhcp6_client(Link *link);\nint link_drop_dhcp6_config(Link *link, Network *network);\n\nint link_serialize_dhcp6_client(Link *link, FILE *f);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp6_pd_prefix_hint);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp6_mud_url);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp6_client_start_mode);\n\nconst char* dhcp6_client_start_mode_to_string(DHCP6ClientStartMode i) _const_;\nDHCP6ClientStartMode dhcp6_client_start_mode_from_string(const char *s) _pure_;\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "297μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "121μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "156525μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "390μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "327μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "157660μs",
      "parallelizable_steps": [],
      "critical_path_length": "157149μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 23,
        "complexity_score": 2.1739130434782608
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 23,
        "complexity_score": 2.1739130434782608,
        "content_hash": "b8b1316e9511fe4f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dhcp6.h"
      }
    },
    "source_hash": "5f1ed1b29b56"
  },
  {
    "instruction": "Decompose the network operation: QUIC Connection Establishment",
    "input": "Analyze the step-by-step process for: QUIC Connection Establishment",
    "output": {
      "operation": "QUIC Connection Establishment",
      "category": "quic_http3",
      "steps": [
        {
          "step": 1,
          "action": "Generate connection ID and initial keys",
          "expected_time": "695μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Send Initial packet with TLS ClientHello",
          "expected_time": "521409μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Receive and process server Initial packet",
          "expected_time": "257691μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Complete TLS handshake over QUIC",
          "expected_time": "1107μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish 1-RTT protected connection",
          "expected_time": "440091μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1220993μs",
      "parallelizable_steps": [],
      "critical_path_length": "698477μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "quic_http3",
      "complexity": "high",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "a33ba919b2c2"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/rm-rf.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum RemoveFlags {\n        REMOVE_ONLY_DIRECTORIES = 1 << 0, /* Only remove empty directories, no files */\n        REMOVE_ROOT             = 1 << 1, /* Remove the specified directory itself too, not just the contents of it */\n        REMOVE_PHYSICAL         = 1 << 2, /* If not set, only removes files on tmpfs, never physical file systems */\n        REMOVE_SUBVOLUME        = 1 << 3, /* Drop btrfs subvolumes in the tree too */\n        REMOVE_MISSING_OK       = 1 << 4, /* If the top-level directory is missing, ignore the ENOENT for it */\n        REMOVE_CHMOD            = 1 << 5, /* chmod() for write access if we cannot delete or access something */\n        REMOVE_CHMOD_RESTORE    = 1 << 6, /* Restore the old mode before returning */\n        REMOVE_SYNCFS           = 1 << 7, /* syncfs() the root of the specified directory after removing everything in it */\n} RemoveFlags;\n\nint unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags);\nint fstatat_harder(int dfd,\n                const char *filename,\n                struct stat *ret,\n                int fstatat_flags,\n                RemoveFlags remove_flags);\n\n/* Note: directory file descriptors passed to the functions below must be\n * positioned at the beginning. If the fd was already used for reading, rewind it. */\nint rm_rf_children(int fd, RemoveFlags flags, const struct stat *root_dev);\nint rm_rf_child(int fd, const char *name, RemoveFlags flags);\nint rm_rf_at(int dir_fd, const char *path, RemoveFlags flags);\nstatic inline int rm_rf(const char *path, RemoveFlags flags) {\n        return rm_rf_at(AT_FDCWD, path, flags);\n}\n\n/* Useful for using with _cleanup_(), destroys a directory on a temporary file system. */\nconst char* rm_rf_safe(const char *p);\nDEFINE_TRIVIAL_CLEANUP_FUNC(const char*, rm_rf_safe);\n\n/* Similar as above, but allow to destroy a directory on a physical file system, and also frees the pointer. */\nchar* rm_rf_physical_and_free(char *p);\nDEFINE_TRIVIAL_CLEANUP_FUNC(char*, rm_rf_physical_and_free);\n\n/* Similar as above, but also has magic btrfs subvolume powers. */\nchar* rm_rf_subvolume_and_free(char *p);\nDEFINE_TRIVIAL_CLEANUP_FUNC(char*, rm_rf_subvolume_and_free);\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "670μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "280μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "581363μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "320262μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "204064μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "507550μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "9657μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "300μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1624146μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "828392μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.888888888888889
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.888888888888889,
        "content_hash": "05c79377113d25c7"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/rm-rf.h"
      }
    },
    "source_hash": "cb9667ad2f7b"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-wall.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"format-util.h\"\n#include \"journald-manager.h\"\n#include \"journald-wall.h\"\n#include \"log.h\"\n#include \"process-util.h\"\n#include \"string-util.h\"\n#include \"wall.h\"\n\nvoid manager_forward_wall(\n                Manager *m,\n                int priority,\n                const char *identifier,\n                const char *message,\n                const struct ucred *ucred) {\n\n        _cleanup_free_ char *ident_buf = NULL, *l_buf = NULL;\n        const char *l;\n        int r;\n\n        assert(m);\n        assert(message);\n\n        if (LOG_PRI(priority) > m->config.max_level_wall)\n                return;\n\n        if (ucred) {\n                if (!identifier) {\n                        (void) pid_get_comm(ucred->pid, &ident_buf);\n                        identifier = ident_buf;\n                }\n\n                if (asprintf(&l_buf, \"%s[\"PID_FMT\"]: %s\", strempty(identifier), ucred->pid, message) < 0) {\n                        log_oom();\n                        return;\n                }\n\n                l = l_buf;\n\n        } else if (identifier) {\n\n                l = l_buf = strjoin(identifier, \": \", message);\n                if (!l_buf) {\n                        log_oom();\n                        return;\n                }\n        } else\n                l = message;\n\n        r = wall(l, \"systemd-journald\", NULL, NULL, NULL);\n        if (r < 0)\n                log_debug_errno(r, \"Failed to send wall message: %m\");\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "559μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "358μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "695695μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "541306μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "246196μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "398368μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1882770μs",
      "parallelizable_steps": [],
      "critical_path_length": "942738μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 44,
        "complexity_score": 3.6363636363636367
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 44,
        "complexity_score": 3.6363636363636367,
        "content_hash": "9c3a0908359657e9"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-wall.c"
      }
    },
    "source_hash": "7a534a913d45"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/wireguard.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#include <linux/wireguard.h>\n\n#include \"in-addr-util.h\"\n#include \"list.h\"\n#include \"netdev.h\"\n#include \"networkd-forward.h\"\n#include \"socket-util.h\"\n\ntypedef struct WireguardIPmask {\n        uint16_t family;\n        union in_addr_union ip;\n        uint8_t cidr;\n\n        LIST_FIELDS(struct WireguardIPmask, ipmasks);\n} WireguardIPmask;\n\ntypedef struct WireguardPeer {\n        Wireguard *wireguard;\n        ConfigSection *section;\n\n        uint8_t public_key[WG_KEY_LEN];\n        uint8_t preshared_key[WG_KEY_LEN];\n        char *public_key_file;\n        char *preshared_key_file;\n        uint32_t flags;\n        uint16_t persistent_keepalive_interval;\n\n        union sockaddr_union endpoint;\n        char *endpoint_host;\n        char *endpoint_port;\n\n        unsigned n_retries;\n        sd_event_source *resolve_retry_event_source;\n        sd_resolve_query *resolve_query;\n\n        uint32_t route_table;\n        uint32_t route_priority;\n        bool route_table_set;\n        bool route_priority_set;\n\n        LIST_HEAD(WireguardIPmask, ipmasks);\n        LIST_FIELDS(struct WireguardPeer, peers);\n} WireguardPeer;\n\ntypedef struct Wireguard {\n        NetDev meta;\n        unsigned last_peer_section;\n\n        uint32_t flags;\n        uint8_t private_key[WG_KEY_LEN];\n        char *private_key_file;\n        uint16_t port;\n        uint32_t fwmark;\n\n        Hashmap *peers_by_section;\n        LIST_HEAD(WireguardPeer, peers);\n\n        Set *routes;\n        uint32_t route_table;\n        uint32_t route_priority;\n} Wireguard;\n\nDEFINE_NETDEV_CAST(WIREGUARD, Wireguard);\nextern const NetDevVTable wireguard_vtable;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_allowed_ips);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_endpoint);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_listen_port);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_key);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_key_file);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_private_key);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_private_key_file);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_keepalive);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_route_table);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_route_table);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_route_priority);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_route_priority);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "61μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "31μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "11058μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "69460μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "24372μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "52374μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "16μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "157372μs",
      "parallelizable_steps": [],
      "critical_path_length": "121865μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 64,
        "complexity_score": 0.46875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 64,
        "complexity_score": 0.46875,
        "content_hash": "8e3a9d64bdf9ac02"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/wireguard.h"
      }
    },
    "source_hash": "707fac047607"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ipv4acd.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdipv4acdfoo\n#define foosdipv4acdfoo\n\n/***\n  Copyright © 2014 Axis Communications AB. All rights reserved.\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include <stdbool.h>\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in_addr;\n\ntypedef struct sd_event sd_event;\n\nenum {\n        SD_IPV4ACD_EVENT_STOP           = 0,\n        SD_IPV4ACD_EVENT_BIND           = 1,\n        SD_IPV4ACD_EVENT_CONFLICT       = 2\n};\n\ntypedef struct sd_ipv4acd sd_ipv4acd;\ntypedef void (*sd_ipv4acd_callback_t)(sd_ipv4acd *acd, int event, void *userdata);\ntypedef int (*sd_ipv4acd_check_mac_callback_t)(sd_ipv4acd *acd, const struct ether_addr *mac, void *userdata);\n\nint sd_ipv4acd_detach_event(sd_ipv4acd *acd);\nint sd_ipv4acd_attach_event(sd_ipv4acd *acd, sd_event *event, int64_t priority);\nint sd_ipv4acd_get_address(sd_ipv4acd *acd, struct in_addr *address);\nint sd_ipv4acd_set_callback(sd_ipv4acd *acd, sd_ipv4acd_callback_t cb, void *userdata);\nint sd_ipv4acd_set_check_mac_callback(sd_ipv4acd *acd, sd_ipv4acd_check_mac_callback_t cb, void *userdata);\nint sd_ipv4acd_set_mac(sd_ipv4acd *acd, const struct ether_addr *addr);\nint sd_ipv4acd_set_ifindex(sd_ipv4acd *acd, int interface_index);\nint sd_ipv4acd_get_ifindex(sd_ipv4acd *acd);\nint sd_ipv4acd_set_ifname(sd_ipv4acd *acd, const char *interface_name);\nint sd_ipv4acd_get_ifname(sd_ipv4acd *acd, const char **ret);\nint sd_ipv4acd_set_timeout(sd_ipv4acd *acd, uint64_t usec);\nint sd_ipv4acd_set_address(sd_ipv4acd *acd, const struct in_addr *address);\nint sd_ipv4acd_is_running(sd_ipv4acd *acd);\nint sd_ipv4acd_is_bound(sd_ipv4acd *acd);\n__extension__ int sd_ipv4acd_start(sd_ipv4acd *acd, bool reset_conflicts);\nint sd_ipv4acd_stop(sd_ipv4acd *acd);\nsd_ipv4acd *sd_ipv4acd_ref(sd_ipv4acd *acd);\nsd_ipv4acd *sd_ipv4acd_unref(sd_ipv4acd *acd);\nint sd_ipv4acd_new(sd_ipv4acd **ret);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ipv4acd, sd_ipv4acd_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "280μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "419660μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1587μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "753μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "138285μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "14μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "560579μs",
      "parallelizable_steps": [],
      "critical_path_length": "420427μs",
      "metadata": {
        "functions_found": [
          "void",
          "int"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "void",
          "int"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692,
        "content_hash": "6c5b123d2de34cd3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ipv4acd.h"
      }
    },
    "source_hash": "f11fc9d999da"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/fuzz-resource-record.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-json.h\"\n\n#include \"fuzz.h\"\n#include \"memstream-util.h\"\n#include \"resolved-dns-packet.h\"\n#include \"resolved-dns-rr.h\"\n#include \"string-util.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *rr = NULL, *copy = NULL;\n        _cleanup_(sd_json_variant_unrefp) sd_json_variant *v = NULL;\n        _cleanup_(memstream_done) MemStream m = {};\n        FILE *f;\n\n        if (outside_size_range(size, 0, DNS_PACKET_SIZE_MAX))\n                return 0;\n\n        if (dns_resource_record_new_from_raw(&rr, data, size) < 0)\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(copy = dns_resource_record_copy(rr));\n        assert_se(dns_resource_record_equal(copy, rr) > 0);\n\n        assert_se(f = memstream_init(&m));\n        (void) fprintf(f, \"%s\", strna(dns_resource_record_to_string(rr)));\n\n        assert_se(dns_resource_record_to_json(rr, &v) >= 0);\n        assert_se(sd_json_variant_dump(v, SD_JSON_FORMAT_PRETTY|SD_JSON_FORMAT_COLOR|SD_JSON_FORMAT_SOURCE, f, NULL) >= 0);\n        assert_se(dns_resource_record_to_wire_format(rr, false) >= 0);\n        assert_se(dns_resource_record_to_wire_format(rr, true) >= 0);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "202μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "42μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "74634μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "465929μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "239μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "18μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "541064μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "465989μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 2.962962962962963
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 2.962962962962963,
        "content_hash": "d8facec6ec36a0e1"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/fuzz-resource-record.c"
      }
    },
    "source_hash": "b6f9a52fafed"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/bless-boot/boot-check-no-failures.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <getopt.h>\n#include <stdio.h>\n\n#include \"sd-bus.h\"\n\n#include \"alloc-util.h\"\n#include \"build.h\"\n#include \"bus-error.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"pretty-print.h\"\n\nstatic int help(void) {\n        _cleanup_free_ char *link = NULL;\n        int r;\n\n        r = terminal_urlify_man(\"systemd-boot-check-no-failures.service\", \"8\", &link);\n        if (r < 0)\n                return log_oom();\n\n        printf(\"%s [OPTIONS...]\\n\"\n               \"\\n%sVerify system operational state.%s\\n\\n\"\n               \"  -h --help          Show this help\\n\"\n               \"     --version       Print version\\n\"\n               \"\\nSee the %s for details.\\n\",\n               program_invocation_short_name,\n               ansi_highlight(),\n               ansi_normal(),\n               link);\n\n        return 0;\n}\n\nstatic int parse_argv(int argc, char *argv[]) {\n        enum {\n                ARG_PATH = 0x100,\n                ARG_VERSION,\n        };\n\n        static const struct option options[] = {\n                { \"help\",         no_argument,       NULL, 'h'              },\n                { \"version\",      no_argument,       NULL, ARG_VERSION      },\n                {}\n        };\n\n        int c;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        while ((c = getopt_long(argc, argv, \"h\", options, NULL)) >= 0)\n                switch (c) {\n\n                case 'h':\n                        help();\n                        return 0;\n\n                case ARG_VERSION:\n                        return version();\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached();\n                }\n\n        return 1;\n}\n\nstatic int run(int argc, char *argv[]) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        uint32_t n;\n        int r;\n\n        log_setup();\n\n        r = parse_argv(argc, argv);\n        if (r <= 0)\n                return r;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to connect to system bus: %m\");\n\n        r = sd_bus_get_property_trivial(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"NFailedUnits\",\n                        &error,\n                        'u',\n                        &n);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get failed units counter: %s\", bus_error_message(&error, r));\n\n        if (n > 0)\n                log_notice(\"Health check: %\" PRIu32 \" units have failed.\", n);\n        else\n                log_info(\"Health check: no failed units.\");\n\n        return n > 0;\n}\n\nDEFINE_MAIN_FUNCTION_WITH_POSITIVE_FAILURE(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "214μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "59μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "27663μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "159952μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "222877μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "228515μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "173μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "639453μs",
      "parallelizable_steps": [],
      "critical_path_length": "388526μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 84,
        "complexity_score": 1.3095238095238095
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 84,
        "complexity_score": 1.3095238095238095,
        "content_hash": "3db66b40239cc8ca"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/bless-boot/boot-check-no-failures.c"
      }
    },
    "source_hash": "172cb49c776f"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/oom/oomd-manager.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"conf-parser-forward.h\"\n#include \"forward.h\"\n#include \"oomd-util.h\"\n\n/* Polling interval for monitoring stats */\n#define SWAP_INTERVAL_USEC 150000 /* 0.15 seconds */\n/* Pressure counters are lagging (~2 seconds) compared to swap so polling too frequently just wastes CPU */\n#define MEM_PRESSURE_INTERVAL_USEC (1 * USEC_PER_SEC)\n\n/* Take action if 10s of memory pressure > 60 for more than 30s. We use the \"full\" value from PSI so this is the\n * percentage of time all tasks were delayed (i.e. unproductive).\n * Generally 60 or higher might be acceptable for something like system.slice with no memory.high set; processes in\n * system.slice are assumed to be less latency sensitive. */\n#define DEFAULT_MEM_PRESSURE_DURATION_USEC (30 * USEC_PER_SEC)\n#define DEFAULT_MEM_PRESSURE_LIMIT_PERCENT 60\n#define DEFAULT_SWAP_USED_LIMIT_PERCENT 90\n\n/* Only tackle candidates with large swap usage. */\n#define THRESHOLD_SWAP_USED_PERCENT 5\n\n#define RECLAIM_DURATION_USEC (30 * USEC_PER_SEC)\n#define POST_ACTION_DELAY_USEC (15 * USEC_PER_SEC)\n\ntypedef struct Manager {\n        sd_bus *bus;\n        sd_event *event;\n\n        Hashmap *polkit_registry;\n\n        bool dry_run;\n        int swap_used_limit_permyriad;\n        loadavg_t default_mem_pressure_limit;\n        usec_t default_mem_pressure_duration_usec;\n\n        /* k: cgroup paths -> v: OomdCGroupContext\n         * Used to detect when to take action. */\n        Hashmap *monitored_swap_cgroup_contexts;\n        Hashmap *monitored_mem_pressure_cgroup_contexts;\n        Hashmap *monitored_mem_pressure_cgroup_contexts_candidates;\n\n        OomdSystemContext system_context;\n\n        usec_t mem_pressure_post_action_delay_start;\n\n        sd_event_source *swap_context_event_source;\n        sd_event_source *mem_pressure_context_event_source;\n\n        /* This varlink object is used to manage the subscription from systemd-oomd to PID1 which it uses to\n         * listen for changes in ManagedOOM settings (oomd client - systemd server). */\n        sd_varlink *varlink_client;\n        /* This varlink server object is used to manage systemd-oomd's varlink server which is used by user\n         * managers to report changes in ManagedOOM settings (oomd server - systemd client). */\n        sd_varlink_server *varlink_server;\n} Manager;\n\nManager* manager_free(Manager *m);\nDEFINE_TRIVIAL_CLEANUP_FUNC(Manager*, manager_free);\n\nint manager_new(Manager **ret);\n\nint manager_start(Manager *m, bool dry_run, int fd);\n\nint manager_get_dump_string(Manager *m, char **ret);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_oomd_default);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "150μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "285μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "181781μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "189μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "200μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "182605μs",
      "parallelizable_steps": [],
      "critical_path_length": "182131μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.2
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.2,
        "content_hash": "3c42c1f322532bfa"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/oom/oomd-manager.h"
      }
    },
    "source_hash": "6cc60aad36c3"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-lldp-tx.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdlldptxhfoo\n#define foosdlldptxhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n#include \"sd-json.h\"\n#include \"sd-lldp.h\"    /* IWYU pragma: export*/\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\n\ntypedef struct sd_event sd_event;\ntypedef struct sd_lldp_tx sd_lldp_tx;\n\n__extension__ typedef enum _SD_ENUM_TYPE_S64(sd_lldp_multicast_mode_t) {\n        SD_LLDP_MULTICAST_MODE_NEAREST_BRIDGE,\n        SD_LLDP_MULTICAST_MODE_NON_TPMR_BRIDGE,\n        SD_LLDP_MULTICAST_MODE_CUSTOMER_BRIDGE,\n        _SD_LLDP_MULTICAST_MODE_MAX,\n        _SD_LLDP_MULTICAST_MODE_INVALID = -EINVAL,\n        _SD_ENUM_FORCE_S64(LLDP_TX_MODE)\n} sd_lldp_multicast_mode_t;\n\nint sd_lldp_tx_new(sd_lldp_tx **ret);\nsd_lldp_tx *sd_lldp_tx_ref(sd_lldp_tx *lldp_tx);\nsd_lldp_tx *sd_lldp_tx_unref(sd_lldp_tx *lldp_tx);\n\nint sd_lldp_tx_start(sd_lldp_tx *lldp_tx);\nint sd_lldp_tx_stop(sd_lldp_tx *lldp_tx);\nint sd_lldp_tx_is_running(sd_lldp_tx *lldp_tx);\n\nint sd_lldp_tx_attach_event(sd_lldp_tx *lldp_tx, sd_event *event, int64_t priority);\nint sd_lldp_tx_detach_event(sd_lldp_tx *lldp_tx);\n\nint sd_lldp_tx_set_ifindex(sd_lldp_tx *lldp_tx, int ifindex);\nint sd_lldp_tx_set_ifname(sd_lldp_tx *lldp_tx, const char *ifname);\nint sd_lldp_tx_get_ifname(sd_lldp_tx *lldp_tx, const char **ret);\n\nint sd_lldp_tx_set_multicast_mode(sd_lldp_tx *lldp_tx, sd_lldp_multicast_mode_t mode);\nint sd_lldp_tx_set_hwaddr(sd_lldp_tx *lldp_tx, const struct ether_addr *hwaddr);\nint sd_lldp_tx_set_port_description(sd_lldp_tx *lldp_tx, const char *port_description);\nint sd_lldp_tx_set_hostname(sd_lldp_tx *lldp_tx, const char *hostname);\nint sd_lldp_tx_set_pretty_hostname(sd_lldp_tx *lldp_tx, const char *pretty_hostname);\nint sd_lldp_tx_set_capabilities(sd_lldp_tx *lldp_tx, uint16_t supported, uint16_t enabled);\nint sd_lldp_tx_set_mud_url(sd_lldp_tx *lldp_tx, const char *mud_url);\nint sd_lldp_tx_set_vlan_id(sd_lldp_tx *lldp_tx, uint16_t vlan_id);\n\nint sd_lldp_tx_describe(sd_lldp_tx *lldp_tx, sd_json_variant **ret);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_lldp_tx, sd_lldp_tx_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "28μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "525μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "153296μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "124μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "526μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "154499μs",
      "parallelizable_steps": [],
      "critical_path_length": "153850μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 3.0188679245283017
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 3.0188679245283017,
        "content_hash": "199c1ffa89d04454"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-lldp-tx.h"
      }
    },
    "source_hash": "7a6c5d8cb1bb"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/automount.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"core-forward.h\"\n#include \"unit.h\"\n\ntypedef enum AutomountResult {\n        AUTOMOUNT_SUCCESS,\n        AUTOMOUNT_FAILURE_RESOURCES,\n        AUTOMOUNT_FAILURE_UNMOUNTED,\n        AUTOMOUNT_FAILURE_START_LIMIT_HIT,\n        AUTOMOUNT_FAILURE_MOUNT_START_LIMIT_HIT,\n        _AUTOMOUNT_RESULT_MAX,\n        _AUTOMOUNT_RESULT_INVALID = -EINVAL,\n} AutomountResult;\n\ntypedef struct Automount {\n        Unit meta;\n\n        AutomountState state, deserialized_state;\n\n        char *where;\n        char *extra_options;\n        usec_t timeout_idle_usec;\n\n        int pipe_fd;\n        sd_event_source *pipe_event_source;\n        mode_t directory_mode;\n        dev_t dev_id;\n\n        Set *tokens;\n        Set *expire_tokens;\n\n        sd_event_source *expire_event_source;\n\n        AutomountResult result;\n} Automount;\n\nextern const UnitVTable automount_vtable;\n\nconst char* automount_result_to_string(AutomountResult i) _const_;\nAutomountResult automount_result_from_string(const char *s) _pure_;\n\nDEFINE_CAST(AUTOMOUNT, Automount);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "52μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "52μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "34978μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "174μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "93μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "35349μs",
      "parallelizable_steps": [],
      "critical_path_length": "35123μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 0.625
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 0.625,
        "content_hash": "42e0d55bae0ea64f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/automount.h"
      }
    },
    "source_hash": "c29a485ac01d"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-sysctl-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/socket.h>\n#include <sys/utsname.h>\n\n#include \"sd-id128.h\"\n\n#include \"errno-util.h\"\n#include \"strv.h\"\n#include \"sysctl-util.h\"\n#include \"tests.h\"\n\nstatic const char* const cases[] = {\n        \"a.b.c\", \"a/b/c\",\n        \"a/b/c\", \"a/b/c\",\n        \"a/b.c/d\", \"a/b.c/d\",\n        \"a.b/c.d\", \"a/b.c/d\",\n\n        \"net.ipv4.conf.enp3s0/200.forwarding\", \"net/ipv4/conf/enp3s0.200/forwarding\",\n        \"net/ipv4/conf/enp3s0.200/forwarding\", \"net/ipv4/conf/enp3s0.200/forwarding\",\n\n        \"a...b...c\", \"a/b/c\",\n        \"a///b///c\", \"a/b/c\",\n        \".a...b...c\", \"a/b/c\",\n        \"/a///b///c\", \"a/b/c\",\n        NULL,\n};\n\nTEST(sysctl_normalize) {\n        STRV_FOREACH_PAIR(s, expected, cases) {\n                _cleanup_free_ char *t;\n\n                assert_se(t = strdup(*s));\n                assert_se(sysctl_normalize(t) == t);\n\n                log_info(\"\\\"%s\\\" → \\\"%s\\\", expected \\\"%s\\\"\", *s, t, *expected);\n                ASSERT_STREQ(t, *expected);\n        }\n}\n\nTEST(sysctl_read) {\n        _cleanup_free_ char *s = NULL;\n        struct utsname u;\n        sd_id128_t a, b;\n        int r;\n\n        assert_se(sysctl_read(\"kernel/random/boot_id\", &s) >= 0);\n        assert_se(sd_id128_from_string(s, &a) >= 0);\n        assert_se(sd_id128_get_boot(&b) >= 0);\n        assert_se(sd_id128_equal(a, b));\n        s = mfree(s);\n\n        assert_se(sysctl_read_ip_property(AF_INET, \"lo\", \"forwarding\", &s));\n        assert_se(STR_IN_SET(s, \"0\", \"1\"));\n\n        r = sysctl_write_ip_property(AF_INET, \"lo\", \"forwarding\", s, NULL);\n        assert_se(r >= 0 || ERRNO_IS_NEG_FS_WRITE_REFUSED(r));\n        s = mfree(s);\n\n        assert_se(sysctl_read_ip_property(AF_INET, NULL, \"ip_forward\", &s));\n        assert_se(STR_IN_SET(s, \"0\", \"1\"));\n\n        r = sysctl_write_ip_property(AF_INET, NULL, \"ip_forward\", s, NULL);\n        assert_se(r >= 0 || ERRNO_IS_NEG_FS_WRITE_REFUSED(r));\n        s = mfree(s);\n\n        assert_se(sysctl_read(\"kernel/hostname\", &s) >= 0);\n        assert_se(uname(&u) >= 0);\n        ASSERT_STREQ(s, u.nodename);\n\n        r = sysctl_write(\"kernel/hostname\", s);\n        assert_se(r >= 0 || ERRNO_IS_NEG_FS_WRITE_REFUSED(r));\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "6μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "58μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "339126μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "77004μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "105738μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "234922μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "179μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "757033μs",
      "parallelizable_steps": [],
      "critical_path_length": "445049μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.7543859649122806
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.7543859649122806,
        "content_hash": "3aeba7d482f91106"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-sysctl-util.c"
      }
    },
    "source_hash": "b50d5359a732"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/id128-print.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdio.h>\n\n#include \"sd-id128.h\"\n\n#include \"alloc-util.h\"\n#include \"id128-print.h\"\n#include \"log.h\"\n#include \"pretty-print.h\"\n\nint id128_pretty_print_sample(const char *name, sd_id128_t id) {\n        _cleanup_free_ char *man_link = NULL, *mod_link = NULL;\n\n        const char *on = ansi_highlight(),\n                   *off = ansi_normal();\n\n        if (terminal_urlify(\"man:systemd-id128(1)\", \"systemd-id128(1)\", &man_link) < 0)\n                return log_oom();\n\n        if (terminal_urlify(\"https://docs.python.org/3/library/uuid.html\", \"uuid\", &mod_link) < 0)\n                return log_oom();\n\n        printf(\"As string:\\n\"\n               \"%s\" SD_ID128_FORMAT_STR \"%s\\n\\n\"\n               \"As UUID:\\n\"\n               \"%s\" SD_ID128_UUID_FORMAT_STR \"%s\\n\\n\"\n               \"As %s macro:\\n\"\n               \"%s#define %s SD_ID128_MAKE(\",\n               on, SD_ID128_FORMAT_VAL(id), off,\n               on, SD_ID128_FORMAT_VAL(id), off,\n               man_link,\n               on, name);\n        for (size_t i = 0; i < 16; i++)\n                printf(\"%02x%s\", id.bytes[i], i < 15 ? \",\" : \"\");\n        printf(\")%s\\n\\n\", off);\n\n        printf(\"As Python constant:\\n\"\n               \">>> import %s\\n\"\n               \">>> %s%s = uuid.UUID('\" SD_ID128_FORMAT_STR \"')%s\\n\",\n               mod_link,\n               on, name, SD_ID128_FORMAT_VAL(id), off);\n\n        return 0;\n}\n\nint id128_pretty_print(sd_id128_t id, Id128PrettyPrintMode mode) {\n        assert(mode >= 0);\n        assert(mode < _ID128_PRETTY_PRINT_MODE_MAX);\n\n        if (mode == ID128_PRINT_ID128) {\n                printf(SD_ID128_FORMAT_STR \"\\n\",\n                       SD_ID128_FORMAT_VAL(id));\n                return 0;\n        } else if (mode == ID128_PRINT_UUID) {\n                printf(SD_ID128_UUID_FORMAT_STR \"\\n\",\n                       SD_ID128_FORMAT_VAL(id));\n                return 0;\n        } else\n                return id128_pretty_print_sample(\"XYZ\", id);\n}\n\nint id128_print_new(Id128PrettyPrintMode mode) {\n        sd_id128_t id;\n        int r;\n\n        r = sd_id128_randomize(&id);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to generate ID: %m\");\n\n        return id128_pretty_print(id, mode);\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "686μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "794439μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1320μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2463μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "386527μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "929μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1186364μs",
      "parallelizable_steps": [],
      "critical_path_length": "797831μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.333333333333333,
        "content_hash": "be601aa31d5084b3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/id128-print.c"
      }
    },
    "source_hash": "49d243b24c24"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netdevice.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tDefinitions for the Interfaces handler.\n *\n * Version:\t@(#)dev.h\t1.0.10\t08/12/93\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\tCorey Minyard <wf-rch!minyard@relay.EU.net>\n *\t\tDonald J. Becker, <becker@cesdis.gsfc.nasa.gov>\n *\t\tAlan Cox, <alan@lxorguk.ukuu.org.uk>\n *\t\tBjorn Ekwall. <bj0rn@blox.se>\n *              Pekka Riikonen <priikone@poseidon.pspt.fi>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\t\tMoved to /usr/include/linux for NET3\n */\n#ifndef _LINUX_NETDEVICE_H\n#define _LINUX_NETDEVICE_H\n\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_link.h>\n\n\n#define MAX_ADDR_LEN\t32\t\t/* Largest hardware address length */\n\n/* Initial net device group. All devices belong to group 0 by default. */\n#define INIT_NETDEV_GROUP\t0\n\n\n/* interface name assignment types (sysfs name_assign_type attribute) */\n#define NET_NAME_UNKNOWN\t0\t/* unknown origin (not exposed to userspace) */\n#define NET_NAME_ENUM\t\t1\t/* enumerated by kernel */\n#define NET_NAME_PREDICTABLE\t2\t/* predictably named by the kernel */\n#define NET_NAME_USER\t\t3\t/* provided by user-space */\n#define NET_NAME_RENAMED\t4\t/* renamed by user-space */\n\n/* Media selection options. */\nenum {\n        IF_PORT_UNKNOWN = 0,\n        IF_PORT_10BASE2,\n        IF_PORT_10BASET,\n        IF_PORT_AUI,\n        IF_PORT_100BASET,\n        IF_PORT_100BASETX,\n        IF_PORT_100BASEFX\n};\n\n/* hardware address assignment types */\n#define NET_ADDR_PERM\t\t0\t/* address is permanent (default) */\n#define NET_ADDR_RANDOM\t\t1\t/* address is generated randomly */\n#define NET_ADDR_STOLEN\t\t2\t/* address is stolen from other device */\n#define NET_ADDR_SET\t\t3\t/* address is set using\n\t\t\t\t\t * dev_set_mac_address() */\n\n#endif /* _LINUX_NETDEVICE_H */\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "448μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "204μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "300825μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "521715μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "311029μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "302952μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "421μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1437594μs",
      "parallelizable_steps": [],
      "critical_path_length": "824871μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.508771929824561
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.508771929824561,
        "content_hash": "d214e0a5596e1df7"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netdevice.h"
      }
    },
    "source_hash": "bc4cbb317aaf"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/ip-protocol-list.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"ip-protocol-list.h\"\n#include \"parse-util.h\"\n#include \"string-util.h\"\n\nstatic const struct ip_protocol_name* lookup_ip_protocol(register const char *str, register GPERF_LEN_TYPE len);\n\n#include \"ip-protocol-from-name.inc\"\n#include \"ip-protocol-to-name.inc\"\n\nconst char* ip_protocol_to_name(int id) {\n\n        if (id < 0)\n                return NULL;\n\n        if ((size_t) id >= ELEMENTSOF(ip_protocol_names))\n                return NULL;\n\n        return ip_protocol_names[id];\n}\n\nint ip_protocol_from_name(const char *name) {\n        const struct ip_protocol_name *sc;\n\n        assert(name);\n\n        sc = lookup_ip_protocol(name, strlen(name));\n        if (!sc)\n                return -EINVAL;\n\n        return sc->id;\n}\n\nint parse_ip_protocol_full(const char *s, bool relaxed) {\n        int r, p;\n\n        assert(s);\n\n        if (isempty(s))\n                return IPPROTO_IP;\n\n        /* People commonly use lowercase protocol names, which we can look up very quickly, so let's try that\n         * first. */\n        r = ip_protocol_from_name(s);\n        if (r >= 0)\n                return r;\n\n        /* Do not use strdupa() here, as the input string may come from command line or config files. */\n        _cleanup_free_ char *t = strdup(s);\n        if (!t)\n                return -ENOMEM;\n\n        r = ip_protocol_from_name(ascii_strlower(t));\n        if (r >= 0)\n                return r;\n\n        r = safe_atoi(t, &p);\n        if (r < 0)\n                return r;\n        if (p < 0)\n                return -ERANGE;\n\n        /* If @relaxed, we don't check that we have a name for the protocol. */\n        if (!relaxed && !ip_protocol_to_name(p))\n                return -EPROTONOSUPPORT;\n\n        return p;\n}\n\nconst char* ip_protocol_to_tcp_udp(int id) {\n        return IN_SET(id, IPPROTO_TCP, IPPROTO_UDP) ?\n                ip_protocol_to_name(id) : NULL;\n}\n\nint ip_protocol_from_tcp_udp(const char *ip_protocol) {\n        int id = ip_protocol_from_name(ip_protocol);\n        return IN_SET(id, IPPROTO_TCP, IPPROTO_UDP) ? id : -EINVAL;\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "266μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "346μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "105681μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "220μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "73μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "106586μs",
      "parallelizable_steps": [],
      "critical_path_length": "106020μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 58,
        "complexity_score": 2.413793103448276
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 58,
        "complexity_score": 2.413793103448276,
        "content_hash": "23b26db276e27ea9"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/ip-protocol-list.c"
      }
    },
    "source_hash": "99937c0aaa87"
  },
  {
    "instruction": "Decompose and explain this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "689μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "593μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "469μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "271399μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "279μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "391μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "273820μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "272383μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "ac4b8d09743d"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/core-forward.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"conf-parser-forward.h\"        /* IWYU pragma: export */\n#include \"forward.h\"                    /* IWYU pragma: export */\n#include \"unit-def.h\"                   /* IWYU pragma: export */\n\ntypedef enum CGroupDevicePermissions CGroupDevicePermissions;\ntypedef enum CGroupDevicePolicy CGroupDevicePolicy;\ntypedef enum ExecCleanMask ExecCleanMask;\ntypedef enum ExecPreserveMode ExecPreserveMode;\ntypedef enum FreezerAction FreezerAction;\ntypedef enum JobResult JobResult;\ntypedef enum JobState JobState;\ntypedef enum JobType JobType;\ntypedef enum ManagerState ManagerState;\ntypedef enum TransactionAddFlags TransactionAddFlags;\ntypedef enum UnitDependencyAtom UnitDependencyAtom;\ntypedef enum UnitWriteFlags UnitWriteFlags;\n\ntypedef struct ActivationDetails ActivationDetails;\ntypedef struct BindMount BindMount;\ntypedef struct CGroupBPFForeignProgram CGroupBPFForeignProgram;\ntypedef struct CGroupContext CGroupContext;\ntypedef struct CGroupDeviceAllow CGroupDeviceAllow;\ntypedef struct CGroupIODeviceLatency CGroupIODeviceLatency;\ntypedef struct CGroupIODeviceLimit CGroupIODeviceLimit;\ntypedef struct CGroupIODeviceWeight CGroupIODeviceWeight;\ntypedef struct CGroupRuntime CGroupRuntime;\ntypedef struct CGroupSocketBindItem CGroupSocketBindItem;\ntypedef struct DynamicCreds DynamicCreds;\ntypedef struct DynamicUser DynamicUser;\ntypedef struct ExecCommand ExecCommand;\ntypedef struct ExecContext ExecContext;\ntypedef struct ExecParameters ExecParameters;\ntypedef struct ExecRuntime ExecRuntime;\ntypedef struct ExecSharedRuntime ExecSharedRuntime;\ntypedef struct Job Job;\ntypedef struct JobDependency JobDependency;\ntypedef struct KillContext KillContext;\ntypedef struct Manager Manager;\ntypedef struct MountImage MountImage;\ntypedef struct PathSpec PathSpec;\ntypedef struct Scope Scope;\ntypedef struct Service Service;\ntypedef struct Socket Socket;\ntypedef struct SocketPeer SocketPeer;\ntypedef struct TemporaryFileSystem TemporaryFileSystem;\ntypedef struct Unit Unit;\ntypedef struct UnitRef UnitRef;\n\nstruct restrict_fs_bpf;\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "130μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "5μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "181961μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "15482μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "179669μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "19160μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "73μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "396480μs",
      "parallelizable_steps": [],
      "critical_path_length": "361833μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.0416666666666667
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.0416666666666667,
        "content_hash": "c94094798e7e8809"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/core-forward.h"
      }
    },
    "source_hash": "c82f9b9330a1"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/tc/sfb.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright © 2020 VMware, Inc. */\n\n#include <linux/pkt_sched.h>\n#include \"sd-netlink.h\"\n\n#include \"log.h\"\n#include \"parse-util.h\"\n#include \"qdisc.h\"\n#include \"sfb.h\"\n#include \"string-util.h\"\n\nstatic int stochastic_fair_blue_fill_message(Link *link, QDisc *qdisc, sd_netlink_message *req) {\n        StochasticFairBlue *sfb;\n        int r;\n\n        assert(link);\n        assert(qdisc);\n        assert(req);\n\n        assert_se(sfb = SFB(qdisc));\n\n        const struct tc_sfb_qopt opt = {\n            .rehash_interval = 600*1000,\n            .warmup_time = 60*1000,\n            .penalty_rate = 10,\n            .penalty_burst = 20,\n            .increment = (SFB_MAX_PROB + 1000) / 2000,\n            .decrement = (SFB_MAX_PROB + 10000) / 20000,\n            .max = 25,\n            .bin_size = 20,\n            .limit = sfb->packet_limit,\n        };\n\n        r = sd_netlink_message_open_container_union(req, TCA_OPTIONS, \"sfb\");\n        if (r < 0)\n                return r;\n\n        r = sd_netlink_message_append_data(req, TCA_SFB_PARMS, &opt, sizeof(opt));\n        if (r < 0)\n                return r;\n\n        r = sd_netlink_message_close_container(req);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nint config_parse_stochastic_fair_blue_u32(\n                const char *unit,\n                const char *filename,\n                unsigned line,\n                const char *section,\n                unsigned section_line,\n                const char *lvalue,\n                int ltype,\n                const char *rvalue,\n                void *data,\n                void *userdata) {\n\n        _cleanup_(qdisc_unref_or_set_invalidp) QDisc *qdisc = NULL;\n        StochasticFairBlue *sfb;\n        Network *network = ASSERT_PTR(data);\n        int r;\n\n        assert(filename);\n        assert(lvalue);\n        assert(rvalue);\n\n        r = qdisc_new_static(QDISC_KIND_SFB, network, filename, section_line, &qdisc);\n        if (r == -ENOMEM)\n                return log_oom();\n        if (r < 0) {\n                log_syntax(unit, LOG_WARNING, filename, line, r,\n                           \"More than one kind of queueing discipline, ignoring assignment: %m\");\n                return 0;\n        }\n\n        sfb = SFB(qdisc);\n\n        if (isempty(rvalue)) {\n                sfb->packet_limit = 0;\n\n                TAKE_PTR(qdisc);\n                return 0;\n        }\n\n        r = safe_atou32(rvalue, &sfb->packet_limit);\n        if (r < 0) {\n                log_syntax(unit, LOG_WARNING, filename, line, r,\n                           \"Failed to parse '%s=', ignoring assignment: %s\",\n                           lvalue, rvalue);\n                return 0;\n        }\n\n        TAKE_PTR(qdisc);\n\n        return 0;\n}\n\nconst QDiscVTable sfb_vtable = {\n        .object_size = sizeof(StochasticFairBlue),\n        .tca_kind = \"sfb\",\n        .fill_message = stochastic_fair_blue_fill_message,\n};\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "36μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "104μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "2355μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "259μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "157μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2911μs",
      "parallelizable_steps": [],
      "critical_path_length": "2548μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 85,
        "complexity_score": 0.9411764705882353
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 85,
        "complexity_score": 0.9411764705882353,
        "content_hash": "104a6abf18342087"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/tc/sfb.c"
      }
    },
    "source_hash": "e90d9004f436"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp6-network.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/***\n  Copyright © 2014 Intel Corporation. All rights reserved.\n***/\n\n#include <netinet/in.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"dhcp6-internal.h\"\n#include \"dhcp6-protocol.h\"\n#include \"fd-util.h\"\n#include \"socket-util.h\"\n\nint dhcp6_network_bind_udp_socket(int ifindex, const struct in6_addr *local_address) {\n        union sockaddr_union src = {\n                .in6.sin6_family = AF_INET6,\n                .in6.sin6_addr = *ASSERT_PTR(local_address),\n                .in6.sin6_port = htobe16(DHCP6_PORT_CLIENT),\n                .in6.sin6_scope_id = ifindex,\n        };\n        _cleanup_close_ int s = -EBADF;\n        int r;\n\n        assert(ifindex > 0);\n\n        s = socket(AF_INET6, SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_UDP);\n        if (s < 0)\n                return -errno;\n\n        r = setsockopt_int(s, IPPROTO_IPV6, IPV6_V6ONLY, true);\n        if (r < 0)\n                return r;\n\n        r = setsockopt_int(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, false);\n        if (r < 0)\n                return r;\n\n        r = setsockopt_int(s, SOL_SOCKET, SO_REUSEADDR, true);\n        if (r < 0)\n                return r;\n\n        r = setsockopt_int(s, SOL_SOCKET, SO_TIMESTAMP, true);\n        if (r < 0)\n                return r;\n\n        r = bind(s, &src.sa, sizeof(src.in6));\n        if (r < 0)\n                return -errno;\n\n        return TAKE_FD(s);\n}\n\nint dhcp6_network_send_udp_socket(int s, const struct in6_addr *server_address, const void *packet, size_t len) {\n        union sockaddr_union dest = {\n                .in6.sin6_family = AF_INET6,\n                .in6.sin6_addr = *ASSERT_PTR(server_address),\n                .in6.sin6_port = htobe16(DHCP6_PORT_SERVER),\n        };\n\n        if (sendto(s, packet, len, 0, &dest.sa, sizeof(dest.in6)) < 0)\n                return -errno;\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "39μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "168μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "387983μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "324590μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "85115μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "343886μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "203μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1141984μs",
      "parallelizable_steps": [],
      "critical_path_length": "668644μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 2.1568627450980395
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 2.1568627450980395,
        "content_hash": "9098c728feed7d81"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp6-network.c"
      }
    },
    "source_hash": "4ed75d1f0338"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/generate-gperfs.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n# pylint: disable=unbalanced-tuple-unpacking,consider-using-f-string,consider-using-with\n\n\"\"\"\nGenerate %-from-name.gperf from %-list.txt\n\"\"\"\n\nimport sys\n\nif __name__ == '__main__':\n    if len(sys.argv) < 4:\n        sys.exit(f'Usage: {sys.argv[0]} name prefix file [includes...]')\n\n    name, prefix, file, *includes = sys.argv[1:]\n    includes = [f\"#include {i}\" for i in includes]\n\n    # Older versions of python don't allow backslashes\n    # in f-strings so use chr(10) for newlines and chr(92)\n    # for backslashes instead as a workaround.\n    print(f\"\"\"\\\n%{{\n_Pragma(\"GCC diagnostic ignored {chr(92)}\"-Wimplicit-fallthrough{chr(92)}\"\")\n#if __GNUC__ >= 15\n_Pragma(\"GCC diagnostic ignored {chr(92)}\"-Wzero-as-null-pointer-constant{chr(92)}\"\")\n#endif\n{chr(10).join(includes)}\n%}}\"\"\")\n    print(f\"\"\"\\\nstruct {name}_name {{ const char* name; int id; }};\n%null-strings\n%%\"\"\")\n\n    for line in open(file):\n        print(\"{0}, {1}{0}\".format(line.rstrip(), prefix))\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "704μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "13μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "242206μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "749μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "529μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "244201μs",
      "parallelizable_steps": [],
      "critical_path_length": "243439μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 29,
        "complexity_score": 3.793103448275862
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 29,
        "complexity_score": 3.793103448275862,
        "content_hash": "687f400bb62424fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/generate-gperfs.py"
      }
    },
    "source_hash": "7d8fdecefe4c"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/coverage/coverage.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n/* Use the coverage-related tweaks below only for C stuff as they're not really\n * C++ compatible, and the only thing that is built with a C++ compiler is\n * the lone test-bus-vtable-cc unit test.\n */\n#ifndef __cplusplus\n\nvoid __gcov_dump(void);\nvoid __gcov_reset(void);\n\n/* When built with --coverage (gcov) we need to explicitly call __gcov_dump()\n * in places where we use _exit(), since _exit() skips at-exit hooks resulting\n * in lost coverage.\n *\n * To make sure we don't miss any _exit() calls, this header file is included\n * explicitly on the compiler command line via the -include directive (only\n * when built with -Db_coverage=true)\n */\nvoid _exit(int);\n\nstatic inline _Noreturn void _coverage__exit(int status) {\n        __gcov_dump();\n        _exit(status);\n}\n#define _exit(x) _coverage__exit(x)\n\n/* gcov provides wrappers for the exec*() calls but there's none for execveat()\n * and execvpe() which means we lose all coverage prior to such call. To mitigate\n * this, let's add simple wrappers in gcov's style[0] for these exec*() calls,\n * which dump and reset the coverage data as needed.\n *\n * [0] https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libgcc/libgcov-interface.c;h=b2ee930864183b78c8826255183ca86e15e21ded;hb=HEAD\n */\n\nint execveat(int, const char *, char * const [], char * const [], int);\nint execvpe(const char *, char * const [], char * const []);\n\nstatic inline int _coverage_execveat(\n                        int dirfd,\n                        const char *pathname,\n                        char * const argv[],\n                        char * const envp[],\n                        int flags) {\n        __gcov_dump();\n        int r = execveat(dirfd, pathname, argv, envp, flags);\n        __gcov_reset();\n\n        return r;\n}\n#define execveat(d,p,a,e,f) _coverage_execveat(d, p, a, e, f)\n\nstatic inline int _coverage_execvpe(\n                        const char *file,\n                        char * const argv[],\n                        char * const envp[]) {\n        __gcov_dump();\n        int r = execvpe(file, argv, envp);\n        __gcov_reset();\n\n        return r;\n}\n#define execvpe(f,a,e) _coverage_execvpe(f, a, e)\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "715μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "492877μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "58μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1094μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "63734μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "637μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "559115μs",
      "parallelizable_steps": [],
      "critical_path_length": "494608μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 1.8181818181818183,
        "content_hash": "cb6492ea23e9a441"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/coverage/coverage.h"
      }
    },
    "source_hash": "fc44d179641d"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dhcp6-bus.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"alloc-util.h\"\n#include \"bus-object.h\"\n#include \"dhcp6-client-internal.h\"\n#include \"dhcp6-protocol.h\"\n#include \"networkd-dhcp6-bus.h\"\n#include \"networkd-link-bus.h\"\n#include \"networkd-link.h\"\n#include \"networkd-manager.h\"\n\nstatic int property_get_dhcp6_client_state(\n                sd_bus *bus,\n                const char *path,\n                const char *interface,\n                const char *property,\n                sd_bus_message *reply,\n                void *userdata,\n                sd_bus_error *error) {\n\n        Link *l = ASSERT_PTR(userdata);\n        sd_dhcp6_client *c;\n\n        assert(reply);\n\n        c = l->dhcp6_client;\n        if (!c)\n                return sd_bus_message_append(reply, \"s\", \"disabled\");\n\n        return sd_bus_message_append(reply, \"s\", dhcp6_state_to_string(dhcp6_client_get_state(c)));\n}\n\nstatic int dhcp6_client_emit_changed_strv(Link *link, char **properties) {\n        _cleanup_free_ char *path = NULL;\n\n        assert(link);\n\n        if (sd_bus_is_ready(link->manager->bus) <= 0)\n                return 0;\n\n        path = link_bus_path(link);\n        if (!path)\n                return log_oom();\n\n        return sd_bus_emit_properties_changed_strv(\n                        link->manager->bus,\n                        path,\n                        \"org.freedesktop.network1.DHCPv6Client\",\n                        properties);\n}\n\nvoid dhcp6_client_callback_bus(sd_dhcp6_client *c, int event, void *userdata) {\n        Link *l = ASSERT_PTR(userdata);\n\n        dhcp6_client_emit_changed_strv(l, STRV_MAKE(\"State\"));\n}\n\nstatic const sd_bus_vtable dhcp6_client_vtable[] = {\n        SD_BUS_VTABLE_START(0),\n\n        SD_BUS_PROPERTY(\"State\", \"s\", property_get_dhcp6_client_state, 0, SD_BUS_VTABLE_PROPERTY_EMITS_CHANGE),\n\n        SD_BUS_VTABLE_END\n};\n\nconst BusObjectImplementation dhcp6_client_object = {\n        \"/org/freedesktop/network1/link\",\n        \"org.freedesktop.network1.DHCPv6Client\",\n        .fallback_vtables = BUS_FALLBACK_VTABLES({dhcp6_client_vtable, link_object_find}),\n        .node_enumerator = link_node_enumerator,\n};\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "76μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "77μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "34878μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "106μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "19μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "35156μs",
      "parallelizable_steps": [],
      "critical_path_length": "34973μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 0.7272727272727273
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 0.7272727272727273,
        "content_hash": "bf01c12d992556c3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dhcp6-bus.c"
      }
    },
    "source_hash": "dc7ba8cc4694"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-option.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpoptionhfoo\n#define foosddhcpoptionhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n#include \"sd-dhcp-protocol.h\"   /* IWYU pragma: export */\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp_option sd_dhcp_option;\n\nint sd_dhcp_option_new(uint8_t option, const void *data, size_t length, sd_dhcp_option **ret);\nsd_dhcp_option *sd_dhcp_option_ref(sd_dhcp_option *ra);\nsd_dhcp_option *sd_dhcp_option_unref(sd_dhcp_option *ra);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp_option, sd_dhcp_option_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "913μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1319176μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2461μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "661μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "560600μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1174μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1884985μs",
      "parallelizable_steps": [],
      "critical_path_length": "1321011μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.0,
        "content_hash": "76e13d1d5f67fc86"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-option.h"
      }
    },
    "source_hash": "74cb8d198991"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-utf8.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdutf8hfoo\n#define foosdutf8hfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\n_sd_pure_ const char *sd_utf8_is_valid(const char *s);\n_sd_pure_ const char *sd_ascii_is_valid(const char *s);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1698μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1566587μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1072μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "3035μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "824612μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1113μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "2398117μs",
      "parallelizable_steps": [],
      "critical_path_length": "1570735μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 4.761904761904762
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 4.761904761904762,
        "content_hash": "d4ec0c6496e33f19"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-utf8.h"
      }
    },
    "source_hash": "051a6f3641ba"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/lldp-network.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\nint lldp_network_bind_raw_socket(int ifindex);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "462μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "362μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "268590μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "137μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "297μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "269848μs",
      "parallelizable_steps": [],
      "critical_path_length": "269349μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 3,
        "complexity_score": 6.666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 3,
        "complexity_score": 6.666666666666666,
        "content_hash": "ebcedf09329edfa3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/lldp-network.h"
      }
    },
    "source_hash": "7f6ad4ad75ef"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/tc/hhf.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later\n * Copyright © 2020 VMware, Inc. */\n\n#include <linux/pkt_sched.h>\n\n#include \"sd-netlink.h\"\n\n#include \"hhf.h\"\n#include \"log.h\"\n#include \"parse-util.h\"\n#include \"string-util.h\"\n\nstatic int heavy_hitter_filter_fill_message(Link *link, QDisc *qdisc, sd_netlink_message *req) {\n        HeavyHitterFilter *hhf;\n        int r;\n\n        assert(link);\n        assert(qdisc);\n        assert(req);\n\n        assert_se(hhf = HHF(qdisc));\n\n        r = sd_netlink_message_open_container_union(req, TCA_OPTIONS, \"hhf\");\n        if (r < 0)\n                return r;\n\n        if (hhf->packet_limit > 0) {\n                r = sd_netlink_message_append_u32(req, TCA_HHF_BACKLOG_LIMIT, hhf->packet_limit);\n                if (r < 0)\n                        return r;\n        }\n\n       r = sd_netlink_message_close_container(req);\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nint config_parse_heavy_hitter_filter_packet_limit(\n                const char *unit,\n                const char *filename,\n                unsigned line,\n                const char *section,\n                unsigned section_line,\n                const char *lvalue,\n                int ltype,\n                const char *rvalue,\n                void *data,\n                void *userdata) {\n\n        _cleanup_(qdisc_unref_or_set_invalidp) QDisc *qdisc = NULL;\n        HeavyHitterFilter *hhf;\n        Network *network = ASSERT_PTR(data);\n        int r;\n\n        assert(filename);\n        assert(lvalue);\n        assert(rvalue);\n\n        r = qdisc_new_static(QDISC_KIND_HHF, network, filename, section_line, &qdisc);\n        if (r == -ENOMEM)\n                return log_oom();\n        if (r < 0) {\n                log_syntax(unit, LOG_WARNING, filename, line, r,\n                           \"More than one kind of queueing discipline, ignoring assignment: %m\");\n                return 0;\n        }\n\n        hhf = HHF(qdisc);\n\n        if (isempty(rvalue)) {\n                hhf->packet_limit = 0;\n\n                TAKE_PTR(qdisc);\n                return 0;\n        }\n\n        r = safe_atou32(rvalue, &hhf->packet_limit);\n        if (r < 0) {\n                log_syntax(unit, LOG_WARNING, filename, line, r,\n                           \"Failed to parse '%s=', ignoring assignment: %s\",\n                           lvalue, rvalue);\n                return 0;\n        }\n\n        TAKE_PTR(qdisc);\n\n        return 0;\n}\n\nconst QDiscVTable hhf_vtable = {\n        .object_size = sizeof(HeavyHitterFilter),\n        .tca_kind = \"hhf\",\n        .fill_message = heavy_hitter_filter_fill_message,\n};\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "41μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "64μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "80853μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "436μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "208μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "81602μs",
      "parallelizable_steps": [],
      "critical_path_length": "81102μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.2
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.2,
        "content_hash": "f6ac579097854bf3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/tc/hhf.c"
      }
    },
    "source_hash": "b6dd04a6e4c4"
  },
  {
    "instruction": "Decompose the network operation: TCP 3-way handshake",
    "input": "Analyze the step-by-step process for: TCP 3-way handshake",
    "output": {
      "operation": "TCP 3-way handshake",
      "category": "tcp_connection_management",
      "steps": [
        {
          "step": 1,
          "action": "Client sends SYN packet with ISN",
          "expected_time": "807297μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Server receives SYN and allocates TCB",
          "expected_time": "466μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Server sends SYN-ACK response",
          "expected_time": "902071μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Client receives SYN-ACK and sends ACK",
          "expected_time": "392132μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Connection established and ready",
          "expected_time": "558μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2102524μs",
      "parallelizable_steps": [],
      "critical_path_length": "1709926μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "tcp_connection_management",
      "complexity": "medium",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "cd443f3d055c"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/plymouth-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"io-util.h\"\n#include \"log.h\"\n#include \"plymouth-util.h\"\n#include \"socket-util.h\"\n\nint plymouth_connect(int flags) {\n        static const union sockaddr_union sa = {\n                .un.sun_family = AF_UNIX,\n                .un.sun_path = \"\\0/org/freedesktop/plymouthd\",\n        };\n        _cleanup_close_ int fd = -EBADF;\n\n        fd = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|flags, 0);\n        if (fd < 0)\n                return -errno;\n\n        if (connect(fd, &sa.sa, sockaddr_un_len(&sa.un)) < 0)\n                return -errno;\n\n        return TAKE_FD(fd);\n}\n\nint plymouth_send_raw(const void *raw, size_t size, int flags) {\n        _cleanup_close_ int fd = -EBADF;\n\n        fd = plymouth_connect(flags);\n        if (fd < 0)\n                return fd;\n\n        return loop_write(fd, raw, size);\n}\n\nint plymouth_send_msg(const char *text, bool pause_spinner) {\n        _cleanup_free_ char *plymouth_message = NULL;\n        int c, r;\n\n        assert(text);\n        assert(strlen(text) < UCHAR_MAX);\n\n        c = asprintf(&plymouth_message,\n                     \"M\\x02%c%s%c\"\n                     \"%c%c\", /* pause/resume spinner */\n                     (int) strlen(text) + 1, text, '\\x00',\n                     pause_spinner ? 'A' : 'a', '\\x00');\n        if (c < 0)\n                return log_oom();\n\n        r = plymouth_send_raw(plymouth_message, c, SOCK_NONBLOCK);\n        if (r < 0)\n                return log_full_errno(ERRNO_IS_NO_PLYMOUTH(r) ? LOG_DEBUG : LOG_WARNING, r,\n                                      \"Failed to communicate with plymouth, ignoring: %m\");\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "301μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "81μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "29446μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "112271μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "136280μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "19602μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "34μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "298015μs",
      "parallelizable_steps": [],
      "critical_path_length": "166061μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.5555555555555556
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.5555555555555556,
        "content_hash": "9c80a0a68a2f9435"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/plymouth-util.c"
      }
    },
    "source_hash": "bd215d980d0e"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-duid.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpduidhfoo\n#define foosddhcpduidhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nenum {\n        SD_DUID_TYPE_LLT        = 1,\n        SD_DUID_TYPE_EN         = 2,\n        SD_DUID_TYPE_LL         = 3,\n        SD_DUID_TYPE_UUID       = 4\n};\n\ntypedef struct sd_dhcp_duid sd_dhcp_duid;\n\nint sd_dhcp_duid_clear(sd_dhcp_duid *duid);\n\nint sd_dhcp_duid_is_set(const sd_dhcp_duid *duid);\n\nint sd_dhcp_duid_get(const sd_dhcp_duid *duid, uint16_t *ret_type, const void **ret_data, size_t *ret_size);\nint sd_dhcp_duid_get_raw(const sd_dhcp_duid *duid, const void **ret_data, size_t *ret_size);\n\nint sd_dhcp_duid_set(\n                sd_dhcp_duid *duid,\n                uint16_t duid_type,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_duid_set_raw(\n                sd_dhcp_duid *duid,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_duid_set_llt(\n                sd_dhcp_duid *duid,\n                const void *hw_addr,\n                size_t hw_addr_size,\n                uint16_t arp_type,\n                uint64_t usec);\nint sd_dhcp_duid_set_ll(\n                sd_dhcp_duid *duid,\n                const void *hw_addr,\n                size_t hw_addr_size,\n                uint16_t arp_type);\nint sd_dhcp_duid_set_en(sd_dhcp_duid *duid);\nint sd_dhcp_duid_set_uuid(sd_dhcp_duid *duid);\n\nint sd_dhcp_duid_to_string(const sd_dhcp_duid *duid, char **ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "49μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "57320μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "417μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "773μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "322032μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "729μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "381320μs",
      "parallelizable_steps": [],
      "critical_path_length": "322498μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 1.8867924528301887
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 1.8867924528301887,
        "content_hash": "da4ce8bbb04cc739"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-duid.h"
      }
    },
    "source_hash": "2e633ee1e6d7"
  },
  {
    "instruction": "Decompose the network operation: TCP 3-way handshake",
    "input": "Analyze the step-by-step process for: TCP 3-way handshake",
    "output": {
      "operation": "TCP 3-way handshake",
      "category": "tcp_connection_management",
      "steps": [
        {
          "step": 1,
          "action": "Client sends SYN packet with ISN",
          "expected_time": "807297μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Server receives SYN and allocates TCB",
          "expected_time": "466μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Server sends SYN-ACK response",
          "expected_time": "902071μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Client receives SYN-ACK and sends ACK",
          "expected_time": "392132μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Connection established and ready",
          "expected_time": "558μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2102524μs",
      "parallelizable_steps": [],
      "critical_path_length": "1709926μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "tcp_connection_management",
      "complexity": "medium",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "cd443f3d055c"
  },
  {
    "instruction": "Analyze and decompose this api_clients code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp-client-id-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/if_ether.h>\n\n#include \"sd-dhcp-client-id.h\"\n\n#include \"dhcp-duid-internal.h\"\n#include \"forward.h\"\n#include \"sparse-endian.h\"\n\n/* RFC 2132 section 9.14: its minimum length is 2.\n * Note, its maximum is not mentioend in the RFC. Hence, 255. */\n#define MIN_CLIENT_ID_LEN 2\n#define MAX_CLIENT_ID_LEN 255\n#define MIN_CLIENT_ID_DATA_LEN (MIN_CLIENT_ID_LEN - sizeof(uint8_t))\n#define MAX_CLIENT_ID_DATA_LEN (MAX_CLIENT_ID_LEN - sizeof(uint8_t))\n\ntypedef struct sd_dhcp_client_id {\n        size_t size;\n        union {\n                struct {\n                        uint8_t type;\n                        union {\n                                struct {\n                                        /* 0: Generic (non-LL) (RFC 2132) */\n                                        uint8_t data[MAX_CLIENT_ID_DATA_LEN];\n                                } _packed_ gen;\n                                struct {\n                                        /* 1: Ethernet Link-Layer (RFC 2132) */\n                                        uint8_t haddr[ETH_ALEN];\n                                } _packed_ eth;\n                                struct {\n                                        /* 2 - 254: ARP/Link-Layer (RFC 2132) */\n                                        uint8_t haddr[HW_ADDR_MAX_SIZE];\n                                } _packed_ ll;\n                                struct {\n                                        /* 255: Node-specific (RFC 4361) */\n                                        be32_t iaid;\n                                        struct duid duid;\n                                } _packed_ ns;\n                                uint8_t data[MAX_CLIENT_ID_DATA_LEN];\n                        };\n                } _packed_ id;\n                uint8_t raw[MAX_CLIENT_ID_LEN];\n        };\n} sd_dhcp_client_id;\n\nassert_cc(sizeof_field(sd_dhcp_client_id, id) <= MAX_CLIENT_ID_LEN);\n\nstatic inline bool client_id_size_is_valid(size_t size) {\n        return size >= MIN_CLIENT_ID_LEN && size <= MAX_CLIENT_ID_LEN;\n}\n\nstatic inline bool client_id_data_size_is_valid(size_t size) {\n        return size >= MIN_CLIENT_ID_DATA_LEN && size <= MAX_CLIENT_ID_DATA_LEN;\n}\n\nvoid client_id_hash_func(const sd_dhcp_client_id *client_id, struct siphash *state);\nint client_id_compare_func(const sd_dhcp_client_id *a, const sd_dhcp_client_id *b);\n\nint json_dispatch_client_id(const char *name, sd_json_variant *variant, sd_json_dispatch_flags_t flags, void *userdata);\n",
    "output": {
      "operation": "Api Clients Implementation",
      "category": "api_clients",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "10μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "54μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "42957μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "283μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "36μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "43340μs",
      "parallelizable_steps": [],
      "critical_path_length": "43003μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.7692307692307693
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "api_clients",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.7692307692307693,
        "content_hash": "ffcd4f21eb6bebf8"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp-client-id-internal.h"
      }
    },
    "source_hash": "20a52f52719c"
  },
  {
    "instruction": "Decompose the network operation: TCP 3-way handshake",
    "input": "Analyze the step-by-step process for: TCP 3-way handshake",
    "output": {
      "operation": "TCP 3-way handshake",
      "category": "tcp_connection_management",
      "steps": [
        {
          "step": 1,
          "action": "Client sends SYN packet with ISN",
          "expected_time": "807297μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Server receives SYN and allocates TCB",
          "expected_time": "466μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Server sends SYN-ACK response",
          "expected_time": "902071μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Client receives SYN-ACK and sends ACK",
          "expected_time": "392132μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Connection established and ready",
          "expected_time": "558μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "2102524μs",
      "parallelizable_steps": [],
      "critical_path_length": "1709926μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "tcp_connection_management",
      "complexity": "medium",
      "variation": true,
      "code_analysis": null
    },
    "source_hash": "cd443f3d055c"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/bond-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"bond-util.h\"\n#include \"string-table.h\"\n\nstatic const char* const bond_mode_table[_NETDEV_BOND_MODE_MAX] = {\n        [NETDEV_BOND_MODE_BALANCE_RR] = \"balance-rr\",\n        [NETDEV_BOND_MODE_ACTIVE_BACKUP] = \"active-backup\",\n        [NETDEV_BOND_MODE_BALANCE_XOR] = \"balance-xor\",\n        [NETDEV_BOND_MODE_BROADCAST] = \"broadcast\",\n        [NETDEV_BOND_MODE_802_3AD] = \"802.3ad\",\n        [NETDEV_BOND_MODE_BALANCE_TLB] = \"balance-tlb\",\n        [NETDEV_BOND_MODE_BALANCE_ALB] = \"balance-alb\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_mode, BondMode);\n\nstatic const char* const bond_xmit_hash_policy_table[_NETDEV_BOND_XMIT_HASH_POLICY_MAX] = {\n        [NETDEV_BOND_XMIT_HASH_POLICY_LAYER2] = \"layer2\",\n        [NETDEV_BOND_XMIT_HASH_POLICY_LAYER34] = \"layer3+4\",\n        [NETDEV_BOND_XMIT_HASH_POLICY_LAYER23] = \"layer2+3\",\n        [NETDEV_BOND_XMIT_HASH_POLICY_ENCAP23] = \"encap2+3\",\n        [NETDEV_BOND_XMIT_HASH_POLICY_ENCAP34] = \"encap3+4\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_xmit_hash_policy, BondXmitHashPolicy);\n\nstatic const char* const bond_lacp_rate_table[_NETDEV_BOND_LACP_RATE_MAX] = {\n        [NETDEV_BOND_LACP_RATE_SLOW] = \"slow\",\n        [NETDEV_BOND_LACP_RATE_FAST] = \"fast\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_lacp_rate, BondLacpRate);\n\nstatic const char* const bond_ad_select_table[_NETDEV_BOND_AD_SELECT_MAX] = {\n        [NETDEV_BOND_AD_SELECT_STABLE] = \"stable\",\n        [NETDEV_BOND_AD_SELECT_BANDWIDTH] = \"bandwidth\",\n        [NETDEV_BOND_AD_SELECT_COUNT] = \"count\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_ad_select, BondAdSelect);\n\nstatic const char* const bond_fail_over_mac_table[_NETDEV_BOND_FAIL_OVER_MAC_MAX] = {\n        [NETDEV_BOND_FAIL_OVER_MAC_NONE] = \"none\",\n        [NETDEV_BOND_FAIL_OVER_MAC_ACTIVE] = \"active\",\n        [NETDEV_BOND_FAIL_OVER_MAC_FOLLOW] = \"follow\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_fail_over_mac, BondFailOverMac);\n\nstatic const char *const bond_arp_validate_table[_NETDEV_BOND_ARP_VALIDATE_MAX] = {\n        [NETDEV_BOND_ARP_VALIDATE_NONE] = \"none\",\n        [NETDEV_BOND_ARP_VALIDATE_ACTIVE]= \"active\",\n        [NETDEV_BOND_ARP_VALIDATE_BACKUP]= \"backup\",\n        [NETDEV_BOND_ARP_VALIDATE_ALL]= \"all\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_arp_validate, BondArpValidate);\n\nstatic const char *const bond_arp_all_targets_table[_NETDEV_BOND_ARP_ALL_TARGETS_MAX] = {\n        [NETDEV_BOND_ARP_ALL_TARGETS_ANY] = \"any\",\n        [NETDEV_BOND_ARP_ALL_TARGETS_ALL] = \"all\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_arp_all_targets, BondArpAllTargets);\n\nstatic const char *const bond_primary_reselect_table[_NETDEV_BOND_PRIMARY_RESELECT_MAX] = {\n        [NETDEV_BOND_PRIMARY_RESELECT_ALWAYS] = \"always\",\n        [NETDEV_BOND_PRIMARY_RESELECT_BETTER]= \"better\",\n        [NETDEV_BOND_PRIMARY_RESELECT_FAILURE]= \"failure\",\n};\n\nDEFINE_STRING_TABLE_LOOKUP(bond_primary_reselect, BondPrimaryReselect);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "33μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "8μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "17093μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "23μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "34μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "17191μs",
      "parallelizable_steps": [],
      "critical_path_length": "17160μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.17857142857142855
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.17857142857142855,
        "content_hash": "ce211050eb309809"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/bond-util.c"
      }
    },
    "source_hash": "2d71301abc11"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-delegate.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-forward.h\"\n\n#define DELEGATE_SEARCH_DOMAINS_MAX 1024\n#define DELEGATE_DNS_SERVERS_MAX 256\n\n/* A DnsDelegate object is used to manage additional, explicitly configured unicast DNS lookup scopes,\n * independent from any network link and from the global scope. */\n\ntypedef struct DnsDelegate {\n        Manager *manager;\n        char *id;\n\n        LIST_HEAD(DnsServer, dns_servers);\n        unsigned n_dns_servers;\n        DnsServer *current_dns_server;\n\n        LIST_HEAD(DnsSearchDomain, search_domains);\n        unsigned n_search_domains;\n\n        int default_route;\n\n        DnsScope *scope;\n\n        LIST_FIELDS(DnsDelegate, delegates);\n} DnsDelegate;\n\nint dns_delegate_new(Manager *m, const char *id, DnsDelegate **ret);\nDnsDelegate *dns_delegate_free(DnsDelegate *d);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnsDelegate*, dns_delegate_free);\n\nDnsServer* dns_delegate_set_dns_server(DnsDelegate *d, DnsServer *s);\nDnsServer *dns_delegate_get_dns_server(DnsDelegate *d);\nvoid dns_delegate_next_dns_server(DnsDelegate *d, DnsServer *if_current);\n\nint manager_load_delegates(Manager *m);\n\nconst struct ConfigPerfItem* resolved_dns_delegate_gperf_lookup(const char *key, GPERF_LEN_TYPE length);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_delegate_dns_servers);\nCONFIG_PARSER_PROTOTYPE(config_parse_delegate_domains);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "107μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "42μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "195196μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "62084μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "123μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "16μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "257568μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "195319μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 1.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 1.0,
        "content_hash": "3743df6e29fb4eb2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-delegate.h"
      }
    },
    "source_hash": "360c1c24efd2"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-fiemap.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <fcntl.h>\n#include <linux/fiemap.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include \"argv-util.h\"\n#include \"fd-util.h\"\n#include \"hibernate-util.h\"\n#include \"log.h\"\n#include \"tests.h\"\n\nstatic int test_fiemap_one(const char *path) {\n        _cleanup_free_ struct fiemap *fiemap = NULL;\n        _cleanup_close_ int fd = -EBADF;\n        int r;\n\n        log_info(\"/* %s */\", __func__);\n\n        fd = open(path, O_RDONLY | O_CLOEXEC | O_NONBLOCK);\n        if (fd < 0)\n                return log_error_errno(errno, \"failed to open %s: %m\", path);\n        r = read_fiemap(fd, &fiemap);\n        if (r == -EOPNOTSUPP)\n                exit(log_tests_skipped(\"Not supported\"));\n        if (r < 0)\n                return log_error_errno(r, \"Unable to read extent map for '%s': %m\", path);\n        log_info(\"extent map information for %s:\", path);\n        log_info(\"\\t start: %\" PRIu64, (uint64_t) fiemap->fm_start);\n        log_info(\"\\t length: %\" PRIu64, (uint64_t) fiemap->fm_length);\n        log_info(\"\\t flags: %\" PRIu32, fiemap->fm_flags);\n        log_info(\"\\t number of mapped extents: %\" PRIu32, fiemap->fm_mapped_extents);\n        log_info(\"\\t extent count: %\" PRIu32, fiemap->fm_extent_count);\n        if (fiemap->fm_extent_count > 0)\n                log_info(\"\\t first extent location: %\" PRIu64,\n                         (uint64_t) (fiemap->fm_extents[0].fe_physical / page_size()));\n\n        return 0;\n}\n\nTEST_RET(fiemap) {\n        int r = 0;\n\n        assert_se(test_fiemap_one(saved_argv[0]) == 0);\n        for (int i = 1; i < saved_argc; i++) {\n                int k = test_fiemap_one(saved_argv[i]);\n                if (r == 0)\n                        r = k;\n        }\n\n        return r;\n}\n\nstatic int intro(void) {\n        if (getuid() != 0)\n                log_warning(\"This program is unlikely to work for unprivileged users\");\n\n        return EXIT_SUCCESS;\n}\n\nDEFINE_TEST_MAIN_WITH_INTRO(LOG_DEBUG, intro);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "375μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "431μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "171965μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "185μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "82μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "173038μs",
      "parallelizable_steps": [],
      "critical_path_length": "172422μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.6
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.6,
        "content_hash": "9e1de5577aaa91b6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-fiemap.c"
      }
    },
    "source_hash": "dba59c33590e"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-ipv4ll.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\n#define IPV4LL_ROUTE_METRIC 2048\n\nbool link_ipv4ll_enabled(Link *link);\n\nint ipv4ll_configure(Link *link);\nint ipv4ll_start(Link *link);\nint link_drop_ipv4ll_config(Link *link, Network *network);\nint ipv4ll_update_mac(Link *link);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_ipv4ll);\nCONFIG_PARSER_PROTOTYPE(config_parse_ipv4ll_address);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "9μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "49μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "115160μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "115μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "191μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "115524μs",
      "parallelizable_steps": [],
      "critical_path_length": "115360μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183,
        "content_hash": "85f6837462626f69"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-ipv4ll.h"
      }
    },
    "source_hash": "46b1e7e04a58"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-utmp.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"format-util.h\"\n#include \"in-addr-util.h\"\n#include \"stdio-util.h\"\n#include \"tests.h\"\n#include \"utmp-wtmp.h\"\n\n#define UTX_LINESIZE sizeof_field(struct utmpx, ut_line)\n#define UTX_NAMESIZE sizeof_field(struct utmpx, ut_user)\n#define UTX_HOSTSIZE sizeof_field(struct utmpx, ut_host)\n\nTEST(dump_run_utmp) {\n        _unused_ _cleanup_(utxent_cleanup) bool utmpx = false;\n\n        utmpx = utxent_start();\n\n        for (struct utmpx *u; (u = getutxent()); ) {\n                char _type_buf[DECIMAL_STR_MAX(short)];\n                const char *type =\n                        u->ut_type == EMPTY         ? \"EMPTY\" :\n                        u->ut_type == RUN_LVL       ? \"RUN_LVL\" :\n                        u->ut_type == BOOT_TIME     ? \"BOOT_TIME\" :\n                        u->ut_type == NEW_TIME      ? \"NEW_TIME\" :\n                        u->ut_type == OLD_TIME      ? \"OLD_TIME\" :\n                        u->ut_type == INIT_PROCESS  ? \"INIT_PROCESS\" :\n                        u->ut_type == LOGIN_PROCESS ? \"LOGIN_PROCESS\" :\n                        u->ut_type == USER_PROCESS  ? \"USER_PROCESS\" :\n                        u->ut_type == DEAD_PROCESS  ? \"DEAD_PROCESS\" :\n                        u->ut_type == ACCOUNTING    ? \"ACCOUNTING\" :\n                        _type_buf;\n                if (type == _type_buf)\n                        xsprintf(_type_buf, \"%hd\", u->ut_type);\n\n                union in_addr_union addr = {};\n                memcpy(&addr, u->ut_addr_v6, MIN(sizeof(addr), sizeof(u->ut_addr_v6)));\n                bool is_ipv4 = memeqzero((const uint8_t*) &addr + 4, sizeof(addr) - 4);\n\n                log_info(\"%14s %10\"PID_PRI\" line=%-7.*s id=%-4.4s name=%-8.*s session=%lu host=%.*s addr=%s\",\n                         type,\n                         u->ut_pid,\n                         (int) UTX_LINESIZE, u->ut_line,\n                         u->ut_id,\n                         (int) UTX_NAMESIZE, u->ut_user,\n                         (long unsigned) u->ut_session,\n                         (int) UTX_HOSTSIZE, u->ut_host,\n                         IN_ADDR_TO_STRING(is_ipv4 ? AF_INET : AF_INET6, &addr));\n        }\n}\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "99μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "9μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "86271μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "5μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "159μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "86543μs",
      "parallelizable_steps": [],
      "critical_path_length": "86529μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.9302325581395349
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.9302325581395349,
        "content_hash": "0c2469c97e33c8c5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-utmp.c"
      }
    },
    "source_hash": "8eb71fc31c75"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-manager-varlink.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n\nint manager_connect_varlink(Manager *m, int fd);\nvoid manager_varlink_done(Manager *m);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "363μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "547μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "33956μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "958μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "181μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "36005μs",
      "parallelizable_steps": [],
      "critical_path_length": "34500μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "d85015d8691e0941"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-manager-varlink.h"
      }
    },
    "source_hash": "c84156d77012"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/firewall-util-private.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"firewall-util.h\"\n#include \"forward.h\"\n\ntypedef enum FirewallBackend {\n        FW_BACKEND_NONE,\n#if HAVE_LIBIPTC\n        FW_BACKEND_IPTABLES,\n#endif\n        FW_BACKEND_NFTABLES,\n        _FW_BACKEND_MAX,\n        _FW_BACKEND_INVALID = -EINVAL,\n} FirewallBackend;\n\nstruct FirewallContext {\n        FirewallBackend backend;\n        sd_netlink *nfnl;\n};\n\nconst char* firewall_backend_to_string(FirewallBackend b) _const_;\n\nint fw_nftables_init(FirewallContext *ctx);\nint fw_nftables_init_full(FirewallContext *ctx, bool init_tables);\nvoid fw_nftables_exit(FirewallContext *ctx);\n\nint fw_nftables_add_masquerade(\n                FirewallContext *ctx,\n                bool add,\n                int af,\n                const union in_addr_union *source,\n                unsigned source_prefixlen);\n\nint fw_nftables_add_local_dnat(\n                FirewallContext *ctx,\n                bool add,\n                int af,\n                int protocol,\n                uint16_t local_port,\n                const union in_addr_union *remote,\n                uint16_t remote_port,\n                const union in_addr_union *previous_remote);\n\n#if HAVE_LIBIPTC\nstruct xtc_handle;\n\nint fw_iptables_add_masquerade(\n                bool add,\n                int af,\n                const union in_addr_union *source,\n                unsigned source_prefixlen);\n\nint fw_iptables_add_local_dnat(\n                bool add,\n                int af,\n                int protocol,\n                uint16_t local_port,\n                const union in_addr_union *remote,\n                uint16_t remote_port,\n                const union in_addr_union *previous_remote);\n\nint fw_iptables_init_nat(struct xtc_handle **ret);\n#endif\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "24μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "22776μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "407μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "109μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "23358μs",
      "parallelizable_steps": [],
      "critical_path_length": "22909μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 1.1320754716981132
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 1.1320754716981132,
        "content_hash": "2241980ab432b33b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/firewall-util-private.h"
      }
    },
    "source_hash": "ff7fde54ef8c"
  },
  {
    "instruction": "Decompose the network operation: QUIC Connection Establishment",
    "input": "Analyze the step-by-step process for: QUIC Connection Establishment",
    "output": {
      "operation": "QUIC Connection Establishment",
      "category": "quic_http3",
      "steps": [
        {
          "step": 1,
          "action": "Generate connection ID and initial keys",
          "expected_time": "695μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Send Initial packet with TLS ClientHello",
          "expected_time": "521409μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Receive and process server Initial packet",
          "expected_time": "257691μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Complete TLS handshake over QUIC",
          "expected_time": "1107μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish 1-RTT protected connection",
          "expected_time": "440091μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1220993μs",
      "parallelizable_steps": [],
      "critical_path_length": "698477μs",
      "metadata": {
        "synthetic": true
      }
    },
    "metadata": {
      "source": "synthetic_generation",
      "category": "quic_http3",
      "complexity": "high",
      "code_analysis": null
    },
    "source_hash": "a33ba919b2c2"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/origin-id.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <pthread.h>\n\n#include \"process-util.h\"\n#include \"random-util.h\"\n\n/* This pattern needs to be repeated exactly in multiple modules, so macro it.\n * To ensure an object is not passed into a different module (e.g.: when two shared objects statically\n * linked to libsystemd get loaded in the same process, and the object created by one is passed to the\n * other, see https://github.com/systemd/systemd/issues/27216), create a random static global random\n * (mixed with PID, so that we can also check for reuse after fork) that is stored in the object and\n * checked by public API on use. */\n#define _DEFINE_ORIGIN_ID_HELPERS(type, name, scope)                  \\\nstatic uint64_t origin_id;                                            \\\n                                                                      \\\nstatic void origin_id_initialize(void) {                              \\\n        origin_id = random_u64();                                     \\\n}                                                                     \\\n                                                                      \\\nstatic uint64_t origin_id_query(void) {                               \\\n        static pthread_once_t once = PTHREAD_ONCE_INIT;               \\\n        assert_se(pthread_once(&once, origin_id_initialize) == 0);    \\\n        return origin_id ^ getpid_cached();                           \\\n}                                                                     \\\n                                                                      \\\nscope bool name##_origin_changed(type *p) {                           \\\n        assert(p);                                                    \\\n        return p->origin_id != origin_id_query();                     \\\n}\n\n#define DEFINE_ORIGIN_ID_HELPERS(type, name)                          \\\n        _DEFINE_ORIGIN_ID_HELPERS(type, name,);\n\n#define DEFINE_PRIVATE_ORIGIN_ID_HELPERS(type, name)                  \\\n        _DEFINE_ORIGIN_ID_HELPERS(type, name, static);\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "195μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "270μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "182862μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "294560μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "210138μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "35404μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "33956μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "219μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "757604μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "426956μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.5625
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.5625,
        "content_hash": "36a1c7b5a9c39400"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/origin-id.h"
      }
    },
    "source_hash": "68fb9485312e"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-llmnr.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\n#define LLMNR_PORT 5355\n\nint manager_llmnr_ipv4_udp_fd(Manager *m);\nint manager_llmnr_ipv6_udp_fd(Manager *m);\nint manager_llmnr_ipv4_tcp_fd(Manager *m);\nint manager_llmnr_ipv6_tcp_fd(Manager *m);\n\nvoid manager_llmnr_stop(Manager *m);\nvoid manager_llmnr_maybe_stop(Manager *m);\nint manager_llmnr_start(Manager *m);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "55μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "341μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "48606μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "65μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "338μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "49405μs",
      "parallelizable_steps": [],
      "critical_path_length": "48999μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 1.8181818181818183,
        "content_hash": "27d5c0e16a567bb6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-llmnr.h"
      }
    },
    "source_hash": "f1c51bbbaeb2"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/service-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <getopt.h>\n#include <stdio.h>\n\n#include \"alloc-util.h\"\n#include \"build.h\"\n#include \"bus-object.h\"\n#include \"log.h\"\n#include \"pretty-print.h\"\n#include \"service-util.h\"\n\nstatic int help(const char *program_path, const char *service, const char *description, bool bus_introspect) {\n        _cleanup_free_ char *link = NULL;\n        int r;\n\n        r = terminal_urlify_man(service, \"8\", &link);\n        if (r < 0)\n                return log_oom();\n\n        printf(\"%1$s [OPTIONS...]\\n\"\n               \"\\n%5$s%7$s%6$s\\n\"\n               \"\\nThis program takes no positional arguments.\\n\"\n               \"\\n%3$sOptions:%4$s\\n\"\n               \"  -h --help                 Show this help\\n\"\n               \"     --version              Show package version\\n\"\n               \"%8$s\"\n               \"\\nSee the %2$s for details.\\n\",\n               program_path,\n               link,\n               ansi_underline(),\n               ansi_normal(),\n               ansi_highlight(),\n               ansi_normal(),\n               description,\n               bus_introspect ? \"     --bus-introspect=PATH  Write D-Bus XML introspection data\\n\" : \"\");\n\n        return 0; /* No further action */\n}\n\nint service_parse_argv(\n                const char *service,\n                const char *description,\n                const BusObjectImplementation* const* bus_objects,\n                int argc, char *argv[]) {\n\n        enum {\n                ARG_VERSION = 0x100,\n                ARG_BUS_INTROSPECT,\n        };\n\n        static const struct option options[] = {\n                { \"help\",           no_argument,       NULL, 'h'                },\n                { \"version\",        no_argument,       NULL, ARG_VERSION        },\n                { \"bus-introspect\", required_argument, NULL, ARG_BUS_INTROSPECT },\n                {}\n        };\n\n        int c;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        while ((c = getopt_long(argc, argv, \"h\", options, NULL)) >= 0)\n                switch (c) {\n\n                case 'h':\n                        return help(argv[0], service, description, bus_objects);\n\n                case ARG_VERSION:\n                        return version();\n\n                case ARG_BUS_INTROSPECT:\n                        return bus_introspect_implementations(\n                                        stdout,\n                                        optarg,\n                                        bus_objects);\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached();\n                }\n\n        if (optind < argc)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"This program takes no arguments.\");\n\n        return 1; /* Further action */\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "126μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "108μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "23767μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "289μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "116μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "24406μs",
      "parallelizable_steps": [],
      "critical_path_length": "24009μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 72,
        "complexity_score": 0.8333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 72,
        "complexity_score": 0.8333333333333333,
        "content_hash": "5d64d82cfd834ffe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/service-util.c"
      }
    },
    "source_hash": "85a53f61dc06"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/local-addresses.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"in-addr-util.h\"\n\nstruct local_address {\n        int ifindex;\n        unsigned char scope;\n        uint32_t priority;\n        uint32_t weight;\n        int family;\n        union in_addr_union address;\n        union in_addr_union prefsrc;\n};\n\nbool has_local_address(const struct local_address *addresses, size_t n_addresses, const struct local_address *needle);\n\nint add_local_address(struct local_address **list, size_t *n_list, int ifindex, unsigned char scope, int family, const union in_addr_union *address);\n\nint local_addresses(sd_netlink *rtnl, int ifindex, int af, struct local_address **ret);\n\nint local_gateways(sd_netlink *rtnl, int ifindex, int af, struct local_address **ret);\n\nint local_outbounds(sd_netlink *rtnl, int ifindex, int af, struct local_address **ret);\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "68μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "367μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "193879μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "820μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "618μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "195752μs",
      "parallelizable_steps": [],
      "critical_path_length": "194565μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 3.888888888888889
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 18,
        "complexity_score": 3.888888888888889,
        "content_hash": "37a54d0771d7aee1"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/local-addresses.h"
      }
    },
    "source_hash": "73634eb5599a"
  },
  {
    "instruction": "Analyze and decompose this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "689μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "593μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "469μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "271399μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "279μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "391μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "273820μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "272383μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      }
    },
    "source_hash": "541989d22c4e"
  },
  {
    "instruction": "Analyze and decompose this tcp_udp code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/boot/url-discovery.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"device-path-util.h\"\n#include \"efi-string.h\"\n#include \"proto/device-path.h\"\n#include \"url-discovery.h\"\n\nchar16_t *disk_get_url(EFI_HANDLE *handle) {\n        EFI_STATUS err;\n        EFI_DEVICE_PATH *dp;\n\n        /* export the device path this image is started from */\n\n        if (!handle)\n                return NULL;\n\n        err = BS->HandleProtocol(handle, MAKE_GUID_PTR(EFI_DEVICE_PATH_PROTOCOL), (void **) &dp);\n        if (err != EFI_SUCCESS)\n                return NULL;\n\n        for (; !device_path_is_end(dp); dp = device_path_next_node(dp)) {\n                if (dp->Type != MESSAGING_DEVICE_PATH || dp->SubType != MSG_URI_DP)\n                        continue;\n\n                URI_DEVICE_PATH *udp = (URI_DEVICE_PATH*) dp;\n                return xstrn8_to_16(udp->Uri, dp->Length);\n        }\n\n        return NULL;\n}\n",
    "output": {
      "operation": "Tcp Udp Implementation",
      "category": "tcp_udp",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "75μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "333μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "43661μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "340μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "34μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "44443μs",
      "parallelizable_steps": [],
      "critical_path_length": "43770μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 22,
        "complexity_score": 2.2727272727272725
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "tcp_udp",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 22,
        "complexity_score": 2.2727272727272725,
        "content_hash": "f9da84884323fe88"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/boot/url-discovery.c"
      }
    },
    "source_hash": "356df3090689"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/analyze/analyze-service-watchdogs.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"analyze.h\"\n#include \"analyze-service-watchdogs.h\"\n#include \"bus-error.h\"\n#include \"bus-locator.h\"\n#include \"bus-util.h\"\n#include \"parse-util.h\"\n#include \"runtime-scope.h\"\n#include \"string-util.h\"\n\nint verb_service_watchdogs(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        int b, r;\n\n        assert(IN_SET(argc, 1, 2));\n        assert(argv);\n\n        r = acquire_bus(&bus, NULL);\n        if (r < 0)\n                return bus_log_connect_error(r, arg_transport, arg_runtime_scope);\n\n        if (argc == 1) {\n                /* get ServiceWatchdogs */\n                r = bus_get_property_trivial(bus, bus_systemd_mgr, \"ServiceWatchdogs\", &error, 'b', &b);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to get service-watchdog state: %s\", bus_error_message(&error, r));\n\n                printf(\"%s\\n\", yes_no(!!b));\n\n        } else {\n                /* set ServiceWatchdogs */\n                b = parse_boolean(argv[1]);\n                if (b < 0)\n                        return log_error_errno(b, \"Failed to parse service-watchdogs argument: %m\");\n\n                r = bus_set_property(bus, bus_systemd_mgr, \"ServiceWatchdogs\", &error, \"b\", b);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to set service-watchdog state: %s\", bus_error_message(&error, r));\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "325μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "257μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "90834μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "72780μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "177262μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "1236μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "135148μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "63μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "477905μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "403244μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.6666666666666665
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.6666666666666665,
        "content_hash": "12a310b331877c39"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/analyze/analyze-service-watchdogs.c"
      }
    },
    "source_hash": "ca52d507d8f8"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dns-resolver-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-dns-resolver.h\"\n\n#include \"forward.h\"\n#include \"socket-netlink.h\"\n\n/* https://www.iana.org/assignments/dns-svcb/dns-svcb.xhtml#dns-svcparamkeys */\nenum {\n        DNS_SVC_PARAM_KEY_MANDATORY       = 0, /* RFC 9460 § 8 */\n        DNS_SVC_PARAM_KEY_ALPN            = 1, /* RFC 9460 § 7.1 */\n        DNS_SVC_PARAM_KEY_NO_DEFAULT_ALPN = 2, /* RFC 9460 § 7.1 */\n        DNS_SVC_PARAM_KEY_PORT            = 3, /* RFC 9460 § 7.2 */\n        DNS_SVC_PARAM_KEY_IPV4HINT        = 4, /* RFC 9460 § 7.3 */\n        DNS_SVC_PARAM_KEY_ECH             = 5, /* RFC 9460 */\n        DNS_SVC_PARAM_KEY_IPV6HINT        = 6, /* RFC 9460 § 7.3  */\n        DNS_SVC_PARAM_KEY_DOHPATH         = 7, /* RFC 9461 */\n        DNS_SVC_PARAM_KEY_OHTTP           = 8,\n        _DNS_SVC_PARAM_KEY_MAX_DEFINED,\n        DNS_SVC_PARAM_KEY_INVALID         = 65535 /* RFC 9460 */\n};\n\nconst char* dns_svc_param_key_to_string(int i) _const_;\nconst char* format_dns_svc_param_key(uint16_t i, char buf[static DECIMAL_STR_MAX(uint16_t)+3]);\n#define FORMAT_DNS_SVC_PARAM_KEY(i) format_dns_svc_param_key(i, (char [DECIMAL_STR_MAX(uint16_t)+3]) {})\n\n/* Represents a \"designated resolver\" */\n/* typedef struct sd_dns_resolver sd_dns_resolver; */\ntypedef struct sd_dns_resolver {\n        uint16_t priority;\n        char *auth_name;\n        int family;\n        union in_addr_union *addrs;\n        size_t n_addrs;\n        sd_dns_alpn_flags transports;\n        uint16_t port;\n        char *dohpath;\n} sd_dns_resolver;\n\nvoid siphash24_compress_resolver(const sd_dns_resolver *res, struct siphash *state);\n\nint dns_resolver_transports_to_strv(sd_dns_alpn_flags transports, char ***ret);\n\nint dns_resolvers_to_dot_addrs(const sd_dns_resolver *resolvers, size_t n_resolvers,\n                struct in_addr_full ***ret_addrs, size_t *ret_n_addrs);\n\nint dns_resolver_prio_compare(const sd_dns_resolver *a, const sd_dns_resolver *b);\n\nint dnr_parse_svc_params(const uint8_t *option, size_t len, sd_dns_resolver *resolver);\n\nint dns_resolvers_to_dot_strv(const sd_dns_resolver *resolvers, size_t n_resolvers, char ***ret_names);\n\nvoid sd_dns_resolver_done(sd_dns_resolver *res);\n\nvoid dns_resolver_done_many(sd_dns_resolver *resolvers, size_t n);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "163μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "14μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "24131μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "134788μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "17μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "159148μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "134819μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.1627906976744187
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.1627906976744187,
        "content_hash": "a6b27e4ec84c527b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dns-resolver-internal.h"
      }
    },
    "source_hash": "57555123db21"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/efi-loader.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/* Various calls that interface with EFI variables implementing https://systemd.io/BOOT_LOADER_INTERFACE */\n\nint efi_loader_get_device_part_uuid(sd_id128_t *ret);\nint efi_stub_get_device_part_uuid(sd_id128_t *ret);\nint efi_loader_get_boot_usec(usec_t *ret_firmware, usec_t *ret_loader);\n\nint efi_loader_get_entries(char ***ret);\n\nint efi_loader_get_features(uint64_t *ret);\nint efi_stub_get_features(uint64_t *ret);\n\nint efi_measured_uki(int log_level);\n\nint efi_loader_get_config_timeout_one_shot(usec_t *ret);\nint efi_loader_update_entry_one_shot_cache(char **cache, struct stat *cache_stat);\n\nint efi_get_variable_id128(const char *variable, sd_id128_t *ret);\n\nbool efi_loader_entry_name_valid(const char *s);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "943μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "326189μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "764μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2475μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "348836μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "327μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "679534μs",
      "parallelizable_steps": [],
      "critical_path_length": "350543μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 3.333333333333333,
        "content_hash": "46649860e8767504"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/efi-loader.h"
      }
    },
    "source_hash": "1c36f185cae8"
  },
  {
    "instruction": "Analyze and decompose this general_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/analyze/analyze-verify.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"analyze.h\"\n#include \"analyze-verify-util.h\"\n#include \"analyze-verify.h\"\n#include \"copy.h\"\n#include \"extract-word.h\"\n#include \"log.h\"\n#include \"path-util.h\"\n#include \"rm-rf.h\"\n#include \"runtime-scope.h\"\n#include \"strv.h\"\n#include \"tmpfile-util.h\"\n\nstatic int process_aliases(char *argv[], char *tempdir, char ***ret) {\n        _cleanup_strv_free_ char **filenames = NULL;\n        int r;\n\n        assert(argv);\n        assert(tempdir);\n        assert(ret);\n\n        STRV_FOREACH(filename, strv_skip(argv, 1)) {\n                _cleanup_free_ char *src = NULL, *dst = NULL, *base = NULL;\n                const char *parse_arg;\n\n                parse_arg = *filename;\n                r = extract_first_word(&parse_arg, &src, \":\", EXTRACT_DONT_COALESCE_SEPARATORS|EXTRACT_RETAIN_ESCAPE);\n                if (r < 0)\n                        return r;\n\n                if (!parse_arg) {\n                        r = strv_consume(&filenames, TAKE_PTR(src));\n                        if (r < 0)\n                                return r;\n\n                        continue;\n                }\n\n                r = path_extract_filename(parse_arg, &base);\n                if (r < 0)\n                        return r;\n\n                dst = path_join(tempdir, base);\n                if (!dst)\n                        return -ENOMEM;\n\n                r = copy_file(src, dst, 0, 0644, COPY_REFLINK);\n                if (r < 0)\n                        return r;\n\n                r = strv_consume(&filenames, TAKE_PTR(dst));\n                if (r < 0)\n                        return r;\n        }\n\n        *ret = TAKE_PTR(filenames);\n        return 0;\n}\n\nint verb_verify(int argc, char *argv[], void *userdata) {\n        _cleanup_strv_free_ char **filenames = NULL;\n        _cleanup_(rm_rf_physical_and_freep) char *tempdir = NULL;\n        int r;\n\n        r = mkdtemp_malloc(\"/tmp/systemd-analyze-XXXXXX\", &tempdir);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to setup working directory: %m\");\n\n        r = process_aliases(argv, tempdir, &filenames);\n        if (r < 0)\n                return log_error_errno(r, \"Couldn't process aliases: %m\");\n\n        return verify_units(filenames, arg_runtime_scope, arg_man, arg_generators, arg_recursive_errors, arg_root);\n}\n",
    "output": {
      "operation": "General Networking Implementation",
      "category": "general_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "440μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "155μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "159045μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "338μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "192μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "160170μs",
      "parallelizable_steps": [],
      "critical_path_length": "159677μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 60,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "general_networking",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 60,
        "complexity_score": 2.5,
        "content_hash": "e66ca5e042e153e9"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/analyze/analyze-verify.c"
      }
    },
    "source_hash": "e0c4195e61b9"
  },
  {
    "instruction": "Analyze and decompose this tcp_udp code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/fuzz-journald-stream.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <linux/sockios.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n\n#include \"sd-event.h\"\n\n#include \"fd-util.h\"\n#include \"fuzz.h\"\n#include \"fuzz-journald-util.h\"\n#include \"journald-stream.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_close_pair_ int stream_fds[2] = EBADF_PAIR;\n        _cleanup_(manager_freep) Manager *m = NULL;\n        StdoutStream *stream;\n        int v, fd0;\n\n        if (outside_size_range(size, 1, 65536))\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(socketpair(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0, stream_fds) >= 0);\n        dummy_manager_new(&m, NULL, 0);\n\n        assert_se(stdout_stream_install(m, stream_fds[0], &stream) >= 0);\n        fd0 = TAKE_FD(stream_fds[0]); /* avoid double close */\n\n        assert_se(write(stream_fds[1], data, size) == (ssize_t) size);\n        while (ioctl(fd0, SIOCINQ, &v) == 0 && v)\n                sd_event_run(m->event, UINT64_MAX);\n\n        if (m->n_stdout_streams > 0)\n                stdout_stream_terminate(stream);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Tcp Udp Implementation",
      "category": "tcp_udp",
      "steps": [
        {
          "step": 1,
          "action": "Initialize components and variables",
          "expected_time": "219μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Process input data and parameters",
          "expected_time": "154μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            0
          ]
        },
        {
          "step": 3,
          "action": "Execute core networking operations",
          "expected_time": "82135μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle response and error conditions",
          "expected_time": "312μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Cleanup resources and connections",
          "expected_time": "8μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        }
      ],
      "complexity": "medium",
      "estimated_total_time": "82828μs",
      "parallelizable_steps": [],
      "critical_path_length": "82362μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 28,
        "complexity_score": 1.4285714285714284
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "tcp_udp",
      "complexity": "medium",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 28,
        "complexity_score": 1.4285714285714284,
        "content_hash": "65b305d71b804437"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/fuzz-journald-stream.c"
      }
    },
    "source_hash": "693068bd3d41"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/dns-def.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/* Length of a single label, with all escaping removed, excluding any trailing dot or NUL byte */\n#define DNS_LABEL_MAX 63\n\n/* Worst case length of a single label, with all escaping applied and room for a trailing NUL byte. */\n#define DNS_LABEL_ESCAPED_MAX (DNS_LABEL_MAX*4+1)\n\n/* Maximum length of a full hostname, consisting of a series of unescaped labels, and no trailing dot or NUL byte */\n#define DNS_HOSTNAME_MAX 253\n\n/* Maximum length of a full hostname, on the wire, including the final NUL byte */\n#define DNS_WIRE_FORMAT_HOSTNAME_MAX 255\n\n/* Maximum number of labels per valid hostname */\n#define DNS_N_LABELS_MAX 127\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "38μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "17μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "575338μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "25813μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "209μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "210μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "601625μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "575547μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 13,
        "complexity_score": 4.615384615384616
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 13,
        "complexity_score": 4.615384615384616,
        "content_hash": "2c588e81d60f0174"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/dns-def.h"
      }
    },
    "source_hash": "de9f493984bc"
  }
]