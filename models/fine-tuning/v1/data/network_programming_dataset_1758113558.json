[
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"main-func.h\"\n#include \"tests.h\"\n\nstatic int test_ref_unref(void) {\n        sd_bus_message *m = NULL;\n        sd_bus *bus = NULL;\n        int r;\n\n        /* This test will result in a memory leak in <= v240, but not on v241. Hence to be really useful it\n         * should be run through a leak tracker such as valgrind. */\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                return log_tests_skipped(\"Failed to connect to bus\");\n\n        /* Create a message and enqueue it (this shouldn't send it though as the connection setup is not complete yet) */\n        assert_se(sd_bus_message_new_method_call(bus, &m, \"foo.bar\", \"/foo\", \"quux.quux\", \"waldo\") >= 0);\n        assert_se(sd_bus_send(bus, m, NULL) >= 0);\n\n        /* Let's now unref the message first and the bus second. */\n        m = sd_bus_message_unref(m);\n        bus = sd_bus_unref(bus);\n\n        /* We should have a memory leak now on <= v240. Let's do this again, but destroy in the opposite\n         * order. On v240 that too should be a leak. */\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                return log_tests_skipped(\"Failed to connect to bus\");\n\n        assert_se(sd_bus_message_new_method_call(bus, &m, \"foo.bar\", \"/foo\", \"quux.quux\", \"waldo\") >= 0);\n        assert_se(sd_bus_send(bus, m, NULL) >= 0);\n\n        /* Let's now unref things in the opposite order */\n        bus = sd_bus_unref(bus);\n        m = sd_bus_message_unref(m);\n\n        return 0;\n}\n\nstatic int run(int argc, char *argv[]) {\n        int r;\n\n        test_setup_logging(LOG_INFO);\n\n        r = test_ref_unref();\n        if (r < 0)\n                return r;\n\n        return 0;\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "169μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "41μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "117163μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "147932μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "32473μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "137005μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "170μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "434953μs",
      "parallelizable_steps": [],
      "critical_path_length": "284978μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 1.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 40,
        "complexity_score": 1.0,
        "content_hash": "4f245af99e7b24bb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-bus/test-bus-queue-ref-cycle.c"
      }
    },
    "source_hash": "8d8e310b16ee"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-journal/audit-type.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <stdio.h>\n\n#include \"forward.h\"\n\nconst char* audit_type_to_string(int type);\nint audit_type_from_string(const char *s);\n\n/* This is inspired by DNS TYPEnnn formatting */\n#define audit_type_name_alloca(type)                                    \\\n        ({                                                              \\\n                const char *_s_;                                        \\\n                _s_ = audit_type_to_string(type);                       \\\n                if (!_s_) {                                             \\\n                        _s_ = newa(char, STRLEN(\"AUDIT\") + DECIMAL_STR_MAX(int)); \\\n                        sprintf((char*) _s_, \"AUDIT%04i\", type);        \\\n                }                                                       \\\n                _s_;                                                    \\\n        })\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "262μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "109μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "279679μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "130110μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "282μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "32μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "410474μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "279961μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 17,
        "complexity_score": 2.3529411764705883
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 17,
        "complexity_score": 2.3529411764705883,
        "content_hash": "9a4695a84ab331da"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-journal/audit-type.h"
      }
    },
    "source_hash": "af6713142a28"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: man/check-os-release.py\n\nCode:\n#!/usr/bin/python\n# SPDX-License-Identifier: MIT-0\n\nimport ast\nimport re\nimport sys\n\ndef read_os_release():\n    try:\n        filename = '/etc/os-release'\n        f = open(filename)\n    except FileNotFoundError:\n        filename = '/usr/lib/os-release'\n        f = open(filename)\n\n    for line_number, line in enumerate(f, start=1):\n        line = line.rstrip()\n        if not line or line.startswith('#'):\n            continue\n        m = re.match(r'([A-Z][A-Z_0-9]+)=(.*)', line)\n        if m:\n            name, val = m.groups()\n            if val and val[0] in '\"\\'':\n                val = ast.literal_eval(val)\n            yield name, val\n        else:\n            print(f'{filename}:{line_number}: bad line {line!r}',\n                  file=sys.stderr)\n\nos_release = dict(read_os_release())\n\npretty_name = os_release.get('PRETTY_NAME', 'Linux')\nprint(f'Running on {pretty_name!r}')\n\nif 'debian' in [os_release.get('ID', 'linux'),\n                *os_release.get('ID_LIKE', '').split()]:\n    print('Looks like Debian!')\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "14μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "50μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "348248μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "507661μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "563596μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "531669μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "159812μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "17μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "2111067μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1071656μs",
      "metadata": {
        "functions_found": [
          "read_os_release"
        ],
        "classes_found": [],
        "imports": [
          "ast",
          "re",
          "sys"
        ],
        "lines_of_code": 31,
        "complexity_score": 2.903225806451613
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [
          "read_os_release"
        ],
        "classes": [],
        "imports": [
          "ast",
          "re",
          "sys"
        ],
        "lines_of_code": 31,
        "complexity_score": 2.903225806451613,
        "content_hash": "34f909320046a786"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "man/check-os-release.py"
      }
    },
    "source_hash": "46cbf1da7a92"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/hostname-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"strv.h\"\n\nchar* get_default_hostname_raw(void);\n\nbool valid_ldh_char(char c) _const_;\n\ntypedef enum ValidHostnameFlags {\n        VALID_HOSTNAME_TRAILING_DOT  = 1 << 0,   /* Accept trailing dot on multi-label names */\n        VALID_HOSTNAME_DOT_HOST      = 1 << 1,   /* Accept \".host\" as valid hostname */\n        VALID_HOSTNAME_QUESTION_MARK = 1 << 2,   /* Accept \"?\" as place holder for hashed machine ID value */\n} ValidHostnameFlags;\n\nbool hostname_is_valid(const char *s, ValidHostnameFlags flags) _pure_;\nchar* hostname_cleanup(char *s);\n\nbool is_localhost(const char *hostname);\n\nstatic inline bool is_gateway_hostname(const char *hostname) {\n        /* This tries to identify the valid syntaxes for the our synthetic \"gateway\" host. */\n        return STRCASE_IN_SET(hostname, \"_gateway\", \"_gateway.\");\n}\n\nstatic inline bool is_outbound_hostname(const char *hostname) {\n        /* This tries to identify the valid syntaxes for the our synthetic \"outbound\" host. */\n        return STRCASE_IN_SET(hostname, \"_outbound\", \"_outbound.\");\n}\n\nstatic inline bool is_dns_stub_hostname(const char *hostname) {\n        return STRCASE_IN_SET(hostname, \"_localdnsstub\", \"_localdnsstub.\");\n}\n\nstatic inline bool is_dns_proxy_stub_hostname(const char *hostname) {\n        return STRCASE_IN_SET(hostname, \"_localdnsproxy\", \"_localdnsproxy.\");\n}\n\nconst char* etc_hostname(void);\nconst char* etc_machine_info(void);\n\nint get_pretty_hostname(char **ret);\n\nint machine_spec_valid(const char *s);\nint split_user_at_host(const char *s, char **ret_user, char **ret_host);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "337μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "4μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "227939μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "356202μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "310599μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "309317μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "362μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1204760μs",
      "parallelizable_steps": [],
      "critical_path_length": "665523μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 2.121212121212121
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 2.121212121212121,
        "content_hash": "789f9790a4b7fa3b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/hostname-util.h"
      }
    },
    "source_hash": "109f20ae9aea"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/reply-password/reply-password.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"fd-util.h\"\n#include \"fileio.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"socket-util.h\"\n#include \"string-util.h\"\n\nstatic int send_on_socket(int fd, const char *socket_name, const void *packet, size_t size) {\n        union sockaddr_union sa = {};\n        int salen;\n\n        assert(fd >= 0);\n        assert(socket_name);\n        assert(packet);\n\n        salen = sockaddr_un_set_path(&sa.un, socket_name);\n        if (salen < 0)\n                return log_error_errno(salen, \"Specified socket path for AF_UNIX socket invalid, refusing: %s\", socket_name);\n\n        if (sendto(fd, packet, size, MSG_NOSIGNAL, &sa.sa, salen) < 0)\n                return log_error_errno(errno, \"Failed to send: %m\");\n\n        return 0;\n}\n\nstatic int run(int argc, char *argv[]) {\n        _cleanup_(erase_and_freep) char *packet = NULL;\n        _cleanup_close_ int fd = -EBADF;\n        size_t length = 0;\n        int r;\n\n        log_setup();\n\n        if (argc != 3)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), \"Wrong number of arguments.\");\n\n        if (streq(argv[1], \"1\")) {\n                _cleanup_(erase_and_freep) char *line = NULL;\n\n                r = read_line(stdin, LONG_LINE_MAX, &line);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to read password: %m\");\n                if (r == 0)\n                        return log_error_errno(SYNTHETIC_ERRNO(EIO),\n                                               \"Got EOF while reading password.\");\n\n                packet = strjoin(\"+\", line);\n                if (!packet)\n                        return log_oom();\n\n                length = 1 + strlen(line) + 1;\n\n        } else if (streq(argv[1], \"0\")) {\n                packet = strdup(\"-\");\n                if (!packet)\n                        return log_oom();\n\n                length = 1;\n\n        } else\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Invalid first argument %s\", argv[1]);\n\n        fd = socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);\n        if (fd < 0)\n                return log_error_errno(errno, \"socket() failed: %m\");\n\n        return send_on_socket(fd, argv[2], packet, length);\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "374μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "2μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "367914μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "158382μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "67717μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "330508μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "329μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "925226μs",
      "parallelizable_steps": [],
      "critical_path_length": "488892μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926,
        "content_hash": "932f8f09d1d22307"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/reply-password/reply-password.c"
      }
    },
    "source_hash": "f7b2248228d4"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/coredump-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum CoredumpFilter {\n        COREDUMP_FILTER_PRIVATE_ANONYMOUS = 0,\n        COREDUMP_FILTER_SHARED_ANONYMOUS,\n        COREDUMP_FILTER_PRIVATE_FILE_BACKED,\n        COREDUMP_FILTER_SHARED_FILE_BACKED,\n        COREDUMP_FILTER_ELF_HEADERS,\n        COREDUMP_FILTER_PRIVATE_HUGE,\n        COREDUMP_FILTER_SHARED_HUGE,\n        COREDUMP_FILTER_PRIVATE_DAX,\n        COREDUMP_FILTER_SHARED_DAX,\n        _COREDUMP_FILTER_MAX,\n        _COREDUMP_FILTER_INVALID = -EINVAL,\n} CoredumpFilter;\n\n#define COREDUMP_FILTER_MASK_DEFAULT (1u << COREDUMP_FILTER_PRIVATE_ANONYMOUS | \\\n                                      1u << COREDUMP_FILTER_SHARED_ANONYMOUS | \\\n                                      1u << COREDUMP_FILTER_ELF_HEADERS | \\\n                                      1u << COREDUMP_FILTER_PRIVATE_HUGE)\n\n/* The kernel doesn't like UINT64_MAX and returns ERANGE, use UINT32_MAX to support future new flags */\n#define COREDUMP_FILTER_MASK_ALL UINT32_MAX\n\ntypedef enum SuidDumpMode {\n        SUID_DUMP_DISABLE = 0,  /* PR_SET_DUMPABLE(2const) */\n        SUID_DUMP_USER    = 1,  /* PR_SET_DUMPABLE(2const) */\n        SUID_DUMP_SAFE    = 2,  /* https://www.kernel.org/doc/html/latest/admin-guide/sysctl/fs.html#suid-dumpable */\n        _SUID_DUMP_MODE_MAX,\n} SuidDumpMode;\n\nint set_dumpable(SuidDumpMode mode);\n\nconst char* coredump_filter_to_string(CoredumpFilter i) _const_;\nCoredumpFilter coredump_filter_from_string(const char *s) _pure_;\nint coredump_filter_mask_from_string(const char *s, uint64_t *ret);\n\nint parse_auxv(int log_level,\n               uint8_t elf_class,\n               const void *auxv,\n               size_t size_bytes,\n               int *at_secure,\n               uid_t *uid,\n               uid_t *euid,\n               gid_t *gid,\n               gid_t *egid);\n\nint set_coredump_filter(uint64_t value);\nvoid disable_coredumps(void);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "60μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "127861μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "314μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "27659μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "162μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "156109μs",
      "parallelizable_steps": [],
      "critical_path_length": "128337μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.46511627906976744
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.46511627906976744,
        "content_hash": "9768807c83d9fe52"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/coredump-util.h"
      }
    },
    "source_hash": "cdbf58741cec"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udev-error.c\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0-or-later */\n\n#include \"device-monitor-private.h\"\n#include \"device-private.h\"\n#include \"device-util.h\"\n#include \"errno-list.h\"\n#include \"errno-util.h\"\n#include \"signal-util.h\"\n#include \"udev-error.h\"\n\nint device_add_errno(sd_device *dev, int error) {\n        int r;\n\n        assert(dev);\n\n        if (error == 0)\n                return 0;\n\n        error = ABS(error);\n\n        r = device_add_property(dev, \"UDEV_WORKER_FAILED\", \"1\");\n        RET_GATHER(r, device_add_propertyf(dev, \"UDEV_WORKER_ERRNO\", \"%i\", error));\n\n        const char *str = errno_name_no_fallback(error);\n        if (str)\n                RET_GATHER(r, device_add_property(dev, \"UDEV_WORKER_ERRNO_NAME\", str));\n\n        return r;\n}\n\nint device_add_exit_status(sd_device *dev, int status) {\n        int r;\n\n        assert(dev);\n\n        if (status == 0)\n                return 0;\n\n        r = device_add_property(dev, \"UDEV_WORKER_FAILED\", \"1\");\n        return RET_GATHER(r, device_add_propertyf(dev, \"UDEV_WORKER_EXIT_STATUS\", \"%i\", status));\n}\n\nint device_add_signal(sd_device *dev, int signo) {\n        int r;\n\n        assert(dev);\n\n        r = device_add_property(dev, \"UDEV_WORKER_FAILED\", \"1\");\n        RET_GATHER(r, device_add_propertyf(dev, \"UDEV_WORKER_SIGNAL\", \"%i\", signo));\n\n        const char *str = signal_to_string(signo);\n        if (str)\n                RET_GATHER(r, device_add_property(dev, \"UDEV_WORKER_SIGNAL_NAME\", str));\n\n        return r;\n}\n\nint device_broadcast_on_error(sd_device *dev, sd_device_monitor *monitor) {\n        int r;\n\n        assert(dev);\n        assert(monitor);\n\n        /* delete state from disk */\n        (void) device_delete_db(dev);\n        (void) device_tag_index(dev, /* device_old = */ NULL, /* add = */ false);\n\n        r = device_monitor_send(monitor, /* destination = */ NULL, dev);\n        if (r < 0) {\n                uint64_t seqnum = 0;\n\n                (void) sd_device_get_seqnum(dev, &seqnum);\n                return log_device_warning_errno(dev, r, \"Failed to broadcast event (SEQNUM=%\"PRIu64\") to libudev listeners: %m\", seqnum);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "109μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "157μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "4595μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "208062μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "57451μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "85806μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "74499μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "86μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "430765μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "294111μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 1.1111111111111112
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 1.1111111111111112,
        "content_hash": "ba94e0349079144f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udev-error.c"
      }
    },
    "source_hash": "c71ee98cb39e"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-bus-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-util.h\"\n#include \"log.h\"\n#include \"tests.h\"\n\nstatic int callback(sd_bus_message *m, void *userdata, sd_bus_error *ret_error) {\n        return 1;\n}\n\nstatic void destroy_callback(void *userdata) {\n        int *n_called = userdata;\n\n        (*n_called)++;\n}\n\nTEST(destroy_callback) {\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        sd_bus_slot *slot = NULL;\n        sd_bus_destroy_t t;\n\n        int r, n_called = 0;\n\n        r = bus_open_system_watch_bind_with_description(&bus, \"test-bus\");\n        if (r < 0)\n                return (void) log_error_errno(r, \"Failed to connect to bus: %m\");\n\n        ASSERT_OK_EQ(sd_bus_request_name_async(bus, &slot, \"org.freedesktop.systemd.test-bus-util\", 0, callback, &n_called),\n                     1);\n\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, NULL), 0);\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, &t), 0);\n\n        ASSERT_EQ(sd_bus_slot_set_destroy_callback(slot, destroy_callback), 0);\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, NULL), 1);\n        ASSERT_EQ(sd_bus_slot_get_destroy_callback(slot, &t), 1);\n        assert_se(t == destroy_callback);\n\n        /* Force cleanup so we can look at n_called */\n        ASSERT_EQ(n_called, 0);\n        sd_bus_slot_unref(slot);\n        ASSERT_EQ(n_called, 1);\n}\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "188μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "24μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "286099μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "221133μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "218011μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "208361μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "101μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "933917μs",
      "parallelizable_steps": [],
      "critical_path_length": "504399μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.4705882352941178
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 34,
        "complexity_score": 1.4705882352941178,
        "content_hash": "780663527faa2961"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-bus-util.c"
      }
    },
    "source_hash": "8a6a0dbb2240"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/coverage/coverage.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n/* Use the coverage-related tweaks below only for C stuff as they're not really\n * C++ compatible, and the only thing that is built with a C++ compiler is\n * the lone test-bus-vtable-cc unit test.\n */\n#ifndef __cplusplus\n\nvoid __gcov_dump(void);\nvoid __gcov_reset(void);\n\n/* When built with --coverage (gcov) we need to explicitly call __gcov_dump()\n * in places where we use _exit(), since _exit() skips at-exit hooks resulting\n * in lost coverage.\n *\n * To make sure we don't miss any _exit() calls, this header file is included\n * explicitly on the compiler command line via the -include directive (only\n * when built with -Db_coverage=true)\n */\nvoid _exit(int);\n\nstatic inline _Noreturn void _coverage__exit(int status) {\n        __gcov_dump();\n        _exit(status);\n}\n#define _exit(x) _coverage__exit(x)\n\n/* gcov provides wrappers for the exec*() calls but there's none for execveat()\n * and execvpe() which means we lose all coverage prior to such call. To mitigate\n * this, let's add simple wrappers in gcov's style[0] for these exec*() calls,\n * which dump and reset the coverage data as needed.\n *\n * [0] https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libgcc/libgcov-interface.c;h=b2ee930864183b78c8826255183ca86e15e21ded;hb=HEAD\n */\n\nint execveat(int, const char *, char * const [], char * const [], int);\nint execvpe(const char *, char * const [], char * const []);\n\nstatic inline int _coverage_execveat(\n                        int dirfd,\n                        const char *pathname,\n                        char * const argv[],\n                        char * const envp[],\n                        int flags) {\n        __gcov_dump();\n        int r = execveat(dirfd, pathname, argv, envp, flags);\n        __gcov_reset();\n\n        return r;\n}\n#define execveat(d,p,a,e,f) _coverage_execveat(d, p, a, e, f)\n\nstatic inline int _coverage_execvpe(\n                        const char *file,\n                        char * const argv[],\n                        char * const envp[]) {\n        __gcov_dump();\n        int r = execvpe(file, argv, envp);\n        __gcov_reset();\n\n        return r;\n}\n#define execvpe(f,a,e) _coverage_execvpe(f, a, e)\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "156μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "701575μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1423μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1454μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "8593μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "11μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "713212μs",
      "parallelizable_steps": [],
      "critical_path_length": "703040μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 1.8181818181818183
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 55,
        "complexity_score": 1.8181818181818183,
        "content_hash": "cb6492ea23e9a441"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/coverage/coverage.h"
      }
    },
    "source_hash": "fc44d179641d"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/bpf/socket-bind/socket-bind-skel.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n/* The SPDX header above is actually correct in claiming this was\n * LGPL-2.1-or-later, because it is. Since the kernel doesn't consider that\n * compatible with GPL we will claim this to be GPL however, which should be\n * fine given that LGPL-2.1-or-later downgrades to GPL if needed.\n */\n\n#include \"bpf-dlopen.h\"\n\n/* libbpf is used via dlopen(), so rename symbols */\n#define bpf_object__open_skeleton sym_bpf_object__open_skeleton\n#define bpf_object__load_skeleton sym_bpf_object__load_skeleton\n#define bpf_object__destroy_skeleton sym_bpf_object__destroy_skeleton\n\n#include \"bpf/socket-bind/socket-bind.skel.h\"\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "302μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "208μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "308027μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "34120μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "202285μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "97738μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "164μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "642844μs",
      "parallelizable_steps": [],
      "critical_path_length": "510778μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 12,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 12,
        "complexity_score": 2.5,
        "content_hash": "ad0851910e4c7942"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/bpf/socket-bind/socket-bind-skel.h"
      }
    },
    "source_hash": "39a47bebe69b"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-memfd-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <unistd.h>\n\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"memfd-util.h\"\n#include \"tests.h\"\n\nTEST(memfd_get_sealed) {\n#define TEST_TEXT \"this is some random test text we are going to write to a memfd\"\n        _cleanup_close_ int fd = memfd_new_full(\"test-memfd-get-sealed\", MFD_ALLOW_SEALING);\n        if (fd < 0) {\n                ASSERT_TRUE(ERRNO_IS_NOT_SUPPORTED(fd));\n                return (void) log_tests_skipped_errno(fd, \"Failed to create new memfd\");\n        }\n        ASSERT_OK_EQ_ERRNO(write(fd, TEST_TEXT, strlen(TEST_TEXT)), (ssize_t) strlen(TEST_TEXT));\n        /* we'll leave the read offset at the end of the memfd, the fdopen_independent() descriptors should\n         * start at the beginning anyway */\n\n        uint64_t size, new_size;\n        ASSERT_OK(memfd_get_size(fd, &size));\n        ASSERT_GE(size, (uint64_t) strlen(TEST_TEXT));\n\n        ASSERT_OK(memfd_set_size(fd, size * 2));\n        ASSERT_OK(memfd_get_size(fd, &new_size));\n        ASSERT_EQ(new_size, size * 2);\n\n        ASSERT_OK(memfd_set_size(fd, new_size / 2));\n        ASSERT_OK(memfd_get_size(fd, &size));\n        ASSERT_EQ(size, new_size / 2);\n\n        ASSERT_OK_ZERO(memfd_get_sealed(fd));\n        ASSERT_OK(memfd_set_sealed(fd));\n        ASSERT_OK_POSITIVE(memfd_get_sealed(fd));\n}\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "52μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "93μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "28170μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "118557μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "17340μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "69499μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "60103μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "49μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "293863μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "188198μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 0.6666666666666666,
        "content_hash": "822c7a159ce74b0d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-memfd-util.c"
      }
    },
    "source_hash": "eb09bc07ea13"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/id128-print.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdio.h>\n\n#include \"sd-id128.h\"\n\n#include \"alloc-util.h\"\n#include \"id128-print.h\"\n#include \"log.h\"\n#include \"pretty-print.h\"\n\nint id128_pretty_print_sample(const char *name, sd_id128_t id) {\n        _cleanup_free_ char *man_link = NULL, *mod_link = NULL;\n\n        const char *on = ansi_highlight(),\n                   *off = ansi_normal();\n\n        if (terminal_urlify(\"man:systemd-id128(1)\", \"systemd-id128(1)\", &man_link) < 0)\n                return log_oom();\n\n        if (terminal_urlify(\"https://docs.python.org/3/library/uuid.html\", \"uuid\", &mod_link) < 0)\n                return log_oom();\n\n        printf(\"As string:\\n\"\n               \"%s\" SD_ID128_FORMAT_STR \"%s\\n\\n\"\n               \"As UUID:\\n\"\n               \"%s\" SD_ID128_UUID_FORMAT_STR \"%s\\n\\n\"\n               \"As %s macro:\\n\"\n               \"%s#define %s SD_ID128_MAKE(\",\n               on, SD_ID128_FORMAT_VAL(id), off,\n               on, SD_ID128_FORMAT_VAL(id), off,\n               man_link,\n               on, name);\n        for (size_t i = 0; i < 16; i++)\n                printf(\"%02x%s\", id.bytes[i], i < 15 ? \",\" : \"\");\n        printf(\")%s\\n\\n\", off);\n\n        printf(\"As Python constant:\\n\"\n               \">>> import %s\\n\"\n               \">>> %s%s = uuid.UUID('\" SD_ID128_FORMAT_STR \"')%s\\n\",\n               mod_link,\n               on, name, SD_ID128_FORMAT_VAL(id), off);\n\n        return 0;\n}\n\nint id128_pretty_print(sd_id128_t id, Id128PrettyPrintMode mode) {\n        assert(mode >= 0);\n        assert(mode < _ID128_PRETTY_PRINT_MODE_MAX);\n\n        if (mode == ID128_PRINT_ID128) {\n                printf(SD_ID128_FORMAT_STR \"\\n\",\n                       SD_ID128_FORMAT_VAL(id));\n                return 0;\n        } else if (mode == ID128_PRINT_UUID) {\n                printf(SD_ID128_UUID_FORMAT_STR \"\\n\",\n                       SD_ID128_FORMAT_VAL(id));\n                return 0;\n        } else\n                return id128_pretty_print_sample(\"XYZ\", id);\n}\n\nint id128_print_new(Id128PrettyPrintMode mode) {\n        sd_id128_t id;\n        int r;\n\n        r = sd_id128_randomize(&id);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to generate ID: %m\");\n\n        return id128_pretty_print(id, mode);\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "792μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "790318μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2033μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "449μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "545938μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "76μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1339606μs",
      "parallelizable_steps": [],
      "critical_path_length": "790843μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.333333333333333,
        "content_hash": "be601aa31d5084b3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/id128-print.c"
      }
    },
    "source_hash": "49d243b24c24"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/override/sys/socket.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include_next <sys/socket.h>\n\n/* Supported since kernel v6.5 (5e2ff6704a275be009be8979af17c52361b79b89) */\n#ifndef SO_PASSPIDFD\n#define SO_PASSPIDFD 76\n#endif\n\n/* Supported since kernel v6.5 (7b26952a91cf65ff1cc867a2382a8964d8c0ee7d) */\n#ifndef SO_PEERPIDFD\n#define SO_PEERPIDFD 77\n#endif\n\n/* Supported since kernel v6.16 (77cbe1a6d8730a07f99f9263c2d5f2304cf5e830) */\n#ifndef SO_PASSRIGHTS\n#define SO_PASSRIGHTS 83\n#endif\n\n/* Not exposed yet. Defined in include/linux/socket.h. */\n#ifndef SOL_SCTP\n#define SOL_SCTP 132\n#endif\n\n/* Supported since kernel v2.6.17 (2c7946a7bf45ae86736ab3b43d0085e43947945c).\n * Defined since glibc-2.39 */\n#ifndef SCM_SECURITY\n#define SCM_SECURITY 0x03\n#endif\n\n/* Supported since kernel v6.5 (5e2ff6704a275be009be8979af17c52361b79b89).\n * Defined since glibc-2.39 */\n#ifndef SCM_PIDFD\n#define SCM_PIDFD 0x04\n#endif\n\n/* The maximum number of fds that SCM_RIGHTS accepts. This is an internal kernel constant defined in\n * include/net/scm.h, but very much useful for userspace too. It's documented in unix(7) these days, hence\n * should be fairly reliable to define here. */\n#ifndef SCM_MAX_FD\n#define SCM_MAX_FD 253U\n#endif\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "715μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "260μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "344747μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "908392μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "467526μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "122654μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "232μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1844526μs",
      "parallelizable_steps": [],
      "critical_path_length": "1031306μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 4.571428571428571
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 4.571428571428571,
        "content_hash": "8a3c2a622f254cee"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/override/sys/socket.h"
      }
    },
    "source_hash": "3a8189d3fb94"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/wait-online/dns-configuration.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/uio.h>\n\n#include \"forward.h\"\n\ntypedef struct DNSServer {\n        struct iovec addr;\n        int family;\n        uint16_t port;\n        int ifindex;\n        char *server_name;\n        bool accessible;\n} DNSServer;\n\nDNSServer* dns_server_free(DNSServer *s);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DNSServer*, dns_server_free);\n\ntypedef struct SearchDomain {\n        char *name;\n        bool route_only;\n        int ifindex;\n} SearchDomain;\n\nSearchDomain* search_domain_free(SearchDomain *d);\nDEFINE_TRIVIAL_CLEANUP_FUNC(SearchDomain*, search_domain_free);\n\ntypedef struct DNSConfiguration {\n        char *ifname;\n        int ifindex;\n        bool default_route;\n        DNSServer *current_dns_server;\n        Set *dns_servers;\n        Set *search_domains;\n} DNSConfiguration;\n\nDNSConfiguration* dns_configuration_free(DNSConfiguration *c);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DNSConfiguration*, dns_configuration_free);\n\nint dns_configuration_from_json(sd_json_variant *variant, DNSConfiguration **ret);\nbool dns_is_accessible(DNSConfiguration *c);\nbool dns_configuration_contains_search_domain(DNSConfiguration *c, const char *domain);\n\nextern const struct hash_ops dns_configuration_hash_ops;\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "213μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "3μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "180236μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "19119μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "273μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "70μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "199914μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "180509μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 1.7142857142857144
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 1.7142857142857144,
        "content_hash": "39d4be5feb31e15c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/wait-online/dns-configuration.h"
      }
    },
    "source_hash": "c7222a7e9f46"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: hwdb.d/acpi-update.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\nfrom csv import reader\n\n# pylint: disable=consider-using-with\n\ndef read_table(filename):\n    table = list(reader(open(filename, newline='')))\n    table = table[1:]  # Skip header\n    table.sort(key=lambda x: x[1])\n\n    for row in table:\n        # Some IDs end with whitespace, while they didn't in the old HTML table, so it's probably\n        # a mistake, strip it.\n        print(f'\\nacpi:{row[1].strip()}*:\\n ID_VENDOR_FROM_DATABASE={row[0].strip()}')\n\nprint('''\\\n# This file is part of systemd.\n#\n# Data imported from:\n#     https://uefi.org/uefi-pnp-export\n#     https://uefi.org/uefi-acpi-export''')\n\nread_table('acpi_id_registry.csv')\nread_table('pnp_id_registry.csv')\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "47μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "119740μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2439μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2735μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "408897μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1033μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "534891μs",
      "parallelizable_steps": [],
      "critical_path_length": "411383μs",
      "metadata": {
        "functions_found": [
          "read_table"
        ],
        "classes_found": [],
        "imports": [
          "csv"
        ],
        "lines_of_code": 20,
        "complexity_score": 3.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "read_table"
        ],
        "classes": [],
        "imports": [
          "csv"
        ],
        "lines_of_code": 20,
        "complexity_score": 3.5,
        "content_hash": "50317ad3489f99c1"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "hwdb.d/acpi-update.py"
      }
    },
    "source_hash": "eb04718bc8e7"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/filter.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n/*\n * Linux Socket Filter Data Structures\n */\n\n#ifndef __LINUX_FILTER_H__\n#define __LINUX_FILTER_H__\n\n\n#include <linux/types.h>\n#include <linux/bpf_common.h>\n\n/*\n * Current version of the filter code architecture.\n */\n#define BPF_MAJOR_VERSION 1\n#define BPF_MINOR_VERSION 1\n\n/*\n *\tTry and keep these values and structures similar to BSD, especially\n *\tthe BPF code definitions which need to match so you can share filters\n */\n \nstruct sock_filter {\t/* Filter block */\n\t__u16\tcode;   /* Actual filter code */\n\t__u8\tjt;\t/* Jump true */\n\t__u8\tjf;\t/* Jump false */\n\t__u32\tk;      /* Generic multiuse field */\n};\n\nstruct sock_fprog {\t/* Required for SO_ATTACH_FILTER. */\n\tunsigned short\t\tlen;\t/* Number of filter blocks */\n\tstruct sock_filter *filter;\n};\n\n/* ret - BPF_K and BPF_X also apply */\n#define BPF_RVAL(code)  ((code) & 0x18)\n#define         BPF_A           0x10\n\n/* misc */\n#define BPF_MISCOP(code) ((code) & 0xf8)\n#define         BPF_TAX         0x00\n#define         BPF_TXA         0x80\n\n/*\n * Macros for filter block array initializers.\n */\n#ifndef BPF_STMT\n#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }\n#endif\n#ifndef BPF_JUMP\n#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }\n#endif\n\n/*\n * Number of scratch memory words for: BPF_ST and BPF_STX\n */\n#define BPF_MEMWORDS 16\n\n/* RATIONALE. Negative offsets are invalid in BPF.\n   We use them to reference ancillary data.\n   Unlike introduction new instructions, it does not break\n   existing compilers/optimizers.\n */\n#define SKF_AD_OFF    (-0x1000)\n#define SKF_AD_PROTOCOL 0\n#define SKF_AD_PKTTYPE \t4\n#define SKF_AD_IFINDEX \t8\n#define SKF_AD_NLATTR\t12\n#define SKF_AD_NLATTR_NEST\t16\n#define SKF_AD_MARK \t20\n#define SKF_AD_QUEUE\t24\n#define SKF_AD_HATYPE\t28\n#define SKF_AD_RXHASH\t32\n#define SKF_AD_CPU\t36\n#define SKF_AD_ALU_XOR_X\t40\n#define SKF_AD_VLAN_TAG\t44\n#define SKF_AD_VLAN_TAG_PRESENT 48\n#define SKF_AD_PAY_OFFSET\t52\n#define SKF_AD_RANDOM\t56\n#define SKF_AD_VLAN_TPID\t60\n#define SKF_AD_MAX\t64\n\n#define SKF_NET_OFF\t(-0x100000)\n#define SKF_LL_OFF\t(-0x200000)\n\n#define BPF_NET_OFF\tSKF_NET_OFF\n#define BPF_LL_OFF\tSKF_LL_OFF\n\n#endif /* __LINUX_FILTER_H__ */\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "318μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "127μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "279783μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "332424μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "289730μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "174689μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "275μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1077346μs",
      "parallelizable_steps": [],
      "critical_path_length": "570106μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.7333333333333334
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 75,
        "complexity_score": 1.7333333333333334,
        "content_hash": "aeb1560f02eff26d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/filter.h"
      }
    },
    "source_hash": "b670217b8af4"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp6-option.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcp6optionhfoo\n#define foosddhcp6optionhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n#include \"sd-dhcp6-protocol.h\"  /* IWYU pragma: export */\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp6_option sd_dhcp6_option;\n\nint sd_dhcp6_option_new(uint16_t option, const void *data, size_t length, uint32_t enterprise_identifier, sd_dhcp6_option **ret);\nsd_dhcp6_option *sd_dhcp6_option_ref(sd_dhcp6_option *ra);\nsd_dhcp6_option *sd_dhcp6_option_unref(sd_dhcp6_option *ra);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp6_option, sd_dhcp6_option_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "19μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1557292μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1700μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2642μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "493583μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1599μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "2056835μs",
      "parallelizable_steps": [],
      "critical_path_length": "1561533μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.4
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.4,
        "content_hash": "c382c77861603970"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp6-option.h"
      }
    },
    "source_hash": "77a166c8f502"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-zone.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-forward.h\"\n\ntypedef struct DnsZone {\n        Hashmap *by_key;\n        Hashmap *by_name;\n} DnsZone;\n\n/* RFC 4795 Section 2.8. suggests a TTL of 30s by default */\n#define LLMNR_DEFAULT_TTL (30)\n\n/* RFC 6762 Section 10. suggests a TTL of 120s by default */\n#define MDNS_DEFAULT_TTL (120)\n\ntypedef enum DnsZoneItemState {\n        DNS_ZONE_ITEM_PROBING,\n        DNS_ZONE_ITEM_ESTABLISHED,\n        DNS_ZONE_ITEM_VERIFYING,\n        DNS_ZONE_ITEM_WITHDRAWN,\n} DnsZoneItemState;\n\ntypedef struct DnsZoneItem {\n        DnsScope *scope;\n        DnsResourceRecord *rr;\n\n        DnsZoneItemState state;\n\n        unsigned block_ready;\n\n        bool probing_enabled;\n\n        LIST_FIELDS(DnsZoneItem, by_key);\n        LIST_FIELDS(DnsZoneItem, by_name);\n\n        DnsTransaction *probe_transaction;\n} DnsZoneItem;\n\nvoid dns_zone_flush(DnsZone *z);\n\nint dns_zone_put(DnsZone *z, DnsScope *s, DnsResourceRecord *rr, bool probe);\nDnsZoneItem* dns_zone_get(DnsZone *z, DnsResourceRecord *rr);\nvoid dns_zone_remove_rr(DnsZone *z, DnsResourceRecord *rr);\nint dns_zone_remove_rrs_by_key(DnsZone *z, DnsResourceKey *key);\n\nint dns_zone_lookup(DnsZone *z, DnsResourceKey *key, int ifindex, DnsAnswer **answer, DnsAnswer **soa, bool *tentative);\n\nvoid dns_zone_item_conflict(DnsZoneItem *i);\nvoid dns_zone_item_notify(DnsZoneItem *i);\n\nint dns_zone_check_conflicts(DnsZone *zone, DnsResourceRecord *rr);\nint dns_zone_verify_conflicts(DnsZone *zone, DnsResourceKey *key);\n\nvoid dns_zone_verify_all(DnsZone *zone);\n\nvoid dns_zone_item_probe_stop(DnsZoneItem *i);\n\nvoid dns_zone_dump(DnsZone *zone, FILE *f);\nbool dns_zone_is_empty(DnsZone *zone);\nbool dns_zone_contains_name(DnsZone *z, const char *name);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "46μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "41μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "148566μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "320667μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "5μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "30μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "469355μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "320738μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.8604651162790697
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.8604651162790697,
        "content_hash": "5a6e1195fa1874c2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-zone.h"
      }
    },
    "source_hash": "f065c414e271"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-pretty-print.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdio.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"pretty-print.h\"\n#include \"tests.h\"\n\n#define CYLON_WIDTH 6\n\nstatic void test_draw_cylon_one(unsigned pos) {\n        char buf[CYLON_WIDTH + CYLON_BUFFER_EXTRA + 1];\n\n        log_debug(\"/* %s(%u) */\", __func__, pos);\n\n        assert(pos <= CYLON_WIDTH + 1);\n\n        memset(buf, 0xff, sizeof(buf));\n        draw_cylon(buf, sizeof(buf), CYLON_WIDTH, pos);\n        ASSERT_LE(strlen(buf), sizeof(buf));\n}\n\nTEST(draw_cylon) {\n        bool saved = log_get_show_color();\n\n        log_show_color(false);\n        for (unsigned i = 0; i <= CYLON_WIDTH + 1; i++)\n                test_draw_cylon_one(i);\n\n        log_show_color(true);\n        for (unsigned i = 0; i <= CYLON_WIDTH + 1; i++)\n                test_draw_cylon_one(i);\n\n        log_show_color(saved);\n}\n\nTEST(terminal_urlify) {\n        _cleanup_free_ char *formatted = NULL;\n\n        assert_se(terminal_urlify(\"https://www.freedesktop.org/wiki/Software/systemd\", \"systemd homepage\", &formatted) >= 0);\n        printf(\"Hey, consider visiting the %s right now! It is very good!\\n\", formatted);\n\n        formatted = mfree(formatted);\n\n        assert_se(terminal_urlify_path(\"/etc/fstab\", \"this link to your /etc/fstab\", &formatted) >= 0);\n        printf(\"Or click on %s to have a look at it!\\n\", formatted);\n}\n\nTEST(cat_files) {\n        assert_se(cat_files(\"/no/such/file\", NULL, 0) == -ENOENT);\n        assert_se(cat_files(NULL, NULL, 0) == 0);\n\n        if (access(\"/etc/fstab\", R_OK) >= 0)\n                assert_se(cat_files(\"/etc/fstab\", STRV_MAKE(\"/etc/fstab\", \"/etc/fstab\"), 0) == 0);\n}\n\nTEST(red_green_cross_check_mark) {\n        bool b = false;\n\n        printf(\"yea: <%s>\\n\", GREEN_CHECK_MARK());\n        printf(\"nay: <%s>\\n\", RED_CROSS_MARK());\n\n        printf(\"%s → %s → %s → %s\\n\",\n               COLOR_MARK_BOOL(b),\n               COLOR_MARK_BOOL(!b),\n               COLOR_MARK_BOOL(!!b),\n               COLOR_MARK_BOOL(!!!b));\n}\n\nTEST(print_separator) {\n        print_separator();\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "394μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "751302μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "339μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1323μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "160423μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "680μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "914461μs",
      "parallelizable_steps": [],
      "critical_path_length": "753305μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 2.641509433962264
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 2.641509433962264,
        "content_hash": "f0a06b8b3d9e72fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-pretty-print.c"
      }
    },
    "source_hash": "c5d79fa0b990"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-trust-anchor.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\n/* This contains a fixed database mapping domain names to DS or DNSKEY records. */\n\ntypedef struct DnsTrustAnchor {\n        Hashmap *positive_by_key;\n        Set *negative_by_name;\n        Set *revoked_by_rr;\n} DnsTrustAnchor;\n\nint dns_trust_anchor_load(DnsTrustAnchor *d);\nvoid dns_trust_anchor_flush(DnsTrustAnchor *d);\n\nint dns_trust_anchor_lookup_positive(DnsTrustAnchor *d, const DnsResourceKey* key, DnsAnswer **answer);\nint dns_trust_anchor_lookup_negative(DnsTrustAnchor *d, const char *name);\n\nint dns_trust_anchor_check_revoked(DnsTrustAnchor *d, DnsResourceRecord *dnskey, DnsAnswer *rrs);\nint dns_trust_anchor_is_revoked(DnsTrustAnchor *d, DnsResourceRecord *rr);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "97μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "65μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "261010μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "96792μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "190μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "36μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "358190μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "261200μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 1.3333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 1.3333333333333333,
        "content_hash": "5c705c51c4e0a4ec"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-trust-anchor.h"
      }
    },
    "source_hash": "ecfeb19266a5"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/generator/network-generator.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <stdio.h>\n\n#include \"ether-addr-util.h\"\n#include \"hashmap.h\"\n#include \"in-addr-util.h\"\n#include \"list.h\"\n\ntypedef enum DHCPType {\n        DHCP_TYPE_NONE,\n        DHCP_TYPE_OFF,   /* Same as DHCP_TYPE_NONE */\n        DHCP_TYPE_ON,\n        DHCP_TYPE_ANY,   /* Same as DHCP_TYPE_ON */\n        DHCP_TYPE_DHCP,  /* Actually means: DHCPv4 */\n        DHCP_TYPE_DHCP6,\n        DHCP_TYPE_AUTO6,\n        DHCP_TYPE_EITHER6,\n        DHCP_TYPE_IBFT,\n        DHCP_TYPE_LINK6,\n        DHCP_TYPE_LINK_LOCAL,\n        _DHCP_TYPE_MAX,\n        _DHCP_TYPE_INVALID = -EINVAL,\n} DHCPType;\n\ntypedef struct Address Address;\ntypedef struct Link Link;\ntypedef struct NetDev NetDev;\ntypedef struct Network Network;\ntypedef struct Route Route;\ntypedef struct Context Context;\n\nstruct Address {\n        Network *network;\n\n        union in_addr_union address, peer;\n        unsigned char prefixlen;\n        int family;\n\n        LIST_FIELDS(Address, addresses);\n};\n\nstruct Route {\n        Network *network;\n\n        union in_addr_union dest, gateway;\n        unsigned char prefixlen;\n        int family;\n\n        LIST_FIELDS(Route, routes);\n};\n\nstruct Network {\n        /* [Match] */\n        char *ifname;\n\n        /* [Link] */\n        struct ether_addr mac;\n        uint32_t mtu;\n\n        /* [Network] */\n        DHCPType dhcp_type;\n        char **dns;\n        char **vlan;\n        char *bridge;\n        char *bond;\n\n        /* [DHCP] */\n        char *hostname;\n        int dhcp_use_dns;\n\n        LIST_HEAD(Address, addresses);\n        LIST_HEAD(Route, routes);\n};\n\nstruct NetDev {\n        /* [NetDev] */\n        char *ifname;\n        char *kind;\n        uint32_t mtu;\n\n        /* [VLAN] */\n        uint16_t vlan_id;\n};\n\nstruct Link {\n        char *filename;\n\n        /* [Match] */\n        struct hw_addr_data mac;\n\n        /* [Link] */\n        char *ifname;\n        char **policies;\n        char **alt_policies;\n};\n\ntypedef struct Context {\n        Hashmap *networks_by_name;\n        Hashmap *netdevs_by_name;\n        Hashmap *links_by_filename;\n} Context;\n\nint parse_cmdline_item(const char *key, const char *value, void *data);\nint context_merge_networks(Context *context);\nvoid context_clear(Context *context);\n\nNetwork *network_get(Context *context, const char *ifname);\nvoid network_dump(Network *network, FILE *f);\nint network_format(Network *network, char **ret);\n\nNetDev *netdev_get(Context *context, const char *ifname);\nvoid netdev_dump(NetDev *netdev, FILE *f);\nint netdev_format(NetDev *netdev, char **ret);\n\nLink *link_get(Context *context, const char *filename);\nvoid link_dump(Link *link, FILE *f);\nint link_format(Link *link, char **ret);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "120μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "14μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "16769μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "164474μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "98μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "8μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "181483μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "164496μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 94,
        "complexity_score": 0.9574468085106382
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 94,
        "complexity_score": 0.9574468085106382,
        "content_hash": "050c7d8876ee6033"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/generator/network-generator.h"
      }
    },
    "source_hash": "a25f51ab5d8d"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/uki.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <stdbool.h>\n\n/* List of PE sections that have special meaning for us in unified kernels. This is the canonical order in\n * which we measure the sections into TPM PCR 11. PLEASE DO NOT REORDER! */\ntypedef enum UnifiedSection {\n        UNIFIED_SECTION_LINUX,\n        UNIFIED_SECTION_OSREL,\n        UNIFIED_SECTION_CMDLINE,\n        UNIFIED_SECTION_INITRD,\n        UNIFIED_SECTION_UCODE,\n        UNIFIED_SECTION_SPLASH,\n        UNIFIED_SECTION_DTB,\n        UNIFIED_SECTION_UNAME,\n        UNIFIED_SECTION_SBAT,\n        UNIFIED_SECTION_PCRSIG,\n        UNIFIED_SECTION_PCRPKEY,\n        UNIFIED_SECTION_PROFILE,\n        UNIFIED_SECTION_DTBAUTO,\n        UNIFIED_SECTION_HWIDS,\n        UNIFIED_SECTION_EFIFW,\n        _UNIFIED_SECTION_MAX,\n} UnifiedSection;\n\nextern const char* const unified_sections[_UNIFIED_SECTION_MAX + 1];\n\nstatic inline bool unified_section_measure(UnifiedSection section) {\n        /* Don't include the PCR signature in the PCR measurements, since they sign the expected result of\n         * the measurement, and hence shouldn't be input to it. */\n        return section >= 0 && section < _UNIFIED_SECTION_MAX && section != UNIFIED_SECTION_PCRSIG;\n}\n\n/* Max number of profiles per UKI */\n#define UNIFIED_PROFILES_MAX 256U\n\n/* The native PE machine type, if known, for a full list see:\n * https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types */\n#ifndef _IMAGE_FILE_MACHINE_NATIVE\n#  if defined(__x86_64__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x8664)\n#  elif defined(__i386__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x014c)\n#  elif defined(__ia64__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x0200)\n#  elif defined(__aarch64__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0xaa64)\n#  elif defined(__arm__)\n#    define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x01c0)\n#  elif defined(__riscv)\n#    if __SIZEOF_POINTER__ == 4\n#      define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x5032)\n#    elif __SIZEOF_POINTER__ == 8\n#      define _IMAGE_FILE_MACHINE_NATIVE UINT16_C(0x5064)\n#    endif\n#  endif\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1543μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "3080627μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "5055μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "6373μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "1549335μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1174μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "4644107μs",
      "parallelizable_steps": [],
      "critical_path_length": "3088174μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 8.461538461538462
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 8.461538461538462,
        "content_hash": "9f118bcb918cd7fa"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/uki.h"
      }
    },
    "source_hash": "3c445eeb444f"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/origin-id.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <pthread.h>\n\n#include \"process-util.h\"\n#include \"random-util.h\"\n\n/* This pattern needs to be repeated exactly in multiple modules, so macro it.\n * To ensure an object is not passed into a different module (e.g.: when two shared objects statically\n * linked to libsystemd get loaded in the same process, and the object created by one is passed to the\n * other, see https://github.com/systemd/systemd/issues/27216), create a random static global random\n * (mixed with PID, so that we can also check for reuse after fork) that is stored in the object and\n * checked by public API on use. */\n#define _DEFINE_ORIGIN_ID_HELPERS(type, name, scope)                  \\\nstatic uint64_t origin_id;                                            \\\n                                                                      \\\nstatic void origin_id_initialize(void) {                              \\\n        origin_id = random_u64();                                     \\\n}                                                                     \\\n                                                                      \\\nstatic uint64_t origin_id_query(void) {                               \\\n        static pthread_once_t once = PTHREAD_ONCE_INIT;               \\\n        assert_se(pthread_once(&once, origin_id_initialize) == 0);    \\\n        return origin_id ^ getpid_cached();                           \\\n}                                                                     \\\n                                                                      \\\nscope bool name##_origin_changed(type *p) {                           \\\n        assert(p);                                                    \\\n        return p->origin_id != origin_id_query();                     \\\n}\n\n#define DEFINE_ORIGIN_ID_HELPERS(type, name)                          \\\n        _DEFINE_ORIGIN_ID_HELPERS(type, name,);\n\n#define DEFINE_PRIVATE_ORIGIN_ID_HELPERS(type, name)                  \\\n        _DEFINE_ORIGIN_ID_HELPERS(type, name, static);\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "4μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "250μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "148022μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "245983μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "133242μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "160663μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "109369μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "219μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "797752μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "407115μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.5625
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.5625,
        "content_hash": "36a1c7b5a9c39400"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/origin-id.h"
      }
    },
    "source_hash": "68fb9485312e"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-varlink.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"journald-forward.h\"\n\nint manager_open_varlink(Manager *m, const char *socket, int fd);\n\nvoid sync_req_varlink_reply(SyncReq *req);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "353μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "106μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "771000μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "635479μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "587854μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "506447μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "50μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "2501289μs",
      "parallelizable_steps": [],
      "critical_path_length": "1359257μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "fc2b32e385be0c22"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-varlink.h"
      }
    },
    "source_hash": "67d87235dbb4"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/chid-fundamental.h\n\nCode:\n/* SPDX-License-Identifier: BSD-3-Clause */\n\n#pragma once\n\n#if SD_BOOT\n#  include \"efi.h\"\n#else\n#  include <uchar.h>\n#endif\n\n#include \"efi-fundamental.h\"\n\n#define CHID_TYPES_MAX 18\n/* Any chids starting from EXTRA_CHID_BASE are non-standard and are subject to change and renumeration at any time */\n#define EXTRA_CHID_BASE 15\n\ntypedef enum ChidSmbiosFields {\n        CHID_SMBIOS_MANUFACTURER,\n        CHID_SMBIOS_FAMILY,\n        CHID_SMBIOS_PRODUCT_NAME,\n        CHID_SMBIOS_PRODUCT_SKU,\n        CHID_SMBIOS_BASEBOARD_MANUFACTURER,\n        CHID_SMBIOS_BASEBOARD_PRODUCT,\n        CHID_SMBIOS_BIOS_VENDOR,\n        CHID_SMBIOS_BIOS_VERSION,\n        CHID_SMBIOS_BIOS_MAJOR,\n        CHID_SMBIOS_BIOS_MINOR,\n        CHID_SMBIOS_ENCLOSURE_TYPE,\n        CHID_EDID_PANEL,\n        _CHID_SMBIOS_FIELDS_MAX,\n} ChidSmbiosFields;\n\nextern const uint32_t chid_smbios_table[CHID_TYPES_MAX];\n\n/* CHID (also called HWID by fwupd) is described at https://github.com/fwupd/fwupd/blob/main/docs/hwids.md */\nvoid chid_calculate(const char16_t *const smbios_fields[static _CHID_SMBIOS_FIELDS_MAX], EFI_GUID ret_chids[static CHID_TYPES_MAX]);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "269μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "322890μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "163μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "661μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "30521μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "338μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "354842μs",
      "parallelizable_steps": [],
      "critical_path_length": "323889μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 29,
        "complexity_score": 1.0344827586206897
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 29,
        "complexity_score": 1.0344827586206897,
        "content_hash": "073683b4231e8278"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/chid-fundamental.h"
      }
    },
    "source_hash": "a9acf5413aa1"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ipv4ll.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdipv4llfoo\n#define foosdipv4llfoo\n\n/***\n  Copyright © 2014 Axis Communications AB. All rights reserved.\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in_addr;\n\ntypedef struct sd_event sd_event;\n\nenum {\n        SD_IPV4LL_EVENT_STOP            = 0,\n        SD_IPV4LL_EVENT_BIND            = 1,\n        SD_IPV4LL_EVENT_CONFLICT        = 2\n};\n\ntypedef struct sd_ipv4ll sd_ipv4ll;\ntypedef void (*sd_ipv4ll_callback_t)(sd_ipv4ll *ll, int event, void *userdata);\ntypedef int (*sd_ipv4ll_check_mac_callback_t)(sd_ipv4ll *ll, const struct ether_addr *mac, void *userdata);\n\nint sd_ipv4ll_detach_event(sd_ipv4ll *ll);\nint sd_ipv4ll_attach_event(sd_ipv4ll *ll, sd_event *event, int64_t priority);\nint sd_ipv4ll_get_address(sd_ipv4ll *ll, struct in_addr *address);\nint sd_ipv4ll_set_callback(sd_ipv4ll *ll, sd_ipv4ll_callback_t cb, void *userdata);\nint sd_ipv4ll_set_check_mac_callback(sd_ipv4ll *ll, sd_ipv4ll_check_mac_callback_t cb, void *userdata);\nint sd_ipv4ll_set_mac(sd_ipv4ll *ll, const struct ether_addr *addr);\nint sd_ipv4ll_set_timeout(sd_ipv4ll *ll, uint64_t usec);\nint sd_ipv4ll_set_ifindex(sd_ipv4ll *ll, int interface_index);\nint sd_ipv4ll_get_ifindex(sd_ipv4ll *ll);\nint sd_ipv4ll_set_ifname(sd_ipv4ll *ll, const char *interface_name);\nint sd_ipv4ll_get_ifname(sd_ipv4ll *ll, const char **ret);\nint sd_ipv4ll_set_address(sd_ipv4ll *ll, const struct in_addr *address);\nint sd_ipv4ll_set_address_seed(sd_ipv4ll *ll, uint64_t seed);\nint sd_ipv4ll_is_running(sd_ipv4ll *ll);\nint sd_ipv4ll_restart(sd_ipv4ll *ll);\nint sd_ipv4ll_start(sd_ipv4ll *ll);\nint sd_ipv4ll_stop(sd_ipv4ll *ll);\nsd_ipv4ll *sd_ipv4ll_ref(sd_ipv4ll *ll);\nsd_ipv4ll *sd_ipv4ll_unref(sd_ipv4ll *ll);\nint sd_ipv4ll_new(sd_ipv4ll **ret);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ipv4ll, sd_ipv4ll_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "134μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "18870μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1093μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "795μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "407675μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "104μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "428671μs",
      "parallelizable_steps": [],
      "critical_path_length": "408902μs",
      "metadata": {
        "functions_found": [
          "void",
          "int"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "void",
          "int"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692,
        "content_hash": "ff8c8a8957924859"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ipv4ll.h"
      }
    },
    "source_hash": "52d902d0fa01"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: test/units/TEST-69-SHUTDOWN.py\n\nCode:\n#!/usr/bin/python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n# pylint: disable=broad-except\n\nimport logging\nimport sys\n\nimport pexpect\n\n\ndef main():\n    # TODO: drop once https://bugs.debian.org/1075733 is fixed\n    with open(\"/usr/lib/os-release\") as f:\n        for line in f:\n            if line.startswith(\"ID=\"):\n                if \"debian\" in line or \"ubuntu\" in line:\n                    sys.exit(77)\n\n    logger = logging.getLogger(\"test-shutdown\")\n\n    consoles = []\n    for _ in range(2):\n        # Use script to allocate a separate pseudo tty to run the login shell in.\n        console = pexpect.spawn(\n            \"script\", [\"--quiet\", \"--return\", \"--flush\", \"--command\", \"login -f root\", \"/dev/null\"],\n            logfile=sys.stdout,\n            env={\"TERM\": \"dumb\"},\n            encoding=\"utf-8\",\n            timeout=60,\n        )\n\n        logger.info(\"waiting for login prompt\")\n        console.expect(\".*# \", 10)\n\n        consoles += [console]\n\n    consoles[1].sendline(\"tty\")\n    consoles[1].expect(r\"/dev/(pts/\\d+)\")\n    pty = console.match.group(1)\n    logger.info(\"window 1 at tty %s\", pty)\n\n    logger.info(\"schedule reboot\")\n    consoles[1].sendline(\"shutdown -r\")\n    consoles[1].expect(\"Reboot scheduled for (?P<date>.*), use 'shutdown -c' to cancel\", 2)\n    date = consoles[1].match.group(\"date\")\n    logger.info(\"reboot scheduled for %s\", date)\n\n    logger.info(\"verify broadcast message\")\n    consoles[0].expect(f\"Broadcast message from root@H on {pty}\", 2)\n    consoles[0].expect(f\"The system will reboot at {date}!\", 2)\n\n    logger.info(\"check show output\")\n    consoles[1].sendline(\"shutdown --show\")\n    consoles[1].expect(f\"Reboot scheduled for {date}, use 'shutdown -c' to cancel\", 2)\n\n    logger.info(\"cancel shutdown\")\n    consoles[1].sendline(\"shutdown -c\")\n    consoles[0].expect(\"System shutdown has been cancelled\", 2)\n\n    consoles[0].sendline(\"> /testok\")\n\nif __name__ == \"__main__\":\n    main()\n\n# vim: sw=4 et\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "643μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "764840μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "858μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1794μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "308873μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "551μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1077559μs",
      "parallelizable_steps": [],
      "critical_path_length": "767185μs",
      "metadata": {
        "functions_found": [
          "main"
        ],
        "classes_found": [],
        "imports": [
          "logging",
          "sys",
          "pexpect"
        ],
        "lines_of_code": 49,
        "complexity_score": 2.8571428571428568
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "main"
        ],
        "classes": [],
        "imports": [
          "logging",
          "sys",
          "pexpect"
        ],
        "lines_of_code": 49,
        "complexity_score": 2.8571428571428568,
        "content_hash": "e1ba2e4951525dc0"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "test/units/TEST-69-SHUTDOWN.py"
      }
    },
    "source_hash": "d65082eefe6f"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udev-builtin-btrfs.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <fcntl.h>\n#include <linux/btrfs.h>\n#include <sys/ioctl.h>\n\n#include \"device-util.h\"\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"string-util.h\"\n#include \"udev-builtin.h\"\n\nstatic int builtin_btrfs(UdevEvent *event, int argc, char *argv[]) {\n        sd_device *dev = ASSERT_PTR(ASSERT_PTR(event)->dev);\n        int r;\n\n        if (!IN_SET(argc, 2, 3) || !streq(argv[1], \"ready\"))\n                return log_device_error_errno(dev, SYNTHETIC_ERRNO(EINVAL), \"Invalid arguments.\");\n\n        const char *node;\n        r = sd_device_get_devname(dev, &node);\n        if (r < 0)\n                return log_device_error_errno(dev, r, \"Failed to get device node: %m\");\n\n        if (argc == 3 && !streq(argv[2], node))\n                return log_device_debug_errno(dev, SYNTHETIC_ERRNO(EINVAL), \"Device node '%s' is not owned by the device, it must be '%s'.\", argv[2], node);\n\n        if (strlen(node) >= sizeof_field(struct btrfs_ioctl_vol_args, name))\n                return log_device_debug_errno(dev, SYNTHETIC_ERRNO(EINVAL), \"Device name too long for BTRFS_IOC_DEVICES_READY call: %s\", node);\n\n        if (event->event_mode != EVENT_UDEV_WORKER) {\n                log_device_debug(dev, \"Running in test mode, skipping execution of 'btrfs' builtin command.\");\n                return 0;\n        }\n\n        _cleanup_close_ int fd = open(\"/dev/btrfs-control\", O_RDWR|O_CLOEXEC|O_NOCTTY);\n        if (fd < 0) {\n                if (ERRNO_IS_DEVICE_ABSENT_OR_EMPTY(errno)) {\n                        /* Driver not installed? Then we aren't ready. This is useful in initrds that lack\n                         * btrfs.ko. After the host transition (where btrfs.ko will hopefully become\n                         * available) the device can be retriggered and will then be considered ready. */\n                        udev_builtin_add_property(event, \"ID_BTRFS_READY\", \"0\");\n                        return 0;\n                }\n\n                return log_device_debug_errno(dev, errno, \"Failed to open %s: %m\", \"/dev/btrfs-control\");\n        }\n\n        struct btrfs_ioctl_vol_args args = {};\n        strncpy(args.name, node, sizeof(args.name)-1);\n        r = ioctl(fd, BTRFS_IOC_DEVICES_READY, &args);\n        if (r < 0)\n                return log_device_debug_errno(dev, errno, \"Failed to call BTRFS_IOC_DEVICES_READY: %m\");\n\n        udev_builtin_add_property(event, \"ID_BTRFS_READY\", one_zero(r == 0));\n        return 0;\n}\n\nconst UdevBuiltin udev_builtin_btrfs = {\n        .name = \"btrfs\",\n        .cmd = builtin_btrfs,\n        .help = \"btrfs volume management\",\n};\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "47μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "316μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "45757μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "28030μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "7578μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "44509μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "137280μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "339μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "263856μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "190615μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 2.0,
        "content_hash": "aeed37d21c7ea08a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udev-builtin-btrfs.c"
      }
    },
    "source_hash": "97f26d3f8def"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/plymouth-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"fd-util.h\"\n#include \"io-util.h\"\n#include \"log.h\"\n#include \"plymouth-util.h\"\n#include \"socket-util.h\"\n\nint plymouth_connect(int flags) {\n        static const union sockaddr_union sa = {\n                .un.sun_family = AF_UNIX,\n                .un.sun_path = \"\\0/org/freedesktop/plymouthd\",\n        };\n        _cleanup_close_ int fd = -EBADF;\n\n        fd = socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|flags, 0);\n        if (fd < 0)\n                return -errno;\n\n        if (connect(fd, &sa.sa, sockaddr_un_len(&sa.un)) < 0)\n                return -errno;\n\n        return TAKE_FD(fd);\n}\n\nint plymouth_send_raw(const void *raw, size_t size, int flags) {\n        _cleanup_close_ int fd = -EBADF;\n\n        fd = plymouth_connect(flags);\n        if (fd < 0)\n                return fd;\n\n        return loop_write(fd, raw, size);\n}\n\nint plymouth_send_msg(const char *text, bool pause_spinner) {\n        _cleanup_free_ char *plymouth_message = NULL;\n        int c, r;\n\n        assert(text);\n        assert(strlen(text) < UCHAR_MAX);\n\n        c = asprintf(&plymouth_message,\n                     \"M\\x02%c%s%c\"\n                     \"%c%c\", /* pause/resume spinner */\n                     (int) strlen(text) + 1, text, '\\x00',\n                     pause_spinner ? 'A' : 'a', '\\x00');\n        if (c < 0)\n                return log_oom();\n\n        r = plymouth_send_raw(plymouth_message, c, SOCK_NONBLOCK);\n        if (r < 0)\n                return log_full_errno(ERRNO_IS_NO_PLYMOUTH(r) ? LOG_DEBUG : LOG_WARNING, r,\n                                      \"Failed to communicate with plymouth, ignoring: %m\");\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "144μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "107μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "21018μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "151805μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "242603μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "73190μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "34μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "488901μs",
      "parallelizable_steps": [],
      "critical_path_length": "263799μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.5555555555555556
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.5555555555555556,
        "content_hash": "9c80a0a68a2f9435"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/plymouth-util.c"
      }
    },
    "source_hash": "bd215d980d0e"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/userdb/userdbd.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdlib.h>\n#include <sys/stat.h>\n\n#include \"sd-event.h\"\n\n#include \"daemon-util.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"signal-util.h\"\n#include \"userdbd-manager.h\"\n\n/* This service offers two Varlink services, both implementing io.systemd.UserDatabase:\n *\n *         → io.systemd.NameServiceSwitch: this is a compatibility interface for glibc NSS: it responds to\n *           name lookups by checking the classic NSS interfaces and responding that.\n *\n *         → io.systemd.Multiplexer: this multiplexes lookup requests to all Varlink services that have a\n *           socket in /run/systemd/userdb/. It's supposed to simplify clients that don't want to implement\n *           the full iterative logic on their own.\n *\n *         → io.systemd.DropIn: this makes JSON user/group records dropped into /run/userdb/ available as\n *           regular users.\n */\n\nstatic int run(int argc, char *argv[]) {\n        _cleanup_(manager_freep) Manager *m = NULL;\n        _unused_ _cleanup_(notify_on_cleanup) const char *notify_stop = NULL;\n        int r;\n\n        log_setup();\n\n        umask(0022);\n\n        if (argc != 1)\n                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), \"This program takes no arguments.\");\n\n        if (setenv(\"SYSTEMD_BYPASS_USERDB\", \"io.systemd.NameServiceSwitch:io.systemd.Multiplexer:io.systemd.DropIn\", 1) < 0)\n                return log_error_errno(errno, \"Failed to set $SYSTEMD_BYPASS_USERDB: %m\");\n\n        assert_se(sigprocmask_many(SIG_BLOCK, NULL, SIGCHLD) >= 0);\n\n        r = manager_new(&m);\n        if (r < 0)\n                return log_error_errno(r, \"Could not create manager: %m\");\n\n        r = manager_startup(m);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to start up daemon: %m\");\n\n        notify_stop = notify_start(NOTIFY_READY_MESSAGE, NOTIFY_STOPPING_MESSAGE);\n\n        r = sd_event_loop(m->event);\n        if (r < 0)\n                return log_error_errno(r, \"Event loop failed: %m\");\n\n        return 0;\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "218μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "68μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "106121μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "9053μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "375082μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "242558μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "534μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "733634μs",
      "parallelizable_steps": [],
      "critical_path_length": "481955μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.111111111111111
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.111111111111111,
        "content_hash": "d1b4825894218fa6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/userdb/userdbd.c"
      }
    },
    "source_hash": "3cd7b4fe557b"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udev-builtin-net_driver.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"device-private.h\"\n#include \"device-util.h\"\n#include \"errno-util.h\"\n#include \"ethtool-util.h\"\n#include \"fd-util.h\"\n#include \"udev-builtin.h\"\n\nstatic int builtin_net_driver_set_driver(UdevEvent *event, int argc, char **argv) {\n        sd_device *dev = ASSERT_PTR(ASSERT_PTR(event)->dev);\n        _cleanup_close_ int ethtool_fd = -EBADF;\n        _cleanup_free_ char *driver = NULL;\n        const char *ifname;\n        int r;\n\n        r = device_get_ifname(dev, &ifname);\n        if (r < 0)\n                return log_device_warning_errno(dev, r, \"Failed to get network interface name: %m\");\n\n        r = ethtool_get_driver(&ethtool_fd, ifname, &driver);\n        if (ERRNO_IS_NEG_NOT_SUPPORTED(r)) {\n                log_device_debug_errno(dev, r, \"Querying driver name via ethtool API is not supported by device '%s', ignoring: %m\", ifname);\n                return 0;\n        }\n        if (r == -ENODEV) {\n                log_device_debug_errno(dev, r, \"Device already vanished, ignoring.\");\n                return 0;\n        }\n        if (r < 0)\n                return log_device_warning_errno(dev, r, \"Failed to get driver for '%s': %m\", ifname);\n\n        return udev_builtin_add_property(event, \"ID_NET_DRIVER\", driver);\n}\n\nconst UdevBuiltin udev_builtin_net_driver = {\n        .name = \"net_driver\",\n        .cmd = builtin_net_driver_set_driver,\n        .help = \"Set driver for network device\",\n        .run_once = true,\n};\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "162μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "182μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "439228μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "693766μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "125886μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "31170μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "237926μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "583μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1528903μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "803040μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.611111111111111
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.611111111111111,
        "content_hash": "6bc7c7fcf63a4ab5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udev-builtin-net_driver.c"
      }
    },
    "source_hash": "fe710895fbdd"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/varlink.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"core-forward.h\"\n\nint manager_setup_varlink_server(Manager *m);\n\nint manager_varlink_init(Manager *m);\nvoid manager_varlink_done(Manager *m);\n\n/* The manager is expected to send an update to systemd-oomd if one of the following occurs:\n * - The value of ManagedOOM*= properties change\n * - A unit with ManagedOOM*= properties changes unit active state */\nint manager_varlink_send_managed_oom_update(Unit *u);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "262μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "155μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "102567μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "742939μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "659634μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "351319μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "178μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1857054μs",
      "parallelizable_steps": [],
      "critical_path_length": "1094413μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 4.0,
        "content_hash": "970cd614d837f375"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/varlink.h"
      }
    },
    "source_hash": "aa21629190df"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: man/inotify-watch-tmp.c\n\nCode:\n/* SPDX-License-Identifier: MIT-0 */\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/inotify.h>\n\n#include <systemd/sd-event.h>\n\n#define _cleanup_(f) __attribute__((cleanup(f)))\n\nstatic int inotify_handler(sd_event_source *source,\n                           const struct inotify_event *event,\n                           void *userdata) {\n\n  const char *desc = NULL;\n\n  sd_event_source_get_description(source, &desc);\n\n  if (event->mask & IN_Q_OVERFLOW)\n    printf(\"inotify-handler <%s>: overflow\\n\", desc);\n  else if (event->mask & IN_CREATE)\n    printf(\"inotify-handler <%s>: create on %s\\n\", desc, event->name);\n  else if (event->mask & IN_DELETE)\n    printf(\"inotify-handler <%s>: delete on %s\\n\", desc, event->name);\n  else if (event->mask & IN_MOVED_TO)\n    printf(\"inotify-handler <%s>: moved-to on %s\\n\", desc, event->name);\n\n  /* Terminate the program if an \"exit\" file appears */\n  if ((event->mask & (IN_CREATE|IN_MOVED_TO)) &&\n      strcmp(event->name, \"exit\") == 0)\n    sd_event_exit(sd_event_source_get_event(source), 0);\n\n  return 1;\n}\n\nint main(int argc, char **argv) {\n  _cleanup_(sd_event_unrefp) sd_event *event = NULL;\n  _cleanup_(sd_event_source_unrefp) sd_event_source *source1 = NULL, *source2 = NULL;\n\n  const char *path1 = argc > 1 ? argv[1] : \"/tmp\";\n  const char *path2 = argc > 2 ? argv[2] : NULL;\n\n  /* Note: failure handling is omitted for brevity */\n\n  sd_event_default(&event);\n\n  sd_event_add_inotify(event, &source1, path1,\n                       IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_TO,\n                       inotify_handler, NULL);\n  if (path2)\n    sd_event_add_inotify(event, &source2, path2,\n                         IN_CREATE | IN_DELETE | IN_MODIFY | IN_MOVED_TO,\n                         inotify_handler, NULL);\n\n  sd_event_loop(event);\n\n  return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "186μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "789μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "818242μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "598164μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "660745μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "850001μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "489101μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "159μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "3417387μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1968088μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 42,
        "complexity_score": 5.238095238095238
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 42,
        "complexity_score": 5.238095238095238,
        "content_hash": "782cd479c938824a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "man/inotify-watch-tmp.c"
      }
    },
    "source_hash": "541e457f50eb"
  },
  {
    "instruction": "Examine and structure this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "440μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "265863μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "537μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "519μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "267966μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "266670μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "8dd763201fce"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/core-forward.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"conf-parser-forward.h\"        /* IWYU pragma: export */\n#include \"forward.h\"                    /* IWYU pragma: export */\n#include \"unit-def.h\"                   /* IWYU pragma: export */\n\ntypedef enum CGroupDevicePermissions CGroupDevicePermissions;\ntypedef enum CGroupDevicePolicy CGroupDevicePolicy;\ntypedef enum ExecCleanMask ExecCleanMask;\ntypedef enum ExecPreserveMode ExecPreserveMode;\ntypedef enum FreezerAction FreezerAction;\ntypedef enum JobResult JobResult;\ntypedef enum JobState JobState;\ntypedef enum JobType JobType;\ntypedef enum ManagerState ManagerState;\ntypedef enum TransactionAddFlags TransactionAddFlags;\ntypedef enum UnitDependencyAtom UnitDependencyAtom;\ntypedef enum UnitWriteFlags UnitWriteFlags;\n\ntypedef struct ActivationDetails ActivationDetails;\ntypedef struct BindMount BindMount;\ntypedef struct CGroupBPFForeignProgram CGroupBPFForeignProgram;\ntypedef struct CGroupContext CGroupContext;\ntypedef struct CGroupDeviceAllow CGroupDeviceAllow;\ntypedef struct CGroupIODeviceLatency CGroupIODeviceLatency;\ntypedef struct CGroupIODeviceLimit CGroupIODeviceLimit;\ntypedef struct CGroupIODeviceWeight CGroupIODeviceWeight;\ntypedef struct CGroupRuntime CGroupRuntime;\ntypedef struct CGroupSocketBindItem CGroupSocketBindItem;\ntypedef struct DynamicCreds DynamicCreds;\ntypedef struct DynamicUser DynamicUser;\ntypedef struct ExecCommand ExecCommand;\ntypedef struct ExecContext ExecContext;\ntypedef struct ExecParameters ExecParameters;\ntypedef struct ExecRuntime ExecRuntime;\ntypedef struct ExecSharedRuntime ExecSharedRuntime;\ntypedef struct Job Job;\ntypedef struct JobDependency JobDependency;\ntypedef struct KillContext KillContext;\ntypedef struct Manager Manager;\ntypedef struct MountImage MountImage;\ntypedef struct PathSpec PathSpec;\ntypedef struct Scope Scope;\ntypedef struct Service Service;\ntypedef struct Socket Socket;\ntypedef struct SocketPeer SocketPeer;\ntypedef struct TemporaryFileSystem TemporaryFileSystem;\ntypedef struct Unit Unit;\ntypedef struct UnitRef UnitRef;\n\nstruct restrict_fs_bpf;\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "131μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "15μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "91040μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "186969μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "109410μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "75531μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "120μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "463216μs",
      "parallelizable_steps": [],
      "critical_path_length": "262515μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.0416666666666667
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.0416666666666667,
        "content_hash": "c94094798e7e8809"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/core-forward.h"
      }
    },
    "source_hash": "c82f9b9330a1"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp6-network.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/***\n  Copyright © 2014 Intel Corporation. All rights reserved.\n***/\n\n#include <netinet/in.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"dhcp6-internal.h\"\n#include \"dhcp6-protocol.h\"\n#include \"fd-util.h\"\n#include \"socket-util.h\"\n\nint dhcp6_network_bind_udp_socket(int ifindex, const struct in6_addr *local_address) {\n        union sockaddr_union src = {\n                .in6.sin6_family = AF_INET6,\n                .in6.sin6_addr = *ASSERT_PTR(local_address),\n                .in6.sin6_port = htobe16(DHCP6_PORT_CLIENT),\n                .in6.sin6_scope_id = ifindex,\n        };\n        _cleanup_close_ int s = -EBADF;\n        int r;\n\n        assert(ifindex > 0);\n\n        s = socket(AF_INET6, SOCK_DGRAM | SOCK_CLOEXEC | SOCK_NONBLOCK, IPPROTO_UDP);\n        if (s < 0)\n                return -errno;\n\n        r = setsockopt_int(s, IPPROTO_IPV6, IPV6_V6ONLY, true);\n        if (r < 0)\n                return r;\n\n        r = setsockopt_int(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP, false);\n        if (r < 0)\n                return r;\n\n        r = setsockopt_int(s, SOL_SOCKET, SO_REUSEADDR, true);\n        if (r < 0)\n                return r;\n\n        r = setsockopt_int(s, SOL_SOCKET, SO_TIMESTAMP, true);\n        if (r < 0)\n                return r;\n\n        r = bind(s, &src.sa, sizeof(src.in6));\n        if (r < 0)\n                return -errno;\n\n        return TAKE_FD(s);\n}\n\nint dhcp6_network_send_udp_socket(int s, const struct in6_addr *server_address, const void *packet, size_t len) {\n        union sockaddr_union dest = {\n                .in6.sin6_family = AF_INET6,\n                .in6.sin6_addr = *ASSERT_PTR(server_address),\n                .in6.sin6_port = htobe16(DHCP6_PORT_SERVER),\n        };\n\n        if (sendto(s, packet, len, 0, &dest.sa, sizeof(dest.in6)) < 0)\n                return -errno;\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "195μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "162μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "62091μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "70571μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "9318μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "331249μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "373μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "473959μs",
      "parallelizable_steps": [],
      "critical_path_length": "401982μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 2.1568627450980395
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 2.1568627450980395,
        "content_hash": "9098c728feed7d81"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp6-network.c"
      }
    },
    "source_hash": "4ed75d1f0338"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-sysctl-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/socket.h>\n#include <sys/utsname.h>\n\n#include \"sd-id128.h\"\n\n#include \"errno-util.h\"\n#include \"strv.h\"\n#include \"sysctl-util.h\"\n#include \"tests.h\"\n\nstatic const char* const cases[] = {\n        \"a.b.c\", \"a/b/c\",\n        \"a/b/c\", \"a/b/c\",\n        \"a/b.c/d\", \"a/b.c/d\",\n        \"a.b/c.d\", \"a/b.c/d\",\n\n        \"net.ipv4.conf.enp3s0/200.forwarding\", \"net/ipv4/conf/enp3s0.200/forwarding\",\n        \"net/ipv4/conf/enp3s0.200/forwarding\", \"net/ipv4/conf/enp3s0.200/forwarding\",\n\n        \"a...b...c\", \"a/b/c\",\n        \"a///b///c\", \"a/b/c\",\n        \".a...b...c\", \"a/b/c\",\n        \"/a///b///c\", \"a/b/c\",\n        NULL,\n};\n\nTEST(sysctl_normalize) {\n        STRV_FOREACH_PAIR(s, expected, cases) {\n                _cleanup_free_ char *t;\n\n                assert_se(t = strdup(*s));\n                assert_se(sysctl_normalize(t) == t);\n\n                log_info(\"\\\"%s\\\" → \\\"%s\\\", expected \\\"%s\\\"\", *s, t, *expected);\n                ASSERT_STREQ(t, *expected);\n        }\n}\n\nTEST(sysctl_read) {\n        _cleanup_free_ char *s = NULL;\n        struct utsname u;\n        sd_id128_t a, b;\n        int r;\n\n        assert_se(sysctl_read(\"kernel/random/boot_id\", &s) >= 0);\n        assert_se(sd_id128_from_string(s, &a) >= 0);\n        assert_se(sd_id128_get_boot(&b) >= 0);\n        assert_se(sd_id128_equal(a, b));\n        s = mfree(s);\n\n        assert_se(sysctl_read_ip_property(AF_INET, \"lo\", \"forwarding\", &s));\n        assert_se(STR_IN_SET(s, \"0\", \"1\"));\n\n        r = sysctl_write_ip_property(AF_INET, \"lo\", \"forwarding\", s, NULL);\n        assert_se(r >= 0 || ERRNO_IS_NEG_FS_WRITE_REFUSED(r));\n        s = mfree(s);\n\n        assert_se(sysctl_read_ip_property(AF_INET, NULL, \"ip_forward\", &s));\n        assert_se(STR_IN_SET(s, \"0\", \"1\"));\n\n        r = sysctl_write_ip_property(AF_INET, NULL, \"ip_forward\", s, NULL);\n        assert_se(r >= 0 || ERRNO_IS_NEG_FS_WRITE_REFUSED(r));\n        s = mfree(s);\n\n        assert_se(sysctl_read(\"kernel/hostname\", &s) >= 0);\n        assert_se(uname(&u) >= 0);\n        ASSERT_STREQ(s, u.nodename);\n\n        r = sysctl_write(\"kernel/hostname\", s);\n        assert_se(r >= 0 || ERRNO_IS_NEG_FS_WRITE_REFUSED(r));\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "317μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "170μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "146660μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "244093μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "257008μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "82640μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "176μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "731064μs",
      "parallelizable_steps": [],
      "critical_path_length": "404161μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.7543859649122806
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.7543859649122806,
        "content_hash": "3aeba7d482f91106"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-sysctl-util.c"
      }
    },
    "source_hash": "b50d5359a732"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-daemon.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/eventfd.h>\n\n#include \"sd-daemon.h\"\n\n#include \"fd-util.h\"\n#include \"parse-util.h\"\n#include \"pidfd-util.h\"\n#include \"process-util.h\"\n#include \"strv.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nint main(int argc, char *argv[]) {\n        _cleanup_strv_free_ char **l = NULL;\n        int r, n, i;\n        usec_t duration = USEC_PER_SEC / 10;\n\n        test_setup_logging(LOG_DEBUG);\n\n        if (argc >= 2) {\n                unsigned x;\n\n                ASSERT_OK(safe_atou(argv[1], &x));\n                duration = x * USEC_PER_SEC;\n        }\n\n        n = sd_listen_fds_with_names(false, &l);\n        if (n < 0) {\n                log_error_errno(n, \"Failed to get listening fds: %m\");\n                return EXIT_FAILURE;\n        }\n\n        for (i = 0; i < n; i++)\n                log_info(\"fd=%i name=%s\", SD_LISTEN_FDS_START + i, l[i]);\n\n        sd_notify(0,\n                  \"STATUS=Starting up\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Running\\n\"\n                  \"READY=1\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Reloading\\n\"\n                  \"RELOADING=1\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Running\\n\"\n                  \"READY=1\");\n        usleep_safe(duration);\n\n        sd_notify(0,\n                  \"STATUS=Quitting\\n\"\n                  \"STOPPING=1\");\n        usleep_safe(duration);\n\n        _cleanup_close_ int fd = eventfd(0, EFD_CLOEXEC);\n        ASSERT_OK_ERRNO(fd);\n\n        r = sd_pidfd_get_inode_id(fd, NULL);\n        ASSERT_TRUE(IN_SET(r, -EOPNOTSUPP, -EBADF));\n        if (r == -EBADF) {\n                safe_close(fd);\n                ASSERT_OK_ERRNO(fd = pidfd_open(getpid_cached(), 0));\n                ASSERT_OK(sd_pidfd_get_inode_id(fd, NULL));\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "323μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "8μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "217910μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "63762μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "214334μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "348722μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "21163μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "280μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "866502μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "453407μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.9298245614035086
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 1.9298245614035086,
        "content_hash": "c4c9312a65d6e894"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-daemon.c"
      }
    },
    "source_hash": "a01a714a6168"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscfoo\n#define foosdndiscfoo\n\n/***\n  Copyright © 2014 Intel Corporation. All rights reserved.\n\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n#include \"sd-ndisc-neighbor.h\"  /* IWYU pragma: export */\n#include \"sd-ndisc-protocol.h\"  /* IWYU pragma: export */\n#include \"sd-ndisc-redirect.h\"  /* IWYU pragma: export */\n#include \"sd-ndisc-router.h\"    /* IWYU pragma: export */\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in6_addr;\n\ntypedef struct sd_event sd_event;\ntypedef struct sd_ndisc sd_ndisc;\n\n__extension__ typedef enum _SD_ENUM_TYPE_S64(sd_ndisc_event_t) {\n        SD_NDISC_EVENT_TIMEOUT,\n        SD_NDISC_EVENT_ROUTER,\n        SD_NDISC_EVENT_NEIGHBOR,\n        SD_NDISC_EVENT_REDIRECT,\n        _SD_NDISC_EVENT_MAX,\n        _SD_NDISC_EVENT_INVALID = -EINVAL,\n        _SD_ENUM_FORCE_S64(NDISC_EVENT)\n} sd_ndisc_event_t;\n\ntypedef void (*sd_ndisc_callback_t)(sd_ndisc *nd, sd_ndisc_event_t event, void *message, void *userdata);\n\nint sd_ndisc_new(sd_ndisc **ret);\nsd_ndisc *sd_ndisc_ref(sd_ndisc *nd);\nsd_ndisc *sd_ndisc_unref(sd_ndisc *nd);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc, sd_ndisc_unref);\n\nint sd_ndisc_start(sd_ndisc *nd);\nint sd_ndisc_stop(sd_ndisc *nd);\nint sd_ndisc_is_running(sd_ndisc *nd);\n\nint sd_ndisc_attach_event(sd_ndisc *nd, sd_event *event, int64_t priority);\nint sd_ndisc_detach_event(sd_ndisc *nd);\nsd_event *sd_ndisc_get_event(sd_ndisc *nd);\n\nint sd_ndisc_set_callback(sd_ndisc *nd, sd_ndisc_callback_t cb, void *userdata);\nint sd_ndisc_set_ifindex(sd_ndisc *nd, int interface_index);\nint sd_ndisc_set_ifname(sd_ndisc *nd, const char *interface_name);\nint sd_ndisc_get_ifname(sd_ndisc *nd, const char **ret);\nint sd_ndisc_set_link_local_address(sd_ndisc *nd, const struct in6_addr *addr);\nint sd_ndisc_set_mac(sd_ndisc *nd, const struct ether_addr *mac_addr);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "782μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "327598μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2054μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "959μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "219954μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "805μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "552152μs",
      "parallelizable_steps": [],
      "critical_path_length": "329362μs",
      "metadata": {
        "functions_found": [
          "void"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "void"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 54,
        "complexity_score": 2.5925925925925926,
        "content_hash": "85e51f248a4ce015"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc.h"
      }
    },
    "source_hash": "1bbc7ca7400f"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/blockdev-list.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-device.h\"\n\n#include \"ansi-color.h\"\n#include \"blockdev-list.h\"\n#include \"blockdev-util.h\"\n#include \"device-util.h\"\n#include \"strv.h\"\n#include \"terminal-util.h\"\n\nint blockdev_list(BlockDevListFlags flags) {\n        _cleanup_(sd_device_enumerator_unrefp) sd_device_enumerator *e = NULL;\n        int r;\n\n        if (sd_device_enumerator_new(&e) < 0)\n                return log_oom();\n\n        r = sd_device_enumerator_add_match_subsystem(e, \"block\", /* match = */ true);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to add subsystem match: %m\");\n\n        if (FLAGS_SET(flags, BLOCKDEV_LIST_REQUIRE_LUKS)) {\n                r = sd_device_enumerator_add_match_property(e, \"ID_FS_TYPE\", \"crypto_LUKS\");\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to add match for LUKS block devices: %m\");\n        }\n\n        FOREACH_DEVICE(e, dev) {\n                const char *node;\n\n                r = sd_device_get_devname(dev, &node);\n                if (r < 0) {\n                        log_warning_errno(r, \"Failed to get device node of discovered block device, ignoring: %m\");\n                        continue;\n                }\n\n                if (FLAGS_SET(flags, BLOCKDEV_LIST_IGNORE_ZRAM)) {\n                        r = device_sysname_startswith(dev, \"zram\");\n                        if (r < 0) {\n                                log_warning_errno(r, \"Failed to check device name of discovered block device '%s', ignoring: %m\", node);\n                                continue;\n                        }\n                        if (r > 0)\n                                continue;\n                }\n\n                if (FLAGS_SET(flags, BLOCKDEV_LIST_REQUIRE_PARTITION_SCANNING)) {\n                        r = blockdev_partscan_enabled(dev);\n                        if (r < 0) {\n                                log_warning_errno(r, \"Unable to determine whether '%s' supports partition scanning, skipping device: %m\", node);\n                                continue;\n                        }\n                        if (r == 0) {\n                                log_debug(\"Device '%s' does not support partition scanning, skipping.\", node);\n                                continue;\n                        }\n                }\n\n                printf(\"%s\\n\", node);\n\n                if (FLAGS_SET(flags, BLOCKDEV_LIST_SHOW_SYMLINKS)) {\n                        _cleanup_strv_free_ char **list = NULL;\n\n                        FOREACH_DEVICE_DEVLINK(dev, l)\n                                if (strv_extend(&list, l) < 0)\n                                        return log_oom();\n\n                        strv_sort(list);\n\n                        STRV_FOREACH(i, list)\n                                printf(\"%s%s%s%s\\n\", on_tty() ? \"    \" : \"\", ansi_grey(), *i, ansi_normal());\n                }\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "432μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "373μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "416378μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "612935μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "467991μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "199901μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "177757μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "277μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1876044μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1062126μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 3.114754098360656
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 61,
        "complexity_score": 3.114754098360656,
        "content_hash": "c3e1bc48a107261d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/blockdev-list.c"
      }
    },
    "source_hash": "fc0f7f9d51d3"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/fuzz-dns-packet.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"fuzz.h\"\n#include \"resolved-dns-packet.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_(dns_packet_unrefp) DnsPacket *p = NULL;\n\n        if (outside_size_range(size, 0, DNS_PACKET_SIZE_MAX))\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(dns_packet_new(&p, DNS_PROTOCOL_DNS, 0, DNS_PACKET_SIZE_MAX) >= 0);\n        p->size = 0; /* by default append starts after the header, undo that */\n        assert_se(dns_packet_append_blob(p, data, size, NULL) >= 0);\n        if (size < DNS_PACKET_HEADER_SIZE) {\n                /* make sure we pad the packet back up to the minimum header size */\n                assert_se(p->allocated >= DNS_PACKET_HEADER_SIZE);\n                memzero(DNS_PACKET_DATA(p) + size, DNS_PACKET_HEADER_SIZE - size);\n                p->size = DNS_PACKET_HEADER_SIZE;\n        }\n        (void) dns_packet_extract(p);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "297μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "38μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "249043μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "133727μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "16μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "14μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "383135μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "249059μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 1.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 1.5,
        "content_hash": "1b59101bcb65d334"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/fuzz-dns-packet.c"
      }
    },
    "source_hash": "413b3105b007"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-procfs-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"errno-util.h\"\n#include \"format-util.h\"\n#include \"log.h\"\n#include \"process-util.h\"\n#include \"procfs-util.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nint main(int argc, char *argv[]) {\n        nsec_t nsec;\n        uint64_t v, pid_max, threads_max, limit;\n        int r;\n\n        test_setup_logging(LOG_DEBUG);\n\n        assert_se(procfs_cpu_get_usage(&nsec) >= 0);\n        log_info(\"Current system CPU time: %s\", FORMAT_TIMESPAN(nsec/NSEC_PER_USEC, 1));\n\n        assert_se(procfs_memory_get_used(&v) >= 0);\n        log_info(\"Current memory usage: %s\", FORMAT_BYTES(v));\n\n        assert_se(procfs_tasks_get_current(&v) >= 0);\n        log_info(\"Current number of tasks: %\" PRIu64, v);\n\n        pid_max = TASKS_MAX;\n        r = procfs_get_pid_max(&pid_max);\n        if (r == -ENOENT || ERRNO_IS_NEG_PRIVILEGE(r))\n                return log_tests_skipped_errno(r, \"can't get pid max\");\n        assert(r >= 0);\n        log_info(\"kernel.pid_max: %\"PRIu64, pid_max);\n\n        threads_max = TASKS_MAX;\n        r = procfs_get_threads_max(&threads_max);\n        if (r == -ENOENT || ERRNO_IS_NEG_PRIVILEGE(r))\n                return log_tests_skipped_errno(r, \"can't get threads max\");\n        assert(r >= 0);\n        log_info(\"kernel.threads-max: %\"PRIu64, threads_max);\n\n        limit = MIN(pid_max - (pid_max > 0), threads_max);\n\n        assert_se(r >= 0);\n        log_info(\"Limit of tasks: %\" PRIu64, limit);\n        assert_se(limit > 0);\n\n        /* This call should never fail, as we're trying to set it to the same limit */\n        assert(procfs_tasks_set_limit(limit) >= 0);\n\n        if (limit > 100) {\n                log_info(\"Reducing limit by one to %\"PRIu64\"…\", limit-1);\n\n                r = procfs_tasks_set_limit(limit-1);\n                if (r == -ENOENT || ERRNO_IS_NEG_FS_WRITE_REFUSED(r))\n                        return log_tests_skipped_errno(r, \"can't set tasks limit\");\n                assert_se(r >= 0);\n\n                assert_se(procfs_get_pid_max(&v) >= 0);\n                /* We never decrease the pid_max, so it shouldn't have changed */\n                assert_se(v == pid_max);\n\n                assert_se(procfs_get_threads_max(&v) >= 0);\n                assert_se(v == limit-1);\n\n                assert_se(procfs_tasks_set_limit(limit) >= 0);\n\n                assert_se(procfs_get_pid_max(&v) >= 0);\n                assert_se(v == pid_max);\n\n                assert_se(procfs_get_threads_max(&v) >= 0);\n                assert_se(v == limit);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "155μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "75μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "207423μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "291093μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "184059μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "147115μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "106156μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "306μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "936382μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "497638μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.6071428571428572
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.6071428571428572,
        "content_hash": "910a3a9165ee5bbe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-procfs-util.c"
      }
    },
    "source_hash": "ff316652e2bd"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/boot/shim.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n/*\n * Port to systemd-boot\n * Copyright © 2017 Max Resch <resch.max@gmail.com>\n *\n * Security Policy Handling\n * Copyright © 2012 <James.Bottomley@HansenPartnership.com>\n * https://github.com/mjg59/efitools\n */\n#pragma once\n\n#include \"efi.h\"\n\nbool shim_loaded(void);\nbool shim_loader_available(void);\nEFI_STATUS shim_load_image(EFI_HANDLE parent, const EFI_DEVICE_PATH *device_path, bool boot_policy, EFI_HANDLE *ret_image);\nvoid shim_retain_protocol(void);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "151μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "194702μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "175μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "431μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "9014μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "158μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "204631μs",
      "parallelizable_steps": [],
      "critical_path_length": "195291μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666,
        "content_hash": "2ee369849fe3c603"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/boot/shim.h"
      }
    },
    "source_hash": "9589b3e48057"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/udev/udevd.c\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * Copyright © 2004 Chris Friesen <chris_friesen@sympatico.ca>\n * Copyright © 2009 Canonical Ltd.\n * Copyright © 2009 Scott James Remnant <scott@netsplit.com>\n */\n\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"errno-util.h\"\n#include \"fd-util.h\"\n#include \"label-util.h\"\n#include \"log.h\"\n#include \"process-util.h\"\n#include \"rlimit-util.h\"\n#include \"terminal-util.h\"\n#include \"udev-config.h\"\n#include \"udev-manager.h\"\n#include \"udevd.h\"\n#include \"version.h\"\n\nint run_udevd(int argc, char *argv[]) {\n        _cleanup_(manager_freep) Manager *manager = NULL;\n        int r;\n\n        log_setup();\n\n        manager = manager_new();\n        if (!manager)\n                return log_oom();\n\n        r = manager_load(manager, argc, argv);\n        if (r <= 0)\n                return r;\n\n        r = must_be_root();\n        if (r < 0)\n                return r;\n\n        /* set umask before creating any file/directory */\n        umask(022);\n\n        r = mac_init();\n        if (r < 0)\n                return r;\n\n        /* Make sure we can have plenty fds (for example for pidfds) */\n        (void) rlimit_nofile_bump(-1);\n\n        r = RET_NERRNO(mkdir(\"/run/udev\", 0755));\n        if (r < 0 && r != -EEXIST)\n                return log_error_errno(r, \"Failed to create /run/udev: %m\");\n\n        if (arg_daemonize) {\n                pid_t pid;\n\n                log_info(\"Starting systemd-udevd version \" GIT_VERSION);\n\n                /* connect /dev/null to stdin, stdout, stderr */\n                if (log_get_max_level() < LOG_DEBUG) {\n                        r = make_null_stdio();\n                        if (r < 0)\n                                log_warning_errno(r, \"Failed to redirect standard streams to /dev/null: %m\");\n                }\n\n                pid = fork();\n                if (pid < 0)\n                        return log_error_errno(errno, \"Failed to fork daemon: %m\");\n                if (pid > 0)\n                        /* parent */\n                        return 0;\n\n                /* child */\n                terminal_detach_session();\n        }\n\n        return manager_main(manager);\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "344μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "101μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "205769μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "81327μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "139360μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "162987μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "167μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "590055μs",
      "parallelizable_steps": [],
      "critical_path_length": "345640μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 2.5806451612903225
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 62,
        "complexity_score": 2.5806451612903225,
        "content_hash": "c33b68fa3ac6edfe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/udev/udevd.c"
      }
    },
    "source_hash": "f04cc34dfe79"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fuzz/fuzz-main.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdlib.h>\n\n#include \"alloc-util.h\"\n#include \"fileio.h\"\n#include \"fuzz.h\"\n#include \"log.h\"\n#include \"parse-util.h\"\n#include \"string-util.h\"\n#include \"tests.h\"\n\n/* This is a test driver for the systemd fuzzers that provides main function\n * for regression testing outside of oss-fuzz (https://github.com/google/oss-fuzz)\n *\n * It reads files named on the command line and passes them one by one into the\n * fuzzer that it is compiled into. */\n\n/* This one was borrowed from\n * https://github.com/google/oss-fuzz/blob/646fca1b506b056db3a60d32c4a1a7398f171c94/infra/base-images/base-runner/bad_build_check#L19\n */\n#define NUMBER_OF_RUNS 4\n\nint main(int argc, char **argv) {\n        int r;\n\n        test_setup_logging(LOG_DEBUG);\n\n        unsigned number_of_runs = NUMBER_OF_RUNS;\n\n        const char *v = getenv(\"SYSTEMD_FUZZ_RUNS\");\n        if (!isempty(v)) {\n                r = safe_atou(v, &number_of_runs);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to parse SYSTEMD_FUZZ_RUNS=%s: %m\", v);\n        }\n\n        for (int i = 1; i < argc; i++) {\n                _cleanup_free_ char *buf = NULL;\n                size_t size;\n                char *name;\n\n                name = argv[i];\n                r = read_full_file(name, &buf, &size);\n                if (r < 0) {\n                        log_error_errno(r, \"Failed to open '%s': %m\", name);\n                        return EXIT_FAILURE;\n                }\n                printf(\"%s... \", name);\n                fflush(stdout);\n                for (unsigned j = 0; j < number_of_runs; j++)\n                        if (LLVMFuzzerTestOneInput((uint8_t*)buf, size) == EXIT_TEST_SKIP)\n                                return EXIT_TEST_SKIP;\n                printf(\"ok\\n\");\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "236μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "204863μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "994μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1182μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "250270μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "695μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "458240μs",
      "parallelizable_steps": [],
      "critical_path_length": "251500μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 1.9148936170212765
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 1.9148936170212765,
        "content_hash": "a331fd5aeeaa8d82"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fuzz/fuzz-main.c"
      }
    },
    "source_hash": "6c6e4b90ffd9"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-cache.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\ntypedef struct DnsCache {\n        Hashmap *by_key;\n        Prioq *by_expiry;\n        unsigned n_hit;\n        unsigned n_miss;\n} DnsCache;\n\nvoid dns_cache_flush(DnsCache *c);\nvoid dns_cache_prune(DnsCache *c);\n\nint dns_cache_put(\n                DnsCache *c,\n                DnsCacheMode cache_mode,\n                DnsProtocol protocol,\n                DnsResourceKey *key,\n                int rcode,\n                DnsAnswer *answer,\n                DnsPacket *full_packet,\n                uint64_t query_flags,\n                DnssecResult dnssec_result,\n                uint32_t nsec_ttl,\n                int owner_family,\n                const union in_addr_union *owner_address,\n                usec_t stale_retention_usec);\n\nint dns_cache_lookup(\n                DnsCache *c,\n                DnsResourceKey *key,\n                uint64_t query_flags,\n                int *ret_rcode,\n                DnsAnswer **ret_answer,\n                DnsPacket **ret_full_packet,\n                uint64_t *ret_query_flags,\n                DnssecResult *ret_dnssec_result);\n\nint dns_cache_check_conflicts(DnsCache *cache, DnsResourceRecord *rr, int owner_family, const union in_addr_union *owner_address);\n\nvoid dns_cache_dump(DnsCache *cache, FILE *f);\nint dns_cache_dump_to_json(DnsCache *cache, sd_json_variant **ret);\n\nbool dns_cache_is_empty(DnsCache *cache);\n\nunsigned dns_cache_size(DnsCache *cache);\n\nint dns_cache_export_shared_to_packet(DnsCache *cache, DnsPacket *p, usec_t ts, unsigned max_rr);\n\nbool dns_cache_expiry_in_one_second(DnsCache *c, usec_t t);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "92μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "8μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "73023μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "43354μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "52μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "18μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "116547μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "73075μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805,
        "content_hash": "2115440d2cb0f1db"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-cache.h"
      }
    },
    "source_hash": "5999c06fa513"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/fetch-mkosi.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"\nCheck out mkosi into specified location.\nWith -u, if changed, commit the latest hash.\n\"\"\"\n\nimport argparse\nimport shlex\nimport subprocess\nimport re\nfrom pathlib import Path\n\nURL = 'https://github.com/systemd/mkosi'\nBRANCH = 'main'  # We only want to ever use commits on upstream 'main' branch\nCONFIG = Path('mkosi/mkosi.conf')\nWORKFLOWS = [Path('.github/workflows') / f for f in ['mkosi.yml', 'coverage.yml', 'linter.yml']]\n\ndef parse_args():\n    p = argparse.ArgumentParser(\n        description=__doc__,\n    )\n    p.add_argument(\n        'dir',\n        type=Path,\n    )\n    p.add_argument(\n        '--update', '-u',\n        action='store_true',\n        default=False,\n    )\n    return p.parse_args()\n\ndef read_config():\n    print(f'Reading {CONFIG}…')\n    matches = [m.group(1)\n               for line in open(CONFIG)\n               if (m := re.match('^MinimumVersion=commit:([a-z0-9]{40})$',\n                                 line.strip()))]\n    assert len(matches) == 1\n    return matches[0]\n\ndef commit_file(files: list[Path], commit: str, changes: str):\n    message = '\\n'.join((\n        f'mkosi: update mkosi commit reference to {commit}',\n        '',\n        changes))\n\n    cmd = ['git', 'commit', '-m', message, *(str(file) for file in files)]\n    print(f\"+ {shlex.join(cmd)}\")\n    subprocess.check_call(cmd)\n\ndef checkout_mkosi(args):\n    if args.dir.exists():\n        print(f'{args.dir} already exists.')\n        return\n\n    cmd = [\n        'git', 'clone', URL,\n        f'--branch={BRANCH}',\n        args.dir.as_posix(),\n    ]\n    print(f\"+ {shlex.join(cmd)}\")\n    subprocess.check_call(cmd)\n\ndef update_mkosi(args):\n    old_commit = read_config()\n\n    cmd = ['git', '-C', args.dir.as_posix(), 'rev-parse', f'refs/remotes/origin/{BRANCH}']\n    print(f\"+ {shlex.join(cmd)}\")\n    new_commit = subprocess.check_output(cmd, text=True).strip()\n\n    if old_commit == new_commit:\n        print(f'mkosi: commit {new_commit!s} is still fresh')\n        return\n\n    cmd = ['git', '-C', args.dir.as_posix(), 'log', '--graph', '--first-parent', '--no-merges',\n           '--pretty=oneline', '--no-decorate', '--abbrev-commit', '--abbrev=10',\n           f'{old_commit}..{new_commit}']\n    print(f\"+ {shlex.join(cmd)}\")\n    changes = subprocess.check_output(cmd, text=True).strip()\n\n    for f in [CONFIG, *WORKFLOWS]:\n        s = f.read_text()\n        assert old_commit in s\n        print(f'mkosi: {f}: found old hash, updating…')\n        new = s.replace(old_commit, new_commit)\n        assert new != s\n        f.write_text(new)\n\n    commit_file([CONFIG, *WORKFLOWS], new_commit, changes)\n\nif __name__ == '__main__':\n    args = parse_args()\n    checkout_mkosi(args)\n    if args.update:\n        update_mkosi(args)\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "252μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "266094μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "550μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "313μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "269042μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "195μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "536446μs",
      "parallelizable_steps": [],
      "critical_path_length": "269844μs",
      "metadata": {
        "functions_found": [
          "parse_args",
          "read_config",
          "commit_file",
          "checkout_mkosi",
          "update_mkosi"
        ],
        "classes_found": [],
        "imports": [
          "argparse",
          "shlex",
          "subprocess",
          "re",
          "pathlib"
        ],
        "lines_of_code": 82,
        "complexity_score": 1.5853658536585367
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "parse_args",
          "read_config",
          "commit_file",
          "checkout_mkosi",
          "update_mkosi"
        ],
        "classes": [],
        "imports": [
          "argparse",
          "shlex",
          "subprocess",
          "re",
          "pathlib"
        ],
        "lines_of_code": 82,
        "complexity_score": 1.5853658536585367,
        "content_hash": "235cee2209dab01b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/fetch-mkosi.py"
      }
    },
    "source_hash": "37596dadc94d"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/selinux-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/socket.h>\n\n#include \"forward.h\"\n\n#if HAVE_SELINUX\n#include <selinux/selinux.h> /* IWYU pragma: export */\n\nDEFINE_TRIVIAL_CLEANUP_FUNC_FULL(char*, freecon, NULL);\n#else\nstatic inline void freeconp(char **p) {\n        assert(*p == NULL);\n}\n#endif\n\n#define _cleanup_freecon_ _cleanup_(freeconp)\n\n/* This accepts 0 error, like _zerook(). */\n#define log_selinux_enforcing_errno(error, ...)                         \\\n        ({                                                              \\\n                int _e = (error);                                       \\\n                bool _enforcing = mac_selinux_enforcing();              \\\n                int _level =                                            \\\n                        ERRNO_VALUE(_e) == 0 ? LOG_DEBUG :              \\\n                                  _enforcing ? LOG_ERR : LOG_WARNING;   \\\n                                                                        \\\n                int _r = (log_get_max_level() >= LOG_PRI(_level))       \\\n                        ? log_internal(_level, _e, PROJECT_FILE, __LINE__, __func__, __VA_ARGS__) \\\n                        : -ERRNO_VALUE(_e);                             \\\n                _enforcing ? _r : 0;                                    \\\n        })\n\nbool mac_selinux_use(void);\nvoid mac_selinux_retest(void);\nbool mac_selinux_enforcing(void);\n\nint mac_selinux_init(void);\nint mac_selinux_init_lazy(void);\nvoid mac_selinux_maybe_reload(void);\nvoid mac_selinux_finish(void);\n\nvoid mac_selinux_disable_logging(void);\n\nint mac_selinux_fix_full(int atfd, const char *inode_path, const char *label_path, LabelFixFlags flags);\n\nint mac_selinux_apply(const char *path, const char *label);\nint mac_selinux_apply_fd(int fd, const char *path, const char *label);\n\nint mac_selinux_get_create_label_from_exe(const char *exe, char **ret_label);\nint mac_selinux_get_our_label(char **ret_label);\nint mac_selinux_get_peer_label(int socket_fd, char **ret_label);\nint mac_selinux_get_child_mls_label(int socket_fd, const char *exe, const char *exec_label, char **ret_label);\n\nint mac_selinux_create_file_prepare_at(int dirfd, const char *path, mode_t mode);\nstatic inline int mac_selinux_create_file_prepare(const char *path, mode_t mode) {\n        return mac_selinux_create_file_prepare_at(AT_FDCWD, path, mode);\n}\nint mac_selinux_create_file_prepare_label(const char *path, const char *label);\nvoid mac_selinux_create_file_clear(void);\n\nint mac_selinux_create_socket_prepare(const char *label);\nvoid mac_selinux_create_socket_clear(void);\n\nint mac_selinux_bind(int fd, const struct sockaddr *addr, socklen_t addrlen);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "244μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "86μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "336876μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "99298μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "267450μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "388817μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "86μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1092857μs",
      "parallelizable_steps": [],
      "critical_path_length": "604656μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 1.9607843137254901
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 1.9607843137254901,
        "content_hash": "7c0a7649cd9bfae5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/selinux-util.h"
      }
    },
    "source_hash": "17c39042d01b"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/bless-boot/boot-check-no-failures.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <getopt.h>\n#include <stdio.h>\n\n#include \"sd-bus.h\"\n\n#include \"alloc-util.h\"\n#include \"build.h\"\n#include \"bus-error.h\"\n#include \"log.h\"\n#include \"main-func.h\"\n#include \"pretty-print.h\"\n\nstatic int help(void) {\n        _cleanup_free_ char *link = NULL;\n        int r;\n\n        r = terminal_urlify_man(\"systemd-boot-check-no-failures.service\", \"8\", &link);\n        if (r < 0)\n                return log_oom();\n\n        printf(\"%s [OPTIONS...]\\n\"\n               \"\\n%sVerify system operational state.%s\\n\\n\"\n               \"  -h --help          Show this help\\n\"\n               \"     --version       Print version\\n\"\n               \"\\nSee the %s for details.\\n\",\n               program_invocation_short_name,\n               ansi_highlight(),\n               ansi_normal(),\n               link);\n\n        return 0;\n}\n\nstatic int parse_argv(int argc, char *argv[]) {\n        enum {\n                ARG_PATH = 0x100,\n                ARG_VERSION,\n        };\n\n        static const struct option options[] = {\n                { \"help\",         no_argument,       NULL, 'h'              },\n                { \"version\",      no_argument,       NULL, ARG_VERSION      },\n                {}\n        };\n\n        int c;\n\n        assert(argc >= 0);\n        assert(argv);\n\n        while ((c = getopt_long(argc, argv, \"h\", options, NULL)) >= 0)\n                switch (c) {\n\n                case 'h':\n                        help();\n                        return 0;\n\n                case ARG_VERSION:\n                        return version();\n\n                case '?':\n                        return -EINVAL;\n\n                default:\n                        assert_not_reached();\n                }\n\n        return 1;\n}\n\nstatic int run(int argc, char *argv[]) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        uint32_t n;\n        int r;\n\n        log_setup();\n\n        r = parse_argv(argc, argv);\n        if (r <= 0)\n                return r;\n\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to connect to system bus: %m\");\n\n        r = sd_bus_get_property_trivial(\n                        bus,\n                        \"org.freedesktop.systemd1\",\n                        \"/org/freedesktop/systemd1\",\n                        \"org.freedesktop.systemd1.Manager\",\n                        \"NFailedUnits\",\n                        &error,\n                        'u',\n                        &n);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to get failed units counter: %s\", bus_error_message(&error, r));\n\n        if (n > 0)\n                log_notice(\"Health check: %\" PRIu32 \" units have failed.\", n);\n        else\n                log_info(\"Health check: no failed units.\");\n\n        return n > 0;\n}\n\nDEFINE_MAIN_FUNCTION_WITH_POSITIVE_FAILURE(run);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "204μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "26μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "72154μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "196212μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "157724μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "207018μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "38μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "633376μs",
      "parallelizable_steps": [],
      "critical_path_length": "403256μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 84,
        "complexity_score": 1.3095238095238095
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 84,
        "complexity_score": 1.3095238095238095,
        "content_hash": "3db66b40239cc8ca"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/bless-boot/boot-check-no-failures.c"
      }
    },
    "source_hash": "172cb49c776f"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dns-resolver-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-dns-resolver.h\"\n\n#include \"forward.h\"\n#include \"socket-netlink.h\"\n\n/* https://www.iana.org/assignments/dns-svcb/dns-svcb.xhtml#dns-svcparamkeys */\nenum {\n        DNS_SVC_PARAM_KEY_MANDATORY       = 0, /* RFC 9460 § 8 */\n        DNS_SVC_PARAM_KEY_ALPN            = 1, /* RFC 9460 § 7.1 */\n        DNS_SVC_PARAM_KEY_NO_DEFAULT_ALPN = 2, /* RFC 9460 § 7.1 */\n        DNS_SVC_PARAM_KEY_PORT            = 3, /* RFC 9460 § 7.2 */\n        DNS_SVC_PARAM_KEY_IPV4HINT        = 4, /* RFC 9460 § 7.3 */\n        DNS_SVC_PARAM_KEY_ECH             = 5, /* RFC 9460 */\n        DNS_SVC_PARAM_KEY_IPV6HINT        = 6, /* RFC 9460 § 7.3  */\n        DNS_SVC_PARAM_KEY_DOHPATH         = 7, /* RFC 9461 */\n        DNS_SVC_PARAM_KEY_OHTTP           = 8,\n        _DNS_SVC_PARAM_KEY_MAX_DEFINED,\n        DNS_SVC_PARAM_KEY_INVALID         = 65535 /* RFC 9460 */\n};\n\nconst char* dns_svc_param_key_to_string(int i) _const_;\nconst char* format_dns_svc_param_key(uint16_t i, char buf[static DECIMAL_STR_MAX(uint16_t)+3]);\n#define FORMAT_DNS_SVC_PARAM_KEY(i) format_dns_svc_param_key(i, (char [DECIMAL_STR_MAX(uint16_t)+3]) {})\n\n/* Represents a \"designated resolver\" */\n/* typedef struct sd_dns_resolver sd_dns_resolver; */\ntypedef struct sd_dns_resolver {\n        uint16_t priority;\n        char *auth_name;\n        int family;\n        union in_addr_union *addrs;\n        size_t n_addrs;\n        sd_dns_alpn_flags transports;\n        uint16_t port;\n        char *dohpath;\n} sd_dns_resolver;\n\nvoid siphash24_compress_resolver(const sd_dns_resolver *res, struct siphash *state);\n\nint dns_resolver_transports_to_strv(sd_dns_alpn_flags transports, char ***ret);\n\nint dns_resolvers_to_dot_addrs(const sd_dns_resolver *resolvers, size_t n_resolvers,\n                struct in_addr_full ***ret_addrs, size_t *ret_n_addrs);\n\nint dns_resolver_prio_compare(const sd_dns_resolver *a, const sd_dns_resolver *b);\n\nint dnr_parse_svc_params(const uint8_t *option, size_t len, sd_dns_resolver *resolver);\n\nint dns_resolvers_to_dot_strv(const sd_dns_resolver *resolvers, size_t n_resolvers, char ***ret_names);\n\nvoid sd_dns_resolver_done(sd_dns_resolver *res);\n\nvoid dns_resolver_done_many(sd_dns_resolver *resolvers, size_t n);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "150μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "51μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "190882μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "174375μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "139μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "13μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "365610μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "191021μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.1627906976744187
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 1.1627906976744187,
        "content_hash": "a6b27e4ec84c527b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dns-resolver-internal.h"
      }
    },
    "source_hash": "57555123db21"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-data-fd-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include \"data-fd-util.h\"\n#include \"fd-util.h\"\n#include \"memfd-util.h\"\n#include \"process-util.h\"\n#include \"tests.h\"\n\nstatic void assert_equal_fd(int fd1, int fd2) {\n        for (;;) {\n                uint8_t a[4096], b[4096];\n                ssize_t x, y;\n\n                x = read(fd1, a, sizeof(a));\n                assert_se(x >= 0);\n\n                y = read(fd2, b, sizeof(b));\n                assert_se(y >= 0);\n\n                assert_se(x == y);\n\n                if (x == 0)\n                        break;\n\n                assert_se(memcmp(a, b, x) == 0);\n        }\n}\n\nTEST(copy_data_fd) {\n        _cleanup_close_ int fd1 = -EBADF, fd2 = -EBADF;\n        _cleanup_close_pair_ int sfd[2] = EBADF_PAIR;\n        _cleanup_(sigkill_waitp) pid_t pid = -1;\n        int r;\n\n        fd1 = open(\"/etc/fstab\", O_RDONLY|O_CLOEXEC);\n        if (fd1 >= 0) {\n\n                fd2 = copy_data_fd(fd1);\n                assert_se(fd2 >= 0);\n\n                assert_se(lseek(fd1, 0, SEEK_SET) == 0);\n                assert_equal_fd(fd1, fd2);\n        }\n\n        fd1 = safe_close(fd1);\n        fd2 = safe_close(fd2);\n\n        fd1 = memfd_new_and_seal_string(\"data\", \"hallo\");\n        assert_se(fd1 >= 0);\n\n        fd2 = copy_data_fd(fd1);\n        assert_se(fd2 >= 0);\n\n        safe_close(fd1);\n        fd1 = memfd_new_and_seal_string(\"data\", \"hallo\");\n        assert_se(fd1 >= 0);\n\n        assert_equal_fd(fd1, fd2);\n\n        fd1 = safe_close(fd1);\n        fd2 = safe_close(fd2);\n\n        assert_se(socketpair(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0, sfd) >= 0);\n\n        r = safe_fork(\"(sd-pipe)\", FORK_RESET_SIGNALS|FORK_DEATHSIG_SIGTERM|FORK_LOG, &pid);\n        assert_se(r >= 0);\n\n        if (r == 0) {\n                /* child */\n\n                sfd[0] = safe_close(sfd[0]);\n\n                for (uint64_t i = 0; i < 1536*1024 / sizeof(uint64_t); i++)\n                        assert_se(write(sfd[1], &i, sizeof(i)) == sizeof(i));\n\n                sfd[1] = safe_close(sfd[1]);\n\n                _exit(EXIT_SUCCESS);\n        }\n\n        sfd[1] = safe_close(sfd[1]);\n\n        fd2 = copy_data_fd(sfd[0]);\n        assert_se(fd2 >= 0);\n\n        uint64_t j;\n        for (uint64_t i = 0; i < 1536*1024 / sizeof(uint64_t); i++) {\n                assert_se(read(fd2, &j, sizeof(j)) == sizeof(j));\n                assert_se(i == j);\n        }\n\n        assert_se(read(fd2, &j, sizeof(j)) == 0);\n}\n\nDEFINE_TEST_MAIN(LOG_DEBUG);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "312μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "143μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "131084μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "161551μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "171829μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "289874μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "66μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "754859μs",
      "parallelizable_steps": [],
      "critical_path_length": "451568μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 69,
        "complexity_score": 1.5942028985507246
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 69,
        "complexity_score": 1.5942028985507246,
        "content_hash": "a1492e8bf811baa4"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-data-fd-util.c"
      }
    },
    "source_hash": "0d97030ac425"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/test-resolve-tables.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"dns-type.h\"\n#include \"resolved-dns-dnssec.h\"\n#include \"resolved-dns-packet.h\"\n#include \"test-tables.h\"\n#include \"tests.h\"\n\nint main(int argc, char **argv) {\n        uint16_t i;\n\n        test_setup_logging(LOG_DEBUG);\n\n        test_table(DnsProtocol, dns_protocol, DNS_PROTOCOL);\n        test_table(DnssecResult, dnssec_result, DNSSEC_RESULT);\n        test_table(DnssecVerdict, dnssec_verdict, DNSSEC_VERDICT);\n\n        test_table_sparse(int, dns_rcode, DNS_RCODE);\n        test_table_sparse(int, dns_type, DNS_TYPE);\n\n        log_info(\"/* DNS_TYPE */\");\n        for (i = 0; i < _DNS_TYPE_MAX; i++) {\n                const char *s;\n\n                s = dns_type_to_string(i);\n                assert_se(s == NULL || strlen(s) < _DNS_TYPE_STRING_MAX);\n\n                if (s)\n                        log_info(\"%-*s %s%s%s%s%s%s%s%s%s\",\n                                 (int) _DNS_TYPE_STRING_MAX - 1, s,\n                                 dns_type_is_pseudo(i) ? \"pseudo \" : \"\",\n                                 dns_type_is_valid_query(i) ? \"valid_query \" : \"\",\n                                 dns_type_is_valid_rr(i) ? \"is_valid_rr \" : \"\",\n                                 dns_type_may_redirect(i) ? \"may_redirect \" : \"\",\n                                 dns_type_is_dnssec(i) ? \"dnssec \" : \"\",\n                                 dns_type_is_obsolete(i) ? \"obsolete \" : \"\",\n                                 dns_type_may_wildcard(i) ? \"wildcard \" : \"\",\n                                 dns_type_apex_only(i) ? \"apex_only \" : \"\",\n                                 dns_type_needs_authentication(i) ? \"needs_authentication\" : \"\");\n        }\n\n        log_info(\"/* DNS_CLASS */\");\n        for (i = 0; i < _DNS_CLASS_MAX; i++) {\n                const char *s;\n\n                s = dns_class_to_string(i);\n                assert_se(s == NULL || strlen(s) < _DNS_CLASS_STRING_MAX);\n\n                if (s)\n                        log_info(\"%-*s %s%s\",\n                                 (int) _DNS_CLASS_STRING_MAX - 1, s,\n                                 dns_class_is_pseudo(i) ? \"is_pseudo \" : \"\",\n                                 dns_class_is_valid_rr(i) ? \"is_valid_rr \" : \"\");\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "130μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "43μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "152437μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "61449μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "177μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "46μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "214282μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "152614μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.1111111111111112
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 1.1111111111111112,
        "content_hash": "4a3db854b713b17d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/test-resolve-tables.c"
      }
    },
    "source_hash": "5738330aada6"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/bpf/socket-bind/socket-bind-api.bpf.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n/* The SPDX header above is actually correct in claiming this was\n * LGPL-2.1-or-later, because it is. Since the kernel doesn't consider that\n * compatible with GPL we will claim this to be GPL however, which should be\n * fine given that LGPL-2.1-or-later downgrades to GPL if needed.\n */\n\n#include <linux/types.h>\n#include <stdint.h>\n\n/*\n * Bind rule is matched with socket fields accessible to cgroup/bind{4,6} hook\n * through bpf_sock_addr struct.\n * 'address_family' is expected to be one of AF_UNSPEC, AF_INET, AF_INET6 or the\n * magic SOCKET_BIND_RULE_AF_MATCH_NOTHING.\n * Matching by family is bypassed for rules with AF_UNSPEC set, which makes the\n * rest of a rule applicable for both IPv4 and IPv6 addresses.\n * If SOCKET_BIND_RULE_AF_MATCH_NOTHING is set the rule fails unconditionally\n * and other checks are skipped.\n * If matching by family is either successful or bypassed, a rule and a socket\n * are matched by ip protocol.\n * If 'protocol' is 0, matching is bypassed.\n * 'nr_ports' and 'port_min' fields specify a set of ports to match a user port\n * with.\n * If 'nr_ports' is 0, matching by port is bypassed, making that rule applicable\n * for all possible ports, e.g. [1, 65535] range. Thus a rule with\n * 'address_family', 'protocol' and 'nr_ports' equal to AF_UNSPEC, 0 and 0\n * correspondingly forms 'allow any' or 'deny any' cases.\n * For positive 'nr_ports', a user_port lying in a range from 'port_min' to'\n * 'port_min' + 'nr_ports' exclusively is considered to be a match. 'nr_ports'\n * equalling to 1 forms a rule for a single port.\n * Ports are in host order.\n *\n * Examples:\n * AF_UNSPEC, 1, 0, 7777: match IPv4 and IPv6 addresses with 7777 user port;\n *\n * AF_INET, 1023, 0, 1: match IPv4 addresses with user port in [1, 1023]\n * range inclusively;\n *\n * AF_INET6, 0, 0, 0: match IPv6 addresses;\n *\n * AF_UNSPEC, 0, 0, 0: match IPv4 and IPv6 addresses;\n *\n * AF_INET6, IPPROTO_TCP, 0, 0: match IPv6/TCP addresses.\n */\n\nstruct socket_bind_rule {\n        __u32 address_family;\n        __u32 protocol;\n        __u16 nr_ports;\n        __u16 port_min;\n};\n\n#define SOCKET_BIND_MAX_RULES 128\n#define SOCKET_BIND_RULE_AF_MATCH_NOTHING UINT32_MAX\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "774μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "50μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "12920μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "28108μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "785672μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "797161μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "620μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1625305μs",
      "parallelizable_steps": [],
      "critical_path_length": "825319μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 4.117647058823529
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 51,
        "complexity_score": 4.117647058823529,
        "content_hash": "e6716bf5d1797ab5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/bpf/socket-bind/socket-bind-api.bpf.h"
      }
    },
    "source_hash": "69c2e3751a51"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-cryptolib.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"openssl-util.h\"\n#include \"tests.h\"\n\nTEST(string_hashsum) {\n        _cleanup_free_ char *out1 = NULL, *out2 = NULL, *out3 = NULL, *out4 = NULL;\n\n        ASSERT_OK(string_hashsum(\"asdf\", 4, \"SHA224\", &out1));\n        /* echo -n 'asdf' | sha224sum - */\n        ASSERT_STREQ(out1, \"7872a74bcbf298a1e77d507cd95d4f8d96131cbbd4cdfc571e776c8a\");\n\n        ASSERT_OK(string_hashsum(\"asdf\", 4, \"SHA256\", &out2));\n        /* echo -n 'asdf' | sha256sum - */\n        ASSERT_STREQ(out2, \"f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b\");\n\n        ASSERT_OK(string_hashsum(\"\", 0, \"SHA224\", &out3));\n        /* echo -n '' | sha224sum - */\n        ASSERT_STREQ(out3, \"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\");\n\n        ASSERT_OK(string_hashsum(\"\", 0, \"SHA256\", &out4));\n        /* echo -n '' | sha256sum - */\n        ASSERT_STREQ(out4, \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\");\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "60μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "187245μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "121μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "390μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "49790μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "147μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "237753μs",
      "parallelizable_steps": [],
      "critical_path_length": "187782μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 0.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 0.5,
        "content_hash": "8d2d2f16bd99037d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-cryptolib.c"
      }
    },
    "source_hash": "a539c8fcd447"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dnssd.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-conf.h\"\n#include \"resolved-forward.h\"\n\nenum {\n        DNS_TXT_ITEM_TEXT,\n        DNS_TXT_ITEM_DATA,\n};\n\ntypedef struct DnssdTxtData {\n        DnsResourceRecord *rr;\n\n        LIST_HEAD(DnsTxtItem, txts);\n\n        LIST_FIELDS(DnssdTxtData, items);\n} DnssdTxtData;\n\ntypedef struct DnssdRegisteredService {\n        char *path;\n        char *id;\n        char *name_template;\n        char *type;\n        char *subtype;\n        uint16_t port;\n        uint16_t priority;\n        uint16_t weight;\n\n        DnsResourceRecord *ptr_rr;\n        DnsResourceRecord *sub_ptr_rr;\n        DnsResourceRecord *srv_rr;\n\n        /* Section 6.8 of RFC 6763 allows having service\n         * instances with multiple TXT resource records. */\n        LIST_HEAD(DnssdTxtData, txt_data_items);\n\n        Manager *manager;\n\n        /* Services registered via D-Bus are not removed on reload */\n        ResolveConfigSource config_source;\n\n        bool withdrawn:1;\n        uid_t originator;\n} DnssdRegisteredService;\n\nDnssdRegisteredService *dnssd_registered_service_free(DnssdRegisteredService *service);\nDnssdTxtData *dnssd_txtdata_free(DnssdTxtData *txt_data);\nDnssdTxtData *dnssd_txtdata_free_all(DnssdTxtData *txt_data);\nvoid dnssd_registered_service_clear_on_reload(Hashmap *services);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnssdRegisteredService*, dnssd_registered_service_free);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnssdTxtData*, dnssd_txtdata_free);\n\nint dnssd_render_instance_name(Manager *m, DnssdRegisteredService *s, char **ret);\nint dnssd_load(Manager *manager);\nint dnssd_txt_item_new_from_string(const char *key, const char *value, DnsTxtItem **ret_item);\nint dnssd_txt_item_new_from_data(const char *key, const void *value, const size_t size, DnsTxtItem **ret_item);\nint dnssd_update_rrs(DnssdRegisteredService *s);\nint dnssd_signal_conflict(Manager *manager, const char *name);\n\nconst struct ConfigPerfItem* resolved_dnssd_gperf_lookup(const char *key, GPERF_LEN_TYPE length);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_registered_service_name);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_registered_service_subtype);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_registered_service_type);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssd_txt);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "80μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "30μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "9616μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "119473μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "2μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "3μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "129204μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "119506μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.7692307692307693
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 0.7692307692307693,
        "content_hash": "ad1d408a7be5a36f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dnssd.h"
      }
    },
    "source_hash": "7113583cd793"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-search-domain.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-forward.h\"\n\ntypedef enum DnsSearchDomainType {\n        DNS_SEARCH_DOMAIN_SYSTEM,\n        DNS_SEARCH_DOMAIN_LINK,\n        DNS_SEARCH_DOMAIN_DELEGATE,\n} DnsSearchDomainType;\n\ntypedef struct DnsSearchDomain {\n        Manager *manager;\n\n        unsigned n_ref;\n\n        DnsSearchDomainType type;\n        Link *link;\n        DnsDelegate *delegate;\n\n        char *name;\n\n        bool marked:1;\n        bool route_only:1;\n\n        bool linked:1;\n        LIST_FIELDS(DnsSearchDomain, domains);\n} DnsSearchDomain;\n\nint dns_search_domain_new(\n                Manager *m,\n                DnsSearchDomain **ret,\n                DnsSearchDomainType type,\n                Link *link,\n                DnsDelegate *delegate,\n                const char *name);\n\nDnsSearchDomain* dns_search_domain_ref(DnsSearchDomain *d);\nDnsSearchDomain* dns_search_domain_unref(DnsSearchDomain *d);\n\nvoid dns_search_domain_unlink(DnsSearchDomain *d);\nvoid dns_search_domain_move_back_and_unmark(DnsSearchDomain *d);\n\nvoid dns_search_domain_unlink_all(DnsSearchDomain *first);\nbool dns_search_domain_unlink_marked(DnsSearchDomain *first);\nvoid dns_search_domain_mark_all(DnsSearchDomain *first);\n\nint dns_search_domain_find(DnsSearchDomain *first, const char *name, DnsSearchDomain **ret);\n\nstatic inline const char* DNS_SEARCH_DOMAIN_NAME(DnsSearchDomain *d) {\n        return d ? d->name : NULL;\n}\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnsSearchDomain*, dns_search_domain_unref);\n\nint dns_search_domain_dump_to_json(DnsSearchDomain *domain, sd_json_variant **ret);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "12μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "7μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "83215μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "11768μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "75μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "6μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "95083μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "83290μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 0.4878048780487805,
        "content_hash": "d493a1b0c44289fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-search-domain.h"
      }
    },
    "source_hash": "71c4b45adbde"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/rm-rf.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum RemoveFlags {\n        REMOVE_ONLY_DIRECTORIES = 1 << 0, /* Only remove empty directories, no files */\n        REMOVE_ROOT             = 1 << 1, /* Remove the specified directory itself too, not just the contents of it */\n        REMOVE_PHYSICAL         = 1 << 2, /* If not set, only removes files on tmpfs, never physical file systems */\n        REMOVE_SUBVOLUME        = 1 << 3, /* Drop btrfs subvolumes in the tree too */\n        REMOVE_MISSING_OK       = 1 << 4, /* If the top-level directory is missing, ignore the ENOENT for it */\n        REMOVE_CHMOD            = 1 << 5, /* chmod() for write access if we cannot delete or access something */\n        REMOVE_CHMOD_RESTORE    = 1 << 6, /* Restore the old mode before returning */\n        REMOVE_SYNCFS           = 1 << 7, /* syncfs() the root of the specified directory after removing everything in it */\n} RemoveFlags;\n\nint unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags);\nint fstatat_harder(int dfd,\n                const char *filename,\n                struct stat *ret,\n                int fstatat_flags,\n                RemoveFlags remove_flags);\n\n/* Note: directory file descriptors passed to the functions below must be\n * positioned at the beginning. If the fd was already used for reading, rewind it. */\nint rm_rf_children(int fd, RemoveFlags flags, const struct stat *root_dev);\nint rm_rf_child(int fd, const char *name, RemoveFlags flags);\nint rm_rf_at(int dir_fd, const char *path, RemoveFlags flags);\nstatic inline int rm_rf(const char *path, RemoveFlags flags) {\n        return rm_rf_at(AT_FDCWD, path, flags);\n}\n\n/* Useful for using with _cleanup_(), destroys a directory on a temporary file system. */\nconst char* rm_rf_safe(const char *p);\nDEFINE_TRIVIAL_CLEANUP_FUNC(const char*, rm_rf_safe);\n\n/* Similar as above, but allow to destroy a directory on a physical file system, and also frees the pointer. */\nchar* rm_rf_physical_and_free(char *p);\nDEFINE_TRIVIAL_CLEANUP_FUNC(char*, rm_rf_physical_and_free);\n\n/* Similar as above, but also has magic btrfs subvolume powers. */\nchar* rm_rf_subvolume_and_free(char *p);\nDEFINE_TRIVIAL_CLEANUP_FUNC(char*, rm_rf_subvolume_and_free);\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "432μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "600μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "496825μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "388270μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "628164μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "553455μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "108895μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "694μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "2177335μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1233884μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.888888888888889
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.888888888888889,
        "content_hash": "05c79377113d25c7"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/rm-rf.h"
      }
    },
    "source_hash": "cb9667ad2f7b"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/override/linux/nsfs.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include_next <linux/nsfs.h>    /* IWYU pragma: export */\n\n/* Root namespace inode numbers, as per include/linux/proc_ns.h in the kernel source tree, since v3.8:\n * https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=98f842e675f96ffac96e6c50315790912b2812be */\n\n#define PROC_IPC_INIT_INO    ((ino_t) UINT32_C(0xEFFFFFFF))\n#define PROC_UTS_INIT_INO    ((ino_t) UINT32_C(0xEFFFFFFE))\n#define PROC_USER_INIT_INO   ((ino_t) UINT32_C(0xEFFFFFFD))\n#define PROC_PID_INIT_INO    ((ino_t) UINT32_C(0xEFFFFFFC))\n#define PROC_CGROUP_INIT_INO ((ino_t) UINT32_C(0xEFFFFFFB))\n#define PROC_TIME_INIT_INO   ((ino_t) UINT32_C(0xEFFFFFFA))\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "47μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "224879μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "560μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "654μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "70420μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "80μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "296640μs",
      "parallelizable_steps": [],
      "critical_path_length": "225613μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 0.9090909090909092
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 11,
        "complexity_score": 0.9090909090909092,
        "content_hash": "b1775d05a9fcdc32"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/override/linux/nsfs.h"
      }
    },
    "source_hash": "aae1d5b296c1"
  },
  {
    "instruction": "Examine and structure this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "440μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "265863μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "537μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "519μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "267966μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "266670μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "8dd763201fce"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: man/notify-selfcontained-example.py\n\nCode:\n#!/usr/bin/python\n# SPDX-License-Identifier: MIT-0\n#\n# Implement the systemd notify protocol without external dependencies.\n# Supports both readiness notification on startup and on reloading,\n# according to the protocol defined at:\n# https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html\n# This protocol is guaranteed to be stable as per:\n# https://systemd.io/PORTABILITY_AND_STABILITY/\n\nimport errno\nimport os\nimport signal\nimport socket\nimport sys\nimport time\n\nreloading = False\nterminating = False\n\ndef notify(message):\n    if not message:\n        raise ValueError(\"notify() requires a message\")\n\n    socket_path = os.environ.get(\"NOTIFY_SOCKET\")\n    if not socket_path:\n        return\n\n    if socket_path[0] not in (\"/\", \"@\"):\n        raise OSError(errno.EAFNOSUPPORT, \"Unsupported socket type\")\n\n    # Handle abstract socket.\n    if socket_path[0] == \"@\":\n        socket_path = \"\\0\" + socket_path[1:]\n\n    with socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM | socket.SOCK_CLOEXEC) as sock:\n        sock.connect(socket_path)\n        sock.sendall(message)\n\ndef notify_ready():\n    notify(b\"READY=1\")\n\ndef notify_reloading():\n    microsecs = time.clock_gettime_ns(time.CLOCK_MONOTONIC) // 1000\n    notify(f\"RELOADING=1\\nMONOTONIC_USEC={microsecs}\".encode())\n\ndef notify_stopping():\n    notify(b\"STOPPING=1\")\n\ndef reload(signum, frame):\n    global reloading\n    reloading = True\n\ndef terminate(signum, frame):\n    global terminating\n    terminating = True\n\ndef main():\n    print(\"Doing initial setup\")\n    global reloading, terminating\n\n    # Set up signal handlers.\n    print(\"Setting up signal handlers\")\n    signal.signal(signal.SIGHUP, reload)\n    signal.signal(signal.SIGINT, terminate)\n    signal.signal(signal.SIGTERM, terminate)\n\n    # Do any other setup work here.\n\n    # Once all setup is done, signal readiness.\n    print(\"Done setting up\")\n    notify_ready()\n\n    print(\"Starting loop\")\n    while not terminating:\n        if reloading:\n            print(\"Reloading\")\n            reloading = False\n\n            # Support notifying the manager when reloading configuration.\n            # This allows accurate state tracking as well as automatically\n            # enabling 'systemctl reload' without needing to manually\n            # specify an ExecReload= line in the unit file.\n\n            notify_reloading()\n\n            # Do some reconfiguration work here.\n\n            print(\"Done reloading\")\n            notify_ready()\n\n        # Do the real work here ...\n\n        print(\"Sleeping for five seconds\")\n        time.sleep(5)\n\n    print(\"Terminating\")\n    notify_stopping()\n\nif __name__ == \"__main__\":\n    sys.stdout.reconfigure(line_buffering=True)\n    print(\"Starting app\")\n    main()\n    print(\"Stopped app\")\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "62μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "366μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "428101μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "9374μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "51961μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "66665μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "39μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "556568μs",
      "parallelizable_steps": [],
      "critical_path_length": "480163μs",
      "metadata": {
        "functions_found": [
          "notify",
          "notify_ready",
          "notify_reloading",
          "notify_stopping",
          "reload",
          "terminate",
          "main"
        ],
        "classes_found": [],
        "imports": [
          "errno",
          "os",
          "signal",
          "socket",
          "sys",
          "time"
        ],
        "lines_of_code": 79,
        "complexity_score": 3.79746835443038
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "notify",
          "notify_ready",
          "notify_reloading",
          "notify_stopping",
          "reload",
          "terminate",
          "main"
        ],
        "classes": [],
        "imports": [
          "errno",
          "os",
          "signal",
          "socket",
          "sys",
          "time"
        ],
        "lines_of_code": 79,
        "complexity_score": 3.79746835443038,
        "content_hash": "c14e5dc489020b54"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "man/notify-selfcontained-example.py"
      }
    },
    "source_hash": "406eb3d3715b"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-delegate-bus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\nextern const BusObjectImplementation dns_delegate_object;\n\nchar* dns_delegate_bus_path(const DnsDelegate *d);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "342μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "177μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "235150μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "482296μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "508μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "155μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "718628μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "482628μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "4714aa5b512db8de"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-delegate-bus.h"
      }
    },
    "source_hash": "372557bcc7ff"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/dynamic-user.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"core-forward.h\"\n\n/* Note that this object always allocates a pair of user and group under the same name, even if one of them isn't\n * used. This means, if you want to allocate a group and user pair, and they might have two different names, then you\n * need to allocated two of these objects. DynamicCreds below makes that easy. */\ntypedef struct DynamicUser {\n        Manager *manager;\n        unsigned n_ref;\n\n        /* An AF_UNIX socket pair that contains a datagram containing both the numeric ID assigned, as well as a lock\n         * file fd locking the user ID we picked. */\n        int storage_socket[2];\n\n        char name[];\n} DynamicUser;\n\ntypedef struct DynamicCreds {\n        /* A combination of a dynamic user and group */\n        DynamicUser *user;\n        DynamicUser *group;\n} DynamicCreds;\n\nint dynamic_user_serialize(Manager *m, FILE *f, FDSet *fds);\nint dynamic_user_serialize_one(DynamicUser *d, const char *key, FILE *f, FDSet *fds);\nvoid dynamic_user_deserialize_one(Manager *m, const char *value, FDSet *fds, DynamicUser **ret);\nDynamicUser* dynamic_user_free(DynamicUser *d);\nvoid dynamic_user_vacuum(Manager *m, bool close_user);\n\nint dynamic_user_current(DynamicUser *d, uid_t *ret);\nint dynamic_user_lookup_uid(Manager *m, uid_t uid, char **ret);\nint dynamic_user_lookup_name(Manager *m, const char *name, uid_t *ret);\n\nint dynamic_creds_make(Manager *m, const char *user, const char *group, DynamicCreds **ret);\nint dynamic_creds_realize(DynamicCreds *creds, char **suggested_paths, uid_t *uid, gid_t *gid);\n\nDynamicCreds *dynamic_creds_unref(DynamicCreds *creds);\nDynamicCreds *dynamic_creds_destroy(DynamicCreds *creds);\nvoid dynamic_creds_done(DynamicCreds *creds);\nvoid dynamic_creds_close(DynamicCreds *creds);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DynamicCreds*, dynamic_creds_unref);\nDEFINE_TRIVIAL_CLEANUP_FUNC(DynamicCreds*, dynamic_creds_destroy);\n\nDynamicUser *dynamic_user_ref(DynamicUser *user);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "139μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "110μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "61394μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "86903μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "83593μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "183565μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "153μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "415857μs",
      "parallelizable_steps": [],
      "critical_path_length": "270578μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.3888888888888888
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.3888888888888888,
        "content_hash": "063eed7394c83a72"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/dynamic-user.h"
      }
    },
    "source_hash": "e12b1b0b08fa"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/analyze/analyze-service-watchdogs.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"analyze.h\"\n#include \"analyze-service-watchdogs.h\"\n#include \"bus-error.h\"\n#include \"bus-locator.h\"\n#include \"bus-util.h\"\n#include \"parse-util.h\"\n#include \"runtime-scope.h\"\n#include \"string-util.h\"\n\nint verb_service_watchdogs(int argc, char *argv[], void *userdata) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        int b, r;\n\n        assert(IN_SET(argc, 1, 2));\n        assert(argv);\n\n        r = acquire_bus(&bus, NULL);\n        if (r < 0)\n                return bus_log_connect_error(r, arg_transport, arg_runtime_scope);\n\n        if (argc == 1) {\n                /* get ServiceWatchdogs */\n                r = bus_get_property_trivial(bus, bus_systemd_mgr, \"ServiceWatchdogs\", &error, 'b', &b);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to get service-watchdog state: %s\", bus_error_message(&error, r));\n\n                printf(\"%s\\n\", yes_no(!!b));\n\n        } else {\n                /* set ServiceWatchdogs */\n                b = parse_boolean(argv[1]);\n                if (b < 0)\n                        return log_error_errno(b, \"Failed to parse service-watchdogs argument: %m\");\n\n                r = bus_set_property(bus, bus_systemd_mgr, \"ServiceWatchdogs\", &error, \"b\", b);\n                if (r < 0)\n                        return log_error_errno(r, \"Failed to set service-watchdog state: %s\", bus_error_message(&error, r));\n        }\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "124μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "84μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "8382μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "23163μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "56783μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "9741μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "123986μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "179μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "222442μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "189151μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.6666666666666665
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 1.6666666666666665,
        "content_hash": "12a310b331877c39"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/analyze/analyze-service-watchdogs.c"
      }
    },
    "source_hash": "ca52d507d8f8"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-hwdb.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdhwdbhfoo\n#define foosdhwdbhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_hwdb sd_hwdb;\n\nsd_hwdb *sd_hwdb_ref(sd_hwdb *hwdb);\nsd_hwdb *sd_hwdb_unref(sd_hwdb *hwdb);\n\nint sd_hwdb_new(sd_hwdb **ret);\nint sd_hwdb_new_from_path(const char *path, sd_hwdb **ret);\n\nint sd_hwdb_get(sd_hwdb *hwdb, const char *modalias, const char *key, const char **value);\n\nint sd_hwdb_seek(sd_hwdb *hwdb, const char *modalias);\nint sd_hwdb_enumerate(sd_hwdb *hwdb, const char **key, const char **value);\n\n/* the inverse condition avoids ambiguity of dangling 'else' after the macro */\n#define SD_HWDB_FOREACH_PROPERTY(hwdb, modalias, key, value)            \\\n        if (sd_hwdb_seek(hwdb, modalias) < 0) { }                       \\\n        else while (sd_hwdb_enumerate(hwdb, &(key), &(value)) > 0)\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_hwdb, sd_hwdb_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "691μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1528316μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1571μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "591μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "442728μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1429μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1975326μs",
      "parallelizable_steps": [],
      "critical_path_length": "1530336μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 4.0625
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 4.0625,
        "content_hash": "1869619d698298ce"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-hwdb.h"
      }
    },
    "source_hash": "42569e907c93"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dnstls.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#if ENABLE_DNS_OVER_TLS\n\n#if !HAVE_OPENSSL\n#error This source file requires OpenSSL to be available.\n#endif\n\n#include <openssl/ssl.h>\n\n#include \"resolved-forward.h\"\n\ntypedef struct DnsTlsManagerData {\n        SSL_CTX *ctx;\n} DnsTlsManagerData;\n\ntypedef struct DnsTlsServerData {\n        SSL_SESSION *session;\n} DnsTlsServerData;\n\ntypedef struct DnsTlsStreamData {\n        int handshake;\n        bool shutdown;\n        SSL *ssl;\n        BUF_MEM *write_buffer;\n        size_t buffer_offset;\n} DnsTlsStreamData;\n\n#define DNSTLS_STREAM_CLOSED 1\n\nint dnstls_stream_connect_tls(DnsStream *stream, DnsServer *server);\nvoid dnstls_stream_free(DnsStream *stream);\nint dnstls_stream_on_io(DnsStream *stream, uint32_t revents);\nint dnstls_stream_shutdown(DnsStream *stream, int error);\nssize_t dnstls_stream_writev(DnsStream *stream, const struct iovec *iov, size_t iovcnt);\nssize_t dnstls_stream_read(DnsStream *stream, void *buf, size_t count);\n\nvoid dnstls_server_free(DnsServer *server);\n\nint dnstls_manager_init(Manager *manager);\nvoid dnstls_manager_free(Manager *manager);\n\n#endif /* ENABLE_DNS_OVER_TLS */\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "428μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "441981μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "281μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1493μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "100507μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "745μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "545435μs",
      "parallelizable_steps": [],
      "critical_path_length": "444219μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 1.875,
        "content_hash": "0235cc297b591136"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dnstls.h"
      }
    },
    "source_hash": "f99a4737780c"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/memory-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <threads.h>\n#include <unistd.h>\n\n#include \"alloc-util.h\"\n#include \"memory-util.h\"\n\nsize_t page_size(void) {\n        static thread_local size_t pgsz = 0;\n        long r;\n\n        if (_likely_(pgsz > 0))\n                return pgsz;\n\n        r = sysconf(_SC_PAGESIZE);\n        assert(r > 0);\n\n        pgsz = (size_t) r;\n        return pgsz;\n}\n\nbool memeqbyte(uint8_t byte, const void *data, size_t length) {\n        /* Does the buffer consist entirely of the same specific byte value?\n         * Copied from https://github.com/systemd/casync/, copied in turn from\n         * https://github.com/rustyrussell/ccan/blob/master/ccan/mem/mem.c#L92,\n         * which is licensed CC-0.\n         */\n\n        const uint8_t *p = data;\n\n        /* Check first 16 bytes manually */\n        for (size_t i = 0; i < 16; i++, length--) {\n                if (length == 0)\n                        return true;\n                if (p[i] != byte)\n                        return false;\n        }\n\n        /* Now we know first 16 bytes match, memcmp() with self.  */\n        return memcmp(data, p + 16, length) == 0;\n}\n\nvoid* memdup_reverse(const void *mem, size_t size) {\n        assert(mem);\n        assert(size != 0);\n\n        void *p = malloc(size);\n        if (!p)\n                return NULL;\n\n        uint8_t *p_dst = p;\n        const uint8_t *p_src = mem;\n        for (size_t i = 0, k = size; i < size; i++, k--)\n                p_dst[i] = p_src[k-1];\n\n        return p;\n}\n\nvoid* erase_and_free(void *p) {\n        size_t l;\n\n        if (!p)\n                return NULL;\n\n        l = MALLOC_SIZEOF_SAFE(p);\n        explicit_bzero_safe(p, l);\n        return mfree(p);\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "12μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "822347μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "172μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "40μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "54733μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "572μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "877876μs",
      "parallelizable_steps": [],
      "critical_path_length": "822959μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154,
        "content_hash": "f206851f3461b99d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/memory-util.c"
      }
    },
    "source_hash": "eca31c429f26"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/web-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"string-util.h\"\n#include \"strv.h\"\n#include \"utf8.h\"\n#include \"web-util.h\"\n\nbool http_etag_is_valid(const char *etag) {\n        if (isempty(etag))\n                return false;\n\n        if (!endswith(etag, \"\\\"\"))\n                return false;\n\n        if (!STARTSWITH_SET(etag, \"\\\"\", \"W/\\\"\"))\n                return false;\n\n        return true;\n}\n\nbool http_url_is_valid(const char *url) {\n        const char *p;\n\n        if (isempty(url))\n                return false;\n\n        p = STARTSWITH_SET(url, \"http://\", \"https://\");\n        if (!p)\n                return false;\n\n        if (isempty(p))\n                return false;\n\n        return ascii_is_valid(p);\n}\n\nbool file_url_is_valid(const char *url) {\n        const char *p;\n\n        if (isempty(url))\n                return false;\n\n        p = startswith(url, \"file:/\");\n        if (isempty(p))\n                return false;\n\n        return ascii_is_valid(p);\n}\n\nbool documentation_url_is_valid(const char *url) {\n        const char *p;\n\n        if (isempty(url))\n                return false;\n\n        if (http_url_is_valid(url) || file_url_is_valid(url))\n                return true;\n\n        p = STARTSWITH_SET(url, \"info:\", \"man:\");\n        if (isempty(p))\n                return false;\n\n        return ascii_is_valid(p);\n}\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "99μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "921565μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1002μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2325μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "341612μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "713μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1267316μs",
      "parallelizable_steps": [],
      "critical_path_length": "924603μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.7777777777777777
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 45,
        "complexity_score": 3.7777777777777777,
        "content_hash": "a6dad0ec18112747"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/web-util.c"
      }
    },
    "source_hash": "e4a4c9a67d74"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-stub.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"in-addr-util.h\"\n#include \"resolved-forward.h\"\n\ntypedef enum DnsStubListenerMode {\n        DNS_STUB_LISTENER_NO,\n        DNS_STUB_LISTENER_UDP = 1 << 0,\n        DNS_STUB_LISTENER_TCP = 1 << 1,\n        DNS_STUB_LISTENER_YES = DNS_STUB_LISTENER_UDP | DNS_STUB_LISTENER_TCP,\n        _DNS_STUB_LISTENER_MODE_MAX,\n        _DNS_STUB_LISTENER_MODE_INVALID = -EINVAL,\n} DnsStubListenerMode;\n\ntypedef struct DnsStubListenerExtra {\n        Manager *manager;\n\n        DnsStubListenerMode mode;\n\n        int family;\n        union in_addr_union address;\n        uint16_t port;\n\n        sd_event_source *udp_event_source;\n        sd_event_source *tcp_event_source;\n\n        Hashmap *queries_by_packet;\n} DnsStubListenerExtra;\n\nextern const struct hash_ops dns_stub_listener_extra_hash_ops;\n\nint dns_stub_listener_extra_new(Manager *m, DnsStubListenerExtra **ret);\nDnsStubListenerExtra *dns_stub_listener_extra_free(DnsStubListenerExtra *p);\nstatic inline uint16_t dns_stub_listener_extra_port(DnsStubListenerExtra *p) {\n        assert(p);\n\n        return p->port > 0 ? p->port : 53;\n}\n\nvoid manager_dns_stub_stop(Manager *m);\nint manager_dns_stub_start(Manager *m);\n\nconst char* dns_stub_listener_mode_to_string(DnsStubListenerMode p) _const_;\nDnsStubListenerMode dns_stub_listener_mode_from_string(const char *s) _pure_;\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "10μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "8μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "104642μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "53616μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "20μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "29μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "158325μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "104662μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061,
        "content_hash": "279355c8749b5268"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-stub.h"
      }
    },
    "source_hash": "4d4a341898e4"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc-redirect.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscredirectfoo\n#define foosdndiscredirectfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in6_addr;\nstruct ip6_hdr;\n\ntypedef struct sd_ndisc_redirect sd_ndisc_redirect;\n\nsd_ndisc_redirect* sd_ndisc_redirect_ref(sd_ndisc_redirect *na);\nsd_ndisc_redirect* sd_ndisc_redirect_unref(sd_ndisc_redirect *na);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc_redirect, sd_ndisc_redirect_unref);\n\nint sd_ndisc_redirect_set_sender_address(sd_ndisc_redirect *rd, const struct in6_addr *addr);\nint sd_ndisc_redirect_get_sender_address(sd_ndisc_redirect *na, struct in6_addr *ret);\nint sd_ndisc_redirect_get_target_address(sd_ndisc_redirect *na, struct in6_addr *ret);\nint sd_ndisc_redirect_get_destination_address(sd_ndisc_redirect *na, struct in6_addr *ret);\nint sd_ndisc_redirect_get_target_mac(sd_ndisc_redirect *na, struct ether_addr *ret);\nint sd_ndisc_redirect_get_redirected_header(sd_ndisc_redirect *na, struct ip6_hdr *ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "368μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "442448μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "728μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1805μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "482425μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "464μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "928238μs",
      "parallelizable_steps": [],
      "critical_path_length": "483521μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 3.125
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 32,
        "complexity_score": 3.125,
        "content_hash": "4c4f4f3b7afaebdb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc-redirect.h"
      }
    },
    "source_hash": "7d481d402f8e"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-option.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpoptionhfoo\n#define foosddhcpoptionhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n#include \"sd-dhcp-protocol.h\"   /* IWYU pragma: export */\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp_option sd_dhcp_option;\n\nint sd_dhcp_option_new(uint8_t option, const void *data, size_t length, sd_dhcp_option **ret);\nsd_dhcp_option *sd_dhcp_option_ref(sd_dhcp_option *ra);\nsd_dhcp_option *sd_dhcp_option_unref(sd_dhcp_option *ra);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp_option, sd_dhcp_option_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "785μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "164380μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "153μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "275μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "227862μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "543μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "393998μs",
      "parallelizable_steps": [],
      "critical_path_length": "228800μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 4.0,
        "content_hash": "76e13d1d5f67fc86"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-option.h"
      }
    },
    "source_hash": "74cb8d198991"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/home/test-homed-regression-31896.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-locator.h\"\n#include \"main-func.h\"\n#include \"tests.h\"\n\nstatic int run(int argc, char **argv) {\n        _cleanup_(sd_bus_flush_close_unrefp) sd_bus *bus = NULL;\n        _cleanup_(sd_bus_message_unrefp) sd_bus_message *ref = NULL;\n        _cleanup_(sd_bus_error_free) sd_bus_error error = SD_BUS_ERROR_NULL;\n        const char *username = NULL;\n\n        /* This is a regression test for the following bug:\n         * https://github.com/systemd/systemd/pull/31896\n         * It is run as part of TEST-46-HOMED\n         */\n\n        test_setup_logging(LOG_DEBUG);\n        assert_se(sd_bus_open_system(&bus) >= 0);\n\n        assert_se(argc == 2);\n        username = argv[1];\n\n        assert_se(bus_call_method(bus, bus_home_mgr, \"RefHomeUnrestricted\", NULL, &ref, \"sb\", username, true) >= 0);\n\n        assert_se(bus_call_method_async(bus, NULL, bus_home_mgr, \"AuthenticateHome\", NULL, NULL, \"ss\", username, \"{}\") >= 0);\n        assert_se(sd_bus_flush(bus) >= 0);\n\n        (void) bus_call_method(bus, bus_home_mgr, \"ReleaseHome\", &error, NULL, \"s\", username);\n        assert_se(!sd_bus_error_has_name(&error, SD_BUS_ERROR_NO_REPLY)); /* Make sure we didn't crash */\n\n        return 0;\n}\n\nDEFINE_MAIN_FUNCTION(run);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "342μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "50155μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "19μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "620μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "215957μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "9μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "267102μs",
      "parallelizable_steps": [],
      "critical_path_length": "216318μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 1.153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 26,
        "complexity_score": 1.153846153846154,
        "content_hash": "80c0d47d1c9b09e6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/home/test-homed-regression-31896.c"
      }
    },
    "source_hash": "54dc96f24902"
  },
  {
    "instruction": "Examine and structure this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "440μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "265863μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "537μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "519μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "267966μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "266670μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "8dd763201fce"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/dhcp-duid-internal.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-dhcp-duid.h\"\n#include \"sd-id128.h\"\n\n#include \"ether-addr-util.h\"\n#include \"forward.h\"\n#include \"sparse-endian.h\"\n\n#define SYSTEMD_PEN    43793\n\ntypedef enum DUIDType {\n        DUID_TYPE_LLT      = SD_DUID_TYPE_LLT,\n        DUID_TYPE_EN       = SD_DUID_TYPE_EN,\n        DUID_TYPE_LL       = SD_DUID_TYPE_LL,\n        DUID_TYPE_UUID     = SD_DUID_TYPE_UUID,\n        _DUID_TYPE_MAX,\n        _DUID_TYPE_INVALID = -EINVAL,\n} DUIDType;\n\n/* RFC 8415 section 11.1:\n * A DUID consists of a 2-octet type code represented in network byte order, followed by a variable number of\n * octets that make up the actual identifier. The length of the DUID (not including the type code) is at\n * least 1 octet and at most 128 octets. */\n#define MIN_DUID_DATA_LEN 1\n#define MAX_DUID_DATA_LEN 128\n#define MIN_DUID_LEN (sizeof(be16_t) + MIN_DUID_DATA_LEN)\n#define MAX_DUID_LEN (sizeof(be16_t) + MAX_DUID_DATA_LEN)\n\n/* https://tools.ietf.org/html/rfc3315#section-9.1 */\nstruct duid {\n        be16_t type;\n        union {\n                struct {\n                        /* DUID_TYPE_LLT */\n                        be16_t htype;\n                        be32_t time;\n                        uint8_t haddr[HW_ADDR_MAX_SIZE];\n                } _packed_ llt;\n                struct {\n                        /* DUID_TYPE_EN */\n                        be32_t pen;\n                        /* The maximum length of vendor ID is not provided in RFC 8415, but we use 8 bytes.\n                         * See https://datatracker.ietf.org/doc/html/rfc8415#section-11.3 */\n                        uint8_t id[8];\n                } _packed_ en;\n                struct {\n                        /* DUID_TYPE_LL */\n                        be16_t htype;\n                        uint8_t haddr[HW_ADDR_MAX_SIZE];\n                } _packed_ ll;\n                struct {\n                        /* DUID_TYPE_UUID */\n                        sd_id128_t uuid;\n                } _packed_ uuid;\n                uint8_t data[MAX_DUID_DATA_LEN];\n        };\n} _packed_;\n\nassert_cc(sizeof(struct duid) == MAX_DUID_LEN);\n\ntypedef struct sd_dhcp_duid {\n        size_t size;\n        union {\n                struct duid duid;\n                uint8_t raw[MAX_DUID_LEN];\n        };\n} sd_dhcp_duid;\n\nstatic inline bool duid_size_is_valid(size_t size) {\n        return size >= MIN_DUID_LEN && size <= MAX_DUID_LEN;\n}\n\nstatic inline bool duid_data_size_is_valid(size_t size) {\n        return size >= MIN_DUID_DATA_LEN && size <= MAX_DUID_DATA_LEN;\n}\n\nconst char* duid_type_to_string(DUIDType t) _const_;\nint dhcp_duid_to_string_internal(uint16_t type, const void *data, size_t data_size, char **ret);\n\nint dhcp_identifier_set_iaid(\n                sd_device *dev,\n                const struct hw_addr_data *hw_addr,\n                bool legacy_unstable_byteorder,\n                void *ret);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "52μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "207260μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "181μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "104μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "14763μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "149μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "222509μs",
      "parallelizable_steps": [],
      "critical_path_length": "207513μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 0.5405405405405406
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 74,
        "complexity_score": 0.5405405405405406,
        "content_hash": "9c93f42597333238"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/dhcp-duid-internal.h"
      }
    },
    "source_hash": "65144d5c6bca"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/dns-def.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/* Length of a single label, with all escaping removed, excluding any trailing dot or NUL byte */\n#define DNS_LABEL_MAX 63\n\n/* Worst case length of a single label, with all escaping applied and room for a trailing NUL byte. */\n#define DNS_LABEL_ESCAPED_MAX (DNS_LABEL_MAX*4+1)\n\n/* Maximum length of a full hostname, consisting of a series of unescaped labels, and no trailing dot or NUL byte */\n#define DNS_HOSTNAME_MAX 253\n\n/* Maximum length of a full hostname, on the wire, including the final NUL byte */\n#define DNS_WIRE_FORMAT_HOSTNAME_MAX 255\n\n/* Maximum number of labels per valid hostname */\n#define DNS_N_LABELS_MAX 127\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "377μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "33μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "238334μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "224475μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "916μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "169μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "464304μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "239250μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 13,
        "complexity_score": 4.615384615384616
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 13,
        "complexity_score": 4.615384615384616,
        "content_hash": "2c588e81d60f0174"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/dns-def.h"
      }
    },
    "source_hash": "de9f493984bc"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-mdns.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\n#define MDNS_PORT 5353\n#define MDNS_ANNOUNCE_DELAY (1 * USEC_PER_SEC)\n\nint manager_mdns_ipv4_fd(Manager *m);\nint manager_mdns_ipv6_fd(Manager *m);\n\nvoid manager_mdns_stop(Manager *m);\nvoid manager_mdns_maybe_stop(Manager *m);\nint manager_mdns_start(Manager *m);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "198μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "62μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "78104μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "366716μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "27μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "83μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "445190μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "366861μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 2.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 10,
        "complexity_score": 2.0,
        "content_hash": "29fa74257078487a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-mdns.h"
      }
    },
    "source_hash": "42195564cbbe"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc-neighbor.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscneighborfoo\n#define foosdndiscneighborfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct in6_addr;\nstruct ether_addr;\n\ntypedef struct sd_ndisc_neighbor sd_ndisc_neighbor;\n\nsd_ndisc_neighbor *sd_ndisc_neighbor_ref(sd_ndisc_neighbor *na);\nsd_ndisc_neighbor *sd_ndisc_neighbor_unref(sd_ndisc_neighbor *na);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc_neighbor, sd_ndisc_neighbor_unref);\n\nint sd_ndisc_neighbor_get_sender_address(sd_ndisc_neighbor *na, struct in6_addr *ret);\n/* RFC 4861 section 4.4:\n * For solicited advertisements, the Target Address field in the Neighbor Solicitation message that prompted\n * this advertisement. For an unsolicited advertisement, the address whose link-layer address has changed.\n * The Target Address MUST NOT be a multicast address. */\nint sd_ndisc_neighbor_get_target_address(sd_ndisc_neighbor *na, struct in6_addr *ret);\nint sd_ndisc_neighbor_get_target_mac(sd_ndisc_neighbor *na, struct ether_addr *ret);\nint sd_ndisc_neighbor_get_flags(sd_ndisc_neighbor *na, uint32_t *ret);\nint sd_ndisc_neighbor_is_router(sd_ndisc_neighbor *na);\nint sd_ndisc_neighbor_is_solicited(sd_ndisc_neighbor *na);\nint sd_ndisc_neighbor_is_override(sd_ndisc_neighbor *na);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "234μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "202108μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1053μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1561μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "638313μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "671μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "843940μs",
      "parallelizable_steps": [],
      "critical_path_length": "639600μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 36,
        "complexity_score": 3.333333333333333,
        "content_hash": "a4b91656c71f4300"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc-neighbor.h"
      }
    },
    "source_hash": "372322abf38a"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-bus/test-bus-creds.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-bus.h\"\n\n#include \"bus-dump.h\"\n#include \"cgroup-util.h\"\n#include \"errno-util.h\"\n#include \"tests.h\"\n\nint main(int argc, char *argv[]) {\n        _cleanup_(sd_bus_creds_unrefp) sd_bus_creds *creds = NULL;\n        int r;\n\n        test_setup_logging(LOG_DEBUG);\n\n        if (IN_SET(cg_unified(), -ENOMEDIUM, -ENOENT))\n                return log_tests_skipped(\"/sys/fs/cgroup/ not available\");\n\n        r = sd_bus_creds_new_from_pid(&creds, 0, _SD_BUS_CREDS_ALL);\n        log_full_errno(r < 0 ? LOG_ERR : LOG_DEBUG, r, \"sd_bus_creds_new_from_pid: %m\");\n        assert_se(r >= 0);\n\n        bus_creds_dump(creds, NULL, true);\n\n        creds = sd_bus_creds_unref(creds);\n\n        r = sd_bus_creds_new_from_pid(&creds, 1, _SD_BUS_CREDS_ALL);\n        if (!ERRNO_IS_NEG_PRIVILEGE(r)) {\n                assert_se(r >= 0);\n                putchar('\\n');\n                bus_creds_dump(creds, NULL, true);\n        }\n\n        creds = sd_bus_creds_unref(creds);\n\n        _cleanup_(sd_bus_unrefp) sd_bus *bus = NULL;\n        r = sd_bus_default_system(&bus);\n        if (r < 0)\n                log_warning_errno(r, \"Unable to connect to system bus, skipping rest of test.\");\n        else {\n                const char *unique;\n\n                assert_se(sd_bus_get_unique_name(bus, &unique) >= 0);\n\n                r = sd_bus_get_name_creds(bus, unique, _SD_BUS_CREDS_ALL, &creds);\n                log_full_errno(r < 0 ? LOG_ERR : LOG_DEBUG, r, \"sd_bus_get_name_creds: %m\");\n                assert_se(r >= 0);\n\n                putchar('\\n');\n                bus_creds_dump(creds, NULL, true);\n        }\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "108μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "91μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "190269μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "191028μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "37557μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "94277μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "513372μs",
      "parallelizable_steps": [],
      "critical_path_length": "285396μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 1.282051282051282
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 1.282051282051282,
        "content_hash": "5ce28f9ac4994139"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-bus/test-bus-creds.c"
      }
    },
    "source_hash": "7794db63eaf2"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-web-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"tests.h\"\n#include \"web-util.h\"\n\nTEST(is_valid_documentation_url) {\n        ASSERT_TRUE(documentation_url_is_valid(\"https://www.freedesktop.org/wiki/Software/systemd\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"https://www.kernel.org/doc/Documentation/binfmt_misc.txt\"));  /* dead */\n        ASSERT_TRUE(documentation_url_is_valid(\"https://www.kernel.org/doc/Documentation/admin-guide/binfmt-misc.rst\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"https://docs.kernel.org/admin-guide/binfmt-misc.html\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"file:/foo/foo\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"man:systemd.special(7)\"));\n        ASSERT_TRUE(documentation_url_is_valid(\"info:bar\"));\n\n        ASSERT_FALSE(documentation_url_is_valid(\"foo:\"));\n        ASSERT_FALSE(documentation_url_is_valid(\"info:\"));\n        ASSERT_FALSE(documentation_url_is_valid(\"\"));\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "247μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "186123μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "41μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "206μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "3366μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "162μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "190145μs",
      "parallelizable_steps": [],
      "critical_path_length": "186491μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 16,
        "complexity_score": 0.625
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 16,
        "complexity_score": 0.625,
        "content_hash": "003b06b5cf7c96fe"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-web-util.c"
      }
    },
    "source_hash": "82b17d17e114"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd/sd-varlink/varlink-org.varlink.service.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"varlink-org.varlink.service.h\"\n\nstatic SD_VARLINK_DEFINE_METHOD(\n                GetInfo,\n                SD_VARLINK_DEFINE_OUTPUT(vendor, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(product, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(version, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(url, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(interfaces, SD_VARLINK_STRING, SD_VARLINK_ARRAY));\n\nstatic SD_VARLINK_DEFINE_METHOD(\n                GetInterfaceDescription,\n                SD_VARLINK_DEFINE_INPUT(interface, SD_VARLINK_STRING, 0),\n                SD_VARLINK_DEFINE_OUTPUT(description, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                InterfaceNotFound,\n                SD_VARLINK_DEFINE_FIELD(interface, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                MethodNotFound,\n                SD_VARLINK_DEFINE_FIELD(method, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                MethodNotImplemented,\n                SD_VARLINK_DEFINE_FIELD(method, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(\n                InvalidParameter,\n                SD_VARLINK_DEFINE_FIELD(parameter, SD_VARLINK_STRING, 0));\n\nstatic SD_VARLINK_DEFINE_ERROR(PermissionDenied);\n\nstatic SD_VARLINK_DEFINE_ERROR(ExpectedMore);\n\n/* As per https://varlink.org/Service */\nSD_VARLINK_DEFINE_INTERFACE(\n                org_varlink_service,\n                \"org.varlink.service\",\n                &vl_method_GetInfo,\n                &vl_method_GetInterfaceDescription,\n                &vl_error_InterfaceNotFound,\n                &vl_error_MethodNotFound,\n                &vl_error_MethodNotImplemented,\n                &vl_error_InvalidParameter,\n                &vl_error_PermissionDenied,\n                &vl_error_ExpectedMore);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "63346μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "27μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "195μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "41911μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "85μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "105606μs",
      "parallelizable_steps": [],
      "critical_path_length": "63626μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.2564102564102564
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 39,
        "complexity_score": 0.2564102564102564,
        "content_hash": "08e3e44950767eca"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd/sd-varlink/varlink-org.varlink.service.c"
      }
    },
    "source_hash": "8622a025c0a6"
  },
  {
    "instruction": "Analyze and decompose this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "440μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "265863μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "537μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "519μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "267966μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "266670μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      }
    },
    "source_hash": "541989d22c4e"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/format-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"cgroup-util.h\"\n#include \"forward.h\"\n#include \"stdio-util.h\"\n\nassert_cc(sizeof(pid_t) == sizeof(int32_t));\n#define PID_PRI PRIi32\n#define PID_FMT \"%\" PID_PRI\n\nassert_cc(sizeof(uid_t) == sizeof(uint32_t));\n#define UID_FMT \"%\" PRIu32\n\nassert_cc(sizeof(gid_t) == sizeof(uint32_t));\n#define GID_FMT \"%\" PRIu32\n\n/* Note: the lifetime of the compound literal is the immediately surrounding block,\n * see C11 §6.5.2.5, and\n * https://stackoverflow.com/questions/34880638/compound-literal-lifetime-and-if-blocks */\n#define FORMAT_UID(uid) \\\n        snprintf_ok((char[DECIMAL_STR_MAX(uid_t)]){}, DECIMAL_STR_MAX(uid_t), UID_FMT, uid)\n#define FORMAT_GID(gid) \\\n        snprintf_ok((char[DECIMAL_STR_MAX(gid_t)]){}, DECIMAL_STR_MAX(gid_t), GID_FMT, gid)\n\n#if SIZEOF_TIME_T == 8\n#  define PRI_TIME PRIi64\n#elif SIZEOF_TIME_T == 4\n#  define PRI_TIME \"li\"\n#else\n#  error Unknown time_t size\n#endif\n\n#if SIZEOF_TIMEX_MEMBER == 8\n#  define PRI_TIMEX PRIi64\n#elif SIZEOF_TIMEX_MEMBER == 4\n#  define PRI_TIMEX \"li\"\n#else\n#  error Unknown timex member size\n#endif\n\n#if SIZEOF_RLIM_T == 8\n#  define RLIM_FMT \"%\" PRIu64\n#elif SIZEOF_RLIM_T == 4\n#  define RLIM_FMT \"%\" PRIu32\n#else\n#  error Unknown rlim_t size\n#endif\n\n#if SIZEOF_DEV_T == 8\n#  define DEV_FMT \"%\" PRIu64\n#elif SIZEOF_DEV_T == 4\n#  define DEV_FMT \"%\" PRIu32\n#else\n#  error Unknown dev_t size\n#endif\n\n#if SIZEOF_INO_T == 8\n#  define INO_FMT \"%\" PRIu64\n#elif SIZEOF_INO_T == 4\n#  define INO_FMT \"%\" PRIu32\n#else\n#  error Unknown ino_t size\n#endif\n\ntypedef enum {\n        FORMAT_BYTES_USE_IEC     = 1 << 0,\n        FORMAT_BYTES_BELOW_POINT = 1 << 1,\n        FORMAT_BYTES_TRAILING_B  = 1 << 2,\n} FormatBytesFlag;\n\n#define FORMAT_BYTES_MAX 16U\n\nchar* format_bytes_full(char *buf, size_t l, uint64_t t, FormatBytesFlag flag) _warn_unused_result_;\n\n_warn_unused_result_\nstatic inline char* format_bytes(char *buf, size_t l, uint64_t t) {\n        return format_bytes_full(buf, l, t, FORMAT_BYTES_USE_IEC | FORMAT_BYTES_BELOW_POINT | FORMAT_BYTES_TRAILING_B);\n}\n\n/* Note: the lifetime of the compound literal is the immediately surrounding block,\n * see C11 §6.5.2.5, and\n * https://stackoverflow.com/questions/34880638/compound-literal-lifetime-and-if-blocks */\n#define FORMAT_BYTES(t) format_bytes((char[FORMAT_BYTES_MAX]){}, FORMAT_BYTES_MAX, t)\n#define FORMAT_BYTES_FULL(t, flag) format_bytes_full((char[FORMAT_BYTES_MAX]){}, FORMAT_BYTES_MAX, t, flag)\n\n#define FORMAT_BYTES_CGROUP_PROTECTION(t) (t == CGROUP_LIMIT_MAX ? \"infinity\" : FORMAT_BYTES(t))\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "951μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "2303291μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "5238μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "3047μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "1144487μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "928μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "3457942μs",
      "parallelizable_steps": [],
      "critical_path_length": "2307266μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 71,
        "complexity_score": 6.619718309859155
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 71,
        "complexity_score": 6.619718309859155,
        "content_hash": "3bd194a888e57d7f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/format-util.h"
      }
    },
    "source_hash": "aa6b683d186a"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-dns.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"networkd-forward.h\"\n#include \"networkd-util.h\"\n\ntypedef enum UseDomains {\n        USE_DOMAINS_NO,\n        USE_DOMAINS_YES,\n        USE_DOMAINS_ROUTE,\n        _USE_DOMAINS_MAX,\n        _USE_DOMAINS_INVALID = -EINVAL,\n} UseDomains;\n\nUseDomains link_get_use_domains(Link *link, NetworkConfigSource proto);\nbool link_get_use_dns(Link *link, NetworkConfigSource proto);\nbool link_get_use_dnr(Link *link, NetworkConfigSource proto);\n\nconst char* use_domains_to_string(UseDomains p) _const_;\nUseDomains use_domains_from_string(const char *s) _pure_;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_domains);\nCONFIG_PARSER_PROTOTYPE(config_parse_dns);\nCONFIG_PARSER_PROTOTYPE(config_parse_dnssec_negative_trust_anchors);\nCONFIG_PARSER_PROTOTYPE(config_parse_dhcp_use_dns);\nCONFIG_PARSER_PROTOTYPE(config_parse_use_domains);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "44μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "18μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "106684μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "46159μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "116μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "23μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "153044μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "106800μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 0.9523809523809523
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 0.9523809523809523,
        "content_hash": "bb5178522f96a20d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-dns.h"
      }
    },
    "source_hash": "cc053696e8fa"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ndisc-router-solicit.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdndiscroutersolicitfoo\n#define foosdndiscroutersolicitfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\nstruct in6_addr;\nstruct ether_addr;\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_ndisc_router_solicit sd_ndisc_router_solicit;\n\nsd_ndisc_router_solicit *sd_ndisc_router_solicit_ref(sd_ndisc_router_solicit *rs);\nsd_ndisc_router_solicit *sd_ndisc_router_solicit_unref(sd_ndisc_router_solicit *rs);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ndisc_router_solicit, sd_ndisc_router_solicit_unref);\n\nint sd_ndisc_router_solicit_get_sender_address(sd_ndisc_router_solicit *rs, struct in6_addr *ret);\nint sd_ndisc_router_solicit_get_sender_mac(sd_ndisc_router_solicit *rs, struct ether_addr *ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1218μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1392908μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "2021μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1645μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "314563μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "124μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1712479μs",
      "parallelizable_steps": [],
      "critical_path_length": "1394677μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 3.7037037037037033
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 3.7037037037037033,
        "content_hash": "db22055b973a256b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ndisc-router-solicit.h"
      }
    },
    "source_hash": "3d1028b8e1f4"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dnssd-bus.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#include \"forward.h\"\n\nextern const BusObjectImplementation dnssd_object;\n\nint bus_dnssd_method_unregister(sd_bus_message *message, void *userdata, sd_bus_error *error);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "698μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "182μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "363659μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "255894μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "210μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "5μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "620648μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "363869μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 5,
        "complexity_score": 4.0,
        "content_hash": "308505f87cfcc600"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dnssd-bus.h"
      }
    },
    "source_hash": "fd0fa6b76ab9"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-stream.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/socket.h>\n\n#include \"sd-id128.h\"\n\n#include \"journald-forward.h\"\n#include \"list.h\"\n\ntypedef enum StdoutStreamState {\n        STDOUT_STREAM_IDENTIFIER,\n        STDOUT_STREAM_UNIT_ID,\n        STDOUT_STREAM_PRIORITY,\n        STDOUT_STREAM_LEVEL_PREFIX,\n        STDOUT_STREAM_FORWARD_TO_SYSLOG,\n        STDOUT_STREAM_FORWARD_TO_KMSG,\n        STDOUT_STREAM_FORWARD_TO_CONSOLE,\n        STDOUT_STREAM_RUNNING,\n} StdoutStreamState;\n\ntypedef struct StdoutStream {\n        Manager *manager;\n        StdoutStreamState state;\n\n        int fd;\n\n        struct ucred ucred;\n        char *label;\n        char *identifier;\n        char *unit_id;\n        int priority;\n        bool level_prefix:1;\n        bool forward_to_syslog:1;\n        bool forward_to_kmsg:1;\n        bool forward_to_console:1;\n\n        bool fdstore:1;\n        bool in_notify_queue:1;\n\n        char *buffer;\n        size_t length;\n\n        sd_event_source *event_source;\n\n        char *state_file;\n\n        ClientContext *context;\n\n        LIST_FIELDS(StdoutStream, stdout_stream);\n        LIST_FIELDS(StdoutStream, stdout_stream_notify_queue);\n\n        char id_field[STRLEN(\"_STREAM_ID=\") + SD_ID128_STRING_MAX];\n\n        LIST_HEAD(StreamSyncReq, stream_sync_reqs);\n} StdoutStream;\n\nint manager_open_stdout_socket(Manager *m, const char *stdout_socket);\nint manager_restore_streams(Manager *m, FDSet *fds);\n\nStdoutStream* stdout_stream_free(StdoutStream *s);\nint stdout_stream_install(Manager *m, int fd, StdoutStream **ret);\nvoid stdout_stream_terminate(StdoutStream *s);\nvoid stdout_stream_send_notify(StdoutStream *s);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "243μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "6μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "390567μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "526900μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "121926μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "353315μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "432μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1393389μs",
      "parallelizable_steps": [],
      "critical_path_length": "880221μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 2.765957446808511
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 47,
        "complexity_score": 2.765957446808511,
        "content_hash": "8095de6947bc6220"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-stream.h"
      }
    },
    "source_hash": "f868bf61408d"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-audit.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <sys/socket.h>\n\n#include \"journald-forward.h\"\n\nvoid manager_process_audit_message(Manager *m, const void *buffer, size_t buffer_size, const struct ucred *ucred, const union sockaddr_union *sa, socklen_t salen);\n\nvoid process_audit_string(Manager *m, int type, const char *data, size_t size);\n\nint manager_open_audit(Manager *m);\nvoid manager_reset_kernel_audit(Manager *m, int old_set_audit);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "200μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "435226μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "451777μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "96608μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "329595μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "344μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1313792μs",
      "parallelizable_steps": [],
      "critical_path_length": "781572μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 8,
        "complexity_score": 2.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 8,
        "complexity_score": 2.5,
        "content_hash": "0f58fbf6643b997f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-audit.h"
      }
    },
    "source_hash": "dd296fdb1398"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/resolve-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"conf-parser.h\"\n#include \"in-addr-util.h\"\n#include \"resolve-util.h\"\n#include \"string-table.h\"\n\nDEFINE_CONFIG_PARSE_ENUM(config_parse_resolve_support, resolve_support, ResolveSupport);\nDEFINE_CONFIG_PARSE_ENUM(config_parse_dnssec_mode, dnssec_mode, DnssecMode);\nDEFINE_CONFIG_PARSE_ENUM(config_parse_dns_over_tls_mode, dns_over_tls_mode, DnsOverTlsMode);\n\nstatic const char* const resolve_support_table[_RESOLVE_SUPPORT_MAX] = {\n        [RESOLVE_SUPPORT_NO] = \"no\",\n        [RESOLVE_SUPPORT_YES] = \"yes\",\n        [RESOLVE_SUPPORT_RESOLVE] = \"resolve\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(resolve_support, ResolveSupport, RESOLVE_SUPPORT_YES);\n\nstatic const char* const dnssec_mode_table[_DNSSEC_MODE_MAX] = {\n        [DNSSEC_NO] = \"no\",\n        [DNSSEC_ALLOW_DOWNGRADE] = \"allow-downgrade\",\n        [DNSSEC_YES] = \"yes\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(dnssec_mode, DnssecMode, DNSSEC_YES);\n\nstatic const char* const dns_over_tls_mode_table[_DNS_OVER_TLS_MODE_MAX] = {\n        [DNS_OVER_TLS_NO] = \"no\",\n        [DNS_OVER_TLS_OPPORTUNISTIC] = \"opportunistic\",\n        [DNS_OVER_TLS_YES] = \"yes\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(dns_over_tls_mode, DnsOverTlsMode, DNS_OVER_TLS_YES);\n\nbool dns_server_address_valid(int family, const union in_addr_union *sa) {\n\n        /* Refuses the 0 IP addresses as well as 127.0.0.53/127.0.0.54 (which is our own DNS stub) */\n\n        if (!in_addr_is_set(family, sa))\n                return false;\n\n        if (family == AF_INET && IN_SET(be32toh(sa->in.s_addr), INADDR_DNS_STUB, INADDR_DNS_PROXY_STUB))\n                return false;\n\n        return true;\n}\n\nDEFINE_CONFIG_PARSE_ENUM(config_parse_dns_cache_mode, dns_cache_mode, DnsCacheMode);\n\nstatic const char* const dns_cache_mode_table[_DNS_CACHE_MODE_MAX] = {\n        [DNS_CACHE_MODE_YES] = \"yes\",\n        [DNS_CACHE_MODE_NO] = \"no\",\n        [DNS_CACHE_MODE_NO_NEGATIVE] = \"no-negative\",\n};\nDEFINE_STRING_TABLE_LOOKUP_WITH_BOOLEAN(dns_cache_mode, DnsCacheMode, DNS_CACHE_MODE_YES);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "298μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "29μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "119974μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "67937μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "257μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "11μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "188506μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "120231μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732,
        "content_hash": "6280c558ebfb7f7f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/resolve-util.c"
      }
    },
    "source_hash": "a400ffeb8b5f"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/pcapng.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/*\n * For details about the file format see RFC:\n *   https://www.ietf.org/id/draft-tuexen-opsawg-pcapng-03.html\n *  and\n *    https://github.com/pcapng/pcapng/\n */\nenum pcapng_block_types {\n        PCAPNG_INTERFACE_BLOCK = 1,\n        PCAPNG_PACKET_BLOCK,\t\t/* Obsolete */\n        PCAPNG_SIMPLE_PACKET_BLOCK,\n        PCAPNG_NAME_RESOLUTION_BLOCK,\n        PCAPNG_INTERFACE_STATS_BLOCK,\n        PCAPNG_ENHANCED_PACKET_BLOCK,\n\n        PCAPNG_SECTION_BLOCK   = 0x0A0D0D0A,\n};\n\nstruct pcapng_option {\n        uint16_t code;\n        uint16_t length;\n        uint8_t data[];\n};\n\n#define PCAPNG_BYTE_ORDER_MAGIC 0x1A2B3C4D\n#define PCAPNG_MAJOR_VERS 1\n#define PCAPNG_MINOR_VERS 0\n\nenum pcapng_opt {\n        PCAPNG_OPT_END     = 0,\n        PCAPNG_OPT_COMMENT = 1,\n};\n\nstruct pcapng_section {\n        uint32_t block_type;\n        uint32_t block_length;\n        uint32_t byte_order_magic;\n        uint16_t major_version;\n        uint16_t minor_version;\n        uint64_t section_length;\n};\n\nenum pcapng_section_opt {\n        PCAPNG_SHB_HARDWARE = 2,\n        PCAPNG_SHB_OS       = 3,\n        PCAPNG_SHB_USERAPPL = 4,\n};\n\nstruct pcapng_interface_block {\n        uint32_t block_type;\t/* 1 */\n        uint32_t block_length;\n        uint16_t link_type;\n        uint16_t reserved;\n        uint32_t snap_len;\n};\n\nenum pcapng_interface_options {\n        PCAPNG_IFB_NAME\t = 2,\n        PCAPNG_IFB_DESCRIPTION,\n        PCAPNG_IFB_IPV4ADDR,\n        PCAPNG_IFB_IPV6ADDR,\n        PCAPNG_IFB_MACADDR,\n        PCAPNG_IFB_EUIADDR,\n        PCAPNG_IFB_SPEED,\n        PCAPNG_IFB_TSRESOL,\n        PCAPNG_IFB_TZONE,\n        PCAPNG_IFB_FILTER,\n        PCAPNG_IFB_OS,\n        PCAPNG_IFB_FCSLEN,\n        PCAPNG_IFB_TSOFFSET,\n        PCAPNG_IFB_HARDWARE,\n};\n\nstruct pcapng_enhance_packet_block {\n        uint32_t block_type;\t/* 6 */\n        uint32_t block_length;\n        uint32_t interface_id;\n        uint32_t timestamp_hi;\n        uint32_t timestamp_lo;\n        uint32_t capture_length;\n        uint32_t original_length;\n};\n\n/* Flags values */\n#define PCAPNG_IFB_INBOUND   0b01\n#define PCAPNG_IFB_OUTBOUND  0b10\n\nenum pcapng_epb_options {\n        PCAPNG_EPB_FLAGS = 2,\n        PCAPNG_EPB_HASH,\n        PCAPNG_EPB_DROPCOUNT,\n        PCAPNG_EPB_PACKETID,\n        PCAPNG_EPB_QUEUE,\n        PCAPNG_EPB_VERDICT,\n};\n\nstruct pcapng_statistics_block {\n        uint32_t block_type;\t/* 5 */\n        uint32_t block_length;\n        uint32_t interface_id;\n        uint32_t timestamp_hi;\n        uint32_t timestamp_lo;\n};\n\nenum pcapng_isb_options {\n        PCAPNG_ISB_STARTTIME = 2,\n        PCAPNG_ISB_ENDTIME,\n        PCAPNG_ISB_IFRECV,\n        PCAPNG_ISB_IFDROP,\n        PCAPNG_ISB_FILTERACCEPT,\n        PCAPNG_ISB_OSDROP,\n        PCAPNG_ISB_USRDELIV,\n};\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "339μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "785600μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "569μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1565μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "143370μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "624μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "932067μs",
      "parallelizable_steps": [],
      "critical_path_length": "787789μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 102,
        "complexity_score": 2.1568627450980395
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 102,
        "complexity_score": 2.1568627450980395,
        "content_hash": "2a468150112dc4d3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/pcapng.h"
      }
    },
    "source_hash": "0ac9d2050473"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/override/netinet/in.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <linux/in.h>   /* IWYU pragma: export */\n#include <linux/in6.h>  /* IWYU pragma: export */\n#include <linux/ipv6.h> /* IWYU pragma: export */\n#include <stddef.h>\n#include <stdint.h>\n#include <sys/socket.h>\n\n#define INET_ADDRSTRLEN 16\n#define INET6_ADDRSTRLEN 46\n\nextern const struct in6_addr in6addr_any;        /* :: */\nextern const struct in6_addr in6addr_loopback;   /* ::1 */\n#define IN6ADDR_ANY_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } }\n#define IN6ADDR_LOOPBACK_INIT { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 } } }\n\ntypedef uint32_t in_addr_t;\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "9μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "48708μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "42779μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "7528μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "102292μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "104μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "201473μs",
      "parallelizable_steps": [],
      "critical_path_length": "145080μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 0.6666666666666666,
        "content_hash": "7ad6744144d86617"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/override/netinet/in.h"
      }
    },
    "source_hash": "3683bfadf0d3"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/confidential-virt-fundamental.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stdint.h>\n\n/* Keep CVM detection logic in this file at feature parity with\n * that in src/efi/boot/vmm.c */\n\n#define CPUID_PROCESSOR_INFO_AND_FEATURE_BITS UINT32_C(0x1)\n\n/*\n * AMD64 Architecture Programmer’s Manual Volume 3:\n * General-Purpose and System Instructions.\n * Chapter: E4.1 - Maximum Extended Function Number and Vendor String\n *  https://www.amd.com/system/files/TechDocs/24594.pdf\n */\n#define CPUID_GET_HIGHEST_FUNCTION UINT32_C(0x80000000)\n\n/*\n * AMD64 Architecture Programmer’s Manual Volume 3:\n * General-Purpose and System Instructions.\n * Chapter: E4.17 - Encrypted Memory Capabilities\n *  https://www.amd.com/system/files/TechDocs/24594.pdf\n */\n#define CPUID_AMD_GET_ENCRYPTED_MEMORY_CAPABILITIES UINT32_C(0x8000001f)\n\n/*\n * AMD64 Architecture Programmer’s Manual Volume 3:\n * General-Purpose and System Instructions.\n * Chapter: 15.34.10 - SEV_STATUS MSR\n * https://www.amd.com/system/files/TechDocs/24593.pdf\n */\n#define MSR_AMD64_SEV UINT32_C(0xc0010131)\n\n/*\n * Intel® TDX Module v1.5 Base Architecture Specification\n * Chapter: 11.2\n * https://www.intel.com/content/www/us/en/content-details/733575/intel-tdx-module-v1-5-base-architecture-specification.html\n */\n\n#define CPUID_INTEL_TDX_ENUMERATION UINT32_C(0x21)\n\n/* Requirements for Implementing the Microsoft Hypervisor Interface\n * https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/tlfs/tlfs\n */\n#define CPUID_HYPERV_VENDOR_AND_MAX_FUNCTIONS UINT32_C(0x40000000)\n\n#define CPUID_HYPERV_FEATURES UINT32_C(0x40000003)\n\n#define CPUID_HYPERV_ISOLATION_CONFIG UINT32_C(0x4000000C)\n\n#define CPUID_HYPERV_MIN UINT32_C(0x40000005)\n#define CPUID_HYPERV_MAX UINT32_C(0x4000ffff)\n\n#define CPUID_SIG_AMD       \"AuthenticAMD\"\n#define CPUID_SIG_INTEL     \"GenuineIntel\"\n#define CPUID_SIG_INTEL_TDX \"IntelTDX    \"\n#define CPUID_SIG_HYPERV    \"Microsoft Hv\"\n\n/* ecx bit 31: set => hyperpvisor, unset => bare metal */\n#define CPUID_FEATURE_HYPERVISOR (UINT32_C(1) << 31)\n\n/* Linux include/asm-generic/hyperv-tlfs.h */\n#define CPUID_HYPERV_CPU_MANAGEMENT (UINT32_C(1) << 12) /* root partition */\n#define CPUID_HYPERV_ISOLATION      (UINT32_C(1) << 22) /* confidential VM partition */\n\n#define CPUID_HYPERV_ISOLATION_TYPE_MASK UINT32_C(0xf)\n#define CPUID_HYPERV_ISOLATION_TYPE_SNP 2\n#define CPUID_HYPERV_ISOLATION_TYPE_TDX 3\n\n#define EAX_SEV     (UINT32_C(1) << 1)\n#define MSR_SEV     (UINT64_C(1) << 0)\n#define MSR_SEV_ES  (UINT64_C(1) << 1)\n#define MSR_SEV_SNP (UINT64_C(1) << 2)\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "247μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "328195μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "229μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "582μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "10084μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "7μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "339344μs",
      "parallelizable_steps": [],
      "critical_path_length": "328784μs",
      "metadata": {
        "functions_found": [
          "UINT32_C"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.8928571428571429
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "UINT32_C"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 0.8928571428571429,
        "content_hash": "aafc9e27025a1c7c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/confidential-virt-fundamental.h"
      }
    },
    "source_hash": "a5486e1f4dd4"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/timesync/timesyncd-server.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"socket-util.h\"\n#include \"timesyncd-forward.h\"\n\ntypedef enum ServerType {\n        SERVER_SYSTEM,\n        SERVER_FALLBACK,\n        SERVER_LINK,\n        SERVER_RUNTIME,\n        _SERVER_TYPE_MAX,\n        _SERVER_TYPE_INVALID = -EINVAL,\n} ServerType;\n\nstruct ServerAddress {\n        ServerName *name;\n\n        union sockaddr_union sockaddr;\n        socklen_t socklen;\n\n        LIST_FIELDS(ServerAddress, addresses);\n};\n\nstruct ServerName {\n        Manager *manager;\n\n        bool marked;\n\n        ServerType type;\n        char *string;\n\n        LIST_HEAD(ServerAddress, addresses);\n        LIST_FIELDS(ServerName, names);\n};\n\nint server_address_new(ServerName *n, ServerAddress **ret, const union sockaddr_union *sockaddr, socklen_t socklen);\nServerAddress* server_address_free(ServerAddress *a);\nstatic inline int server_address_pretty(ServerAddress *a, char **pretty) {\n        return sockaddr_pretty(&a->sockaddr.sa, a->socklen, true, true, pretty);\n}\n\nint server_name_new(Manager *m, ServerName **ret, ServerType type,const char *string);\nServerName *server_name_free(ServerName *n);\nvoid server_name_flush_addresses(ServerName *n);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "62μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "21μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "74393μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "6418μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "68693μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "62798μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "20μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "212405μs",
      "parallelizable_steps": [],
      "critical_path_length": "143168μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 0.5714285714285714
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 35,
        "complexity_score": 0.5714285714285714,
        "content_hash": "4b7bb2df975290cb"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/timesync/timesyncd-server.h"
      }
    },
    "source_hash": "aa5b4c9093cc"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/af-list.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <string.h>\n#include <sys/socket.h>\n\n#include \"af-list.h\"\n#include \"string-util.h\"\n\nstatic const struct af_name* lookup_af(register const char *str, register GPERF_LEN_TYPE len);\n\n#include \"af-from-name.inc\"\n#include \"af-to-name.inc\"\n\nconst char* af_to_name(int id) {\n\n        if (id <= 0)\n                return NULL;\n\n        if ((size_t) id >= ELEMENTSOF(af_names))\n                return NULL;\n\n        return af_names[id];\n}\n\nconst char* af_to_name_short(int id) {\n        const char *f;\n\n        if (id == AF_UNSPEC)\n                return \"*\";\n\n        f = af_to_name(id);\n        if (!f)\n                return \"unknown\";\n\n        assert(startswith(f, \"AF_\"));\n        return f + 3;\n}\n\nint af_from_name(const char *name) {\n        const struct af_name *sc;\n\n        assert(name);\n\n        sc = lookup_af(name, strlen(name));\n        if (!sc)\n                return -EINVAL;\n\n        return sc->id;\n}\n\nint af_max(void) {\n        return ELEMENTSOF(af_names);\n}\n\nconst char* af_to_ipv4_ipv6(int id) {\n        /* Pretty often we want to map the address family to the typically used protocol name for IPv4 +\n         * IPv6. Let's add special helpers for that. */\n        return id == AF_INET ? \"ipv4\" :\n                id == AF_INET6 ? \"ipv6\" : NULL;\n}\n\nint af_from_ipv4_ipv6(const char *af) {\n        return streq_ptr(af, \"ipv4\") ? AF_INET :\n                streq_ptr(af, \"ipv6\") ? AF_INET6 : AF_UNSPEC;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "235μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "72μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "182044μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "88711μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "313976μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "184672μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "45μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "769755μs",
      "parallelizable_steps": [],
      "critical_path_length": "496300μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 1.9565217391304348
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 46,
        "complexity_score": 1.9565217391304348,
        "content_hash": "e2e0fe764be9fb22"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/af-list.c"
      }
    },
    "source_hash": "20f00e848030"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/catalog-report.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: MIT\n#\n# This file is distributed under the MIT license, see below.\n#\n# The MIT License (MIT)\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n\"\"\"\nPrints out journal entries with no or bad catalog explanations.\n\"\"\"\n\nimport re\n\nfrom systemd import id128, journal\n\n\n# pylint: disable=consider-using-f-string\ndef log_entry(entry):\n    if 'CODE_FILE' in entry:\n        # some of our code was using 'CODE_FUNCTION' instead of 'CODE_FUNC'\n        print('{}:{} {}'.format(entry.get('CODE_FILE', '???'),\n                                entry.get('CODE_LINE', '???'),\n                                entry.get('CODE_FUNC', None) or entry.get('CODE_FUNCTION', '???')))\n    print('    {}'.format(entry.get('MESSAGE', 'no message!')))\n    for k, v in entry.items():\n        if k.startswith('CODE_') or k in {'MESSAGE_ID', 'MESSAGE'}:\n            continue\n        print(f'    {k}={v}')\n    print()\n\nif __name__ == '__main__':\n    j = journal.Reader()\n    logged = set()\n    pattern = re.compile('@[A-Z0-9_]+@')\n\n    mids = { v:k for k,v in id128.__dict__.items() if k.startswith('SD_MESSAGE') }\n\n    for i, x in enumerate(j):\n        if i % 1000 == 0:\n            print(i, end='\\r')\n\n        try:\n            mid = x['MESSAGE_ID']\n        except KeyError:\n            continue\n        name = mids.get(mid, 'unknown')\n\n        try:\n            desc = journal.get_catalog(mid)\n        except FileNotFoundError:\n            if mid in logged:\n                continue\n\n            print(f'{name} {mid.hex}: no catalog entry')\n            log_entry(x)\n            logged.add(mid)\n            continue\n\n        fields = [field[1:-1] for field in pattern.findall(desc)]\n        for field in fields:\n            index = (mid, field)\n            if field in x or index in logged:\n                continue\n            print(f'{name} {mid.hex}: no field {field}')\n            log_entry(x)\n            logged.add(index)\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "563μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "49μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "167789μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "983471μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "547957μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "732355μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "70037μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "239μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "2502460μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1716114μs",
      "metadata": {
        "functions_found": [
          "log_entry"
        ],
        "classes_found": [],
        "imports": [
          "re",
          "systemd"
        ],
        "lines_of_code": 72,
        "complexity_score": 5.694444444444445
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [
          "log_entry"
        ],
        "classes": [],
        "imports": [
          "re",
          "systemd"
        ],
        "lines_of_code": 72,
        "complexity_score": 5.694444444444445,
        "content_hash": "efb4637595b7db2a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/catalog-report.py"
      }
    },
    "source_hash": "89558e81fe10"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-duid.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpduidhfoo\n#define foosddhcpduidhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nenum {\n        SD_DUID_TYPE_LLT        = 1,\n        SD_DUID_TYPE_EN         = 2,\n        SD_DUID_TYPE_LL         = 3,\n        SD_DUID_TYPE_UUID       = 4\n};\n\ntypedef struct sd_dhcp_duid sd_dhcp_duid;\n\nint sd_dhcp_duid_clear(sd_dhcp_duid *duid);\n\nint sd_dhcp_duid_is_set(const sd_dhcp_duid *duid);\n\nint sd_dhcp_duid_get(const sd_dhcp_duid *duid, uint16_t *ret_type, const void **ret_data, size_t *ret_size);\nint sd_dhcp_duid_get_raw(const sd_dhcp_duid *duid, const void **ret_data, size_t *ret_size);\n\nint sd_dhcp_duid_set(\n                sd_dhcp_duid *duid,\n                uint16_t duid_type,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_duid_set_raw(\n                sd_dhcp_duid *duid,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_duid_set_llt(\n                sd_dhcp_duid *duid,\n                const void *hw_addr,\n                size_t hw_addr_size,\n                uint16_t arp_type,\n                uint64_t usec);\nint sd_dhcp_duid_set_ll(\n                sd_dhcp_duid *duid,\n                const void *hw_addr,\n                size_t hw_addr_size,\n                uint16_t arp_type);\nint sd_dhcp_duid_set_en(sd_dhcp_duid *duid);\nint sd_dhcp_duid_set_uuid(sd_dhcp_duid *duid);\n\nint sd_dhcp_duid_to_string(const sd_dhcp_duid *duid, char **ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "324μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "331361μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "895μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "651μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "139485μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "168μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "472884μs",
      "parallelizable_steps": [],
      "critical_path_length": "332180μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 1.8867924528301887
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 53,
        "complexity_score": 1.8867924528301887,
        "content_hash": "da4ce8bbb04cc739"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-duid.h"
      }
    },
    "source_hash": "2e633ee1e6d7"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/core/all-units.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"automount.h\"  /* IWYU pragma: export */\n#include \"device.h\"     /* IWYU pragma: export */\n#include \"mount.h\"      /* IWYU pragma: export */\n#include \"path.h\"       /* IWYU pragma: export */\n#include \"scope.h\"      /* IWYU pragma: export */\n#include \"service.h\"    /* IWYU pragma: export */\n#include \"slice.h\"      /* IWYU pragma: export */\n#include \"socket.h\"     /* IWYU pragma: export */\n#include \"swap.h\"       /* IWYU pragma: export */\n#include \"target.h\"     /* IWYU pragma: export */\n#include \"timer.h\"      /* IWYU pragma: export */\n#include \"unit.h\"       /* IWYU pragma: export */\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "112μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "71μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "36247μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "103233μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "41723μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "102823μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "7μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "284216μs",
      "parallelizable_steps": [],
      "critical_path_length": "206127μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 0.7142857142857142
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 14,
        "complexity_score": 0.7142857142857142,
        "content_hash": "6f040d9ed0cccad2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/core/all-units.h"
      }
    },
    "source_hash": "ad6a3b93e9ca"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-utf8.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdutf8hfoo\n#define foosdutf8hfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\n_sd_pure_ const char *sd_utf8_is_valid(const char *s);\n_sd_pure_ const char *sd_ascii_is_valid(const char *s);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1221928μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "901μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "621μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "478739μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "37μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1702268μs",
      "parallelizable_steps": [],
      "critical_path_length": "1222586μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 4.761904761904762
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 21,
        "complexity_score": 4.761904761904762,
        "content_hash": "d4ec0c6496e33f19"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-utf8.h"
      }
    },
    "source_hash": "051a6f3641ba"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/netdev/wireguard.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#pragma once\n\n#include <linux/wireguard.h>\n\n#include \"in-addr-util.h\"\n#include \"list.h\"\n#include \"netdev.h\"\n#include \"networkd-forward.h\"\n#include \"socket-util.h\"\n\ntypedef struct WireguardIPmask {\n        uint16_t family;\n        union in_addr_union ip;\n        uint8_t cidr;\n\n        LIST_FIELDS(struct WireguardIPmask, ipmasks);\n} WireguardIPmask;\n\ntypedef struct WireguardPeer {\n        Wireguard *wireguard;\n        ConfigSection *section;\n\n        uint8_t public_key[WG_KEY_LEN];\n        uint8_t preshared_key[WG_KEY_LEN];\n        char *public_key_file;\n        char *preshared_key_file;\n        uint32_t flags;\n        uint16_t persistent_keepalive_interval;\n\n        union sockaddr_union endpoint;\n        char *endpoint_host;\n        char *endpoint_port;\n\n        unsigned n_retries;\n        sd_event_source *resolve_retry_event_source;\n        sd_resolve_query *resolve_query;\n\n        uint32_t route_table;\n        uint32_t route_priority;\n        bool route_table_set;\n        bool route_priority_set;\n\n        LIST_HEAD(WireguardIPmask, ipmasks);\n        LIST_FIELDS(struct WireguardPeer, peers);\n} WireguardPeer;\n\ntypedef struct Wireguard {\n        NetDev meta;\n        unsigned last_peer_section;\n\n        uint32_t flags;\n        uint8_t private_key[WG_KEY_LEN];\n        char *private_key_file;\n        uint16_t port;\n        uint32_t fwmark;\n\n        Hashmap *peers_by_section;\n        LIST_HEAD(WireguardPeer, peers);\n\n        Set *routes;\n        uint32_t route_table;\n        uint32_t route_priority;\n} Wireguard;\n\nDEFINE_NETDEV_CAST(WIREGUARD, Wireguard);\nextern const NetDevVTable wireguard_vtable;\n\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_allowed_ips);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_endpoint);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_listen_port);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_key);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_key_file);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_private_key);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_private_key_file);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_keepalive);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_route_table);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_route_table);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_route_priority);\nCONFIG_PARSER_PROTOTYPE(config_parse_wireguard_peer_route_priority);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "36μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "62325μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "10262μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "64816μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "57384μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "46μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "194904μs",
      "parallelizable_steps": [],
      "critical_path_length": "127223μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 64,
        "complexity_score": 0.46875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 64,
        "complexity_score": 0.46875,
        "content_hash": "8e3a9d64bdf9ac02"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/netdev/wireguard.h"
      }
    },
    "source_hash": "707fac047607"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-ipv4acd.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosdipv4acdfoo\n#define foosdipv4acdfoo\n\n/***\n  Copyright © 2014 Axis Communications AB. All rights reserved.\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include <stdbool.h>\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\nstruct ether_addr;\nstruct in_addr;\n\ntypedef struct sd_event sd_event;\n\nenum {\n        SD_IPV4ACD_EVENT_STOP           = 0,\n        SD_IPV4ACD_EVENT_BIND           = 1,\n        SD_IPV4ACD_EVENT_CONFLICT       = 2\n};\n\ntypedef struct sd_ipv4acd sd_ipv4acd;\ntypedef void (*sd_ipv4acd_callback_t)(sd_ipv4acd *acd, int event, void *userdata);\ntypedef int (*sd_ipv4acd_check_mac_callback_t)(sd_ipv4acd *acd, const struct ether_addr *mac, void *userdata);\n\nint sd_ipv4acd_detach_event(sd_ipv4acd *acd);\nint sd_ipv4acd_attach_event(sd_ipv4acd *acd, sd_event *event, int64_t priority);\nint sd_ipv4acd_get_address(sd_ipv4acd *acd, struct in_addr *address);\nint sd_ipv4acd_set_callback(sd_ipv4acd *acd, sd_ipv4acd_callback_t cb, void *userdata);\nint sd_ipv4acd_set_check_mac_callback(sd_ipv4acd *acd, sd_ipv4acd_check_mac_callback_t cb, void *userdata);\nint sd_ipv4acd_set_mac(sd_ipv4acd *acd, const struct ether_addr *addr);\nint sd_ipv4acd_set_ifindex(sd_ipv4acd *acd, int interface_index);\nint sd_ipv4acd_get_ifindex(sd_ipv4acd *acd);\nint sd_ipv4acd_set_ifname(sd_ipv4acd *acd, const char *interface_name);\nint sd_ipv4acd_get_ifname(sd_ipv4acd *acd, const char **ret);\nint sd_ipv4acd_set_timeout(sd_ipv4acd *acd, uint64_t usec);\nint sd_ipv4acd_set_address(sd_ipv4acd *acd, const struct in_addr *address);\nint sd_ipv4acd_is_running(sd_ipv4acd *acd);\nint sd_ipv4acd_is_bound(sd_ipv4acd *acd);\n__extension__ int sd_ipv4acd_start(sd_ipv4acd *acd, bool reset_conflicts);\nint sd_ipv4acd_stop(sd_ipv4acd *acd);\nsd_ipv4acd *sd_ipv4acd_ref(sd_ipv4acd *acd);\nsd_ipv4acd *sd_ipv4acd_unref(sd_ipv4acd *acd);\nint sd_ipv4acd_new(sd_ipv4acd **ret);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_ipv4acd, sd_ipv4acd_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "248μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "961486μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1719μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1576μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "380379μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "259μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1345667μs",
      "parallelizable_steps": [],
      "critical_path_length": "963321μs",
      "metadata": {
        "functions_found": [
          "void",
          "int"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "void",
          "int"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.692307692307692,
        "content_hash": "6c5b123d2de34cd3"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-ipv4acd.h"
      }
    },
    "source_hash": "f11fc9d999da"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-client-id.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpclientidhfoo\n#define foosddhcpclientidhfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp_client_id sd_dhcp_client_id;\ntypedef struct sd_dhcp_duid sd_dhcp_duid;\n\nint sd_dhcp_client_id_new(sd_dhcp_client_id **ret);\nsd_dhcp_client_id* sd_dhcp_client_id_free(sd_dhcp_client_id *client_id);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp_client_id, sd_dhcp_client_id_free);\n\nint sd_dhcp_client_id_clear(sd_dhcp_client_id *client_id);\n\nint sd_dhcp_client_id_is_set(const sd_dhcp_client_id *client_id);\n\nint sd_dhcp_client_id_get(const sd_dhcp_client_id *client_id, uint8_t *ret_type, const void **ret_data, size_t *ret_size);\nint sd_dhcp_client_id_get_raw(const sd_dhcp_client_id *client_id, const void **ret_data, size_t *ret_size);\n\nint sd_dhcp_client_id_set(\n                sd_dhcp_client_id *client_id,\n                uint8_t type,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_client_id_set_raw(\n                sd_dhcp_client_id *client_id,\n                const void *data,\n                size_t data_size);\nint sd_dhcp_client_id_set_iaid_duid(\n                sd_dhcp_client_id *client_id,\n                uint32_t iaid,\n                sd_dhcp_duid *duid);\n\nint sd_dhcp_client_id_to_string(const sd_dhcp_client_id *client_id, char **ret);\nint sd_dhcp_client_id_to_string_from_raw(const void *data, size_t data_size, char **ret);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "657μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "737706μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1360μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "415μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "130686μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "815μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "871639μs",
      "parallelizable_steps": [],
      "critical_path_length": "738936μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 2.3255813953488373
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 2.3255813953488373,
        "content_hash": "724aba8f4f9cc991"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-client-id.h"
      }
    },
    "source_hash": "3e23420c04af"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/generate-dns_type-gperf.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n\"\"\"Generate %-from-name.gperf from %-list.txt\n\"\"\"\n\nimport sys\n\nname, prefix, input = sys.argv[1:]\n\nprint(\"\"\"\\\n%{\n_Pragma(\"GCC diagnostic ignored \\\\\"-Wimplicit-fallthrough\\\\\"\")\n#if __GNUC__ >= 15\n_Pragma(\"GCC diagnostic ignored \\\\\"-Wzero-as-null-pointer-constant\\\\\"\")\n#endif\n%}\"\"\")\nprint(\"\"\"\\\nstruct {}_name {{ const char* name; int id; }};\n%null-strings\n%%\"\"\".format(name))\n\nfor line in open(input):\n    line = line.rstrip()\n    s = line.replace('_', '-')\n    print(\"{}, {}{}\".format(s, prefix, line))\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "98μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "46μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "121242μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "78531μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "49μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "71μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "200037μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "121291μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 21,
        "complexity_score": 2.8571428571428568
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [
          "sys"
        ],
        "lines_of_code": 21,
        "complexity_score": 2.8571428571428568,
        "content_hash": "be8c929678e9f7d5"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/generate-dns_type-gperf.py"
      }
    },
    "source_hash": "ec380d7f3989"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/efi-loader.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\n/* Various calls that interface with EFI variables implementing https://systemd.io/BOOT_LOADER_INTERFACE */\n\nint efi_loader_get_device_part_uuid(sd_id128_t *ret);\nint efi_stub_get_device_part_uuid(sd_id128_t *ret);\nint efi_loader_get_boot_usec(usec_t *ret_firmware, usec_t *ret_loader);\n\nint efi_loader_get_entries(char ***ret);\n\nint efi_loader_get_features(uint64_t *ret);\nint efi_stub_get_features(uint64_t *ret);\n\nint efi_measured_uki(int log_level);\n\nint efi_loader_get_config_timeout_one_shot(usec_t *ret);\nint efi_loader_update_entry_one_shot_cache(char **cache, struct stat *cache_stat);\n\nint efi_get_variable_id128(const char *variable, sd_id128_t *ret);\n\nbool efi_loader_entry_name_valid(const char *s);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "814μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "214087μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "970μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1245μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "344710μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1262μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "563088μs",
      "parallelizable_steps": [],
      "critical_path_length": "346494μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 3.333333333333333
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 15,
        "complexity_score": 3.333333333333333,
        "content_hash": "46649860e8767504"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/efi-loader.h"
      }
    },
    "source_hash": "1c36f185cae8"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-selinux.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/socket.h>\n\n#include \"fd-util.h\"\n#include \"log.h\"\n#include \"selinux-util.h\"\n#include \"string-util.h\"\n#include \"tests.h\"\n#include \"time-util.h\"\n\nstatic void test_testing(void) {\n        bool b;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n\n        mac_selinux_retest();\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n\n        b = mac_selinux_use();\n        log_info(\"mac_selinux_use → %s\", yes_no(b));\n}\n\nstatic void test_loading(void) {\n        usec_t n1, n2;\n        int r;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        n1 = now(CLOCK_MONOTONIC);\n        r = mac_selinux_init();\n        n2 = now(CLOCK_MONOTONIC);\n        log_info_errno(r, \"mac_selinux_init → %d %.2fs (%m)\", r, (n2 - n1)/1e6);\n}\n\nstatic void test_cleanup(void) {\n        usec_t n1, n2;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        n1 = now(CLOCK_MONOTONIC);\n        mac_selinux_finish();\n        n2 = now(CLOCK_MONOTONIC);\n        log_info(\"mac_selinux_finish → %.2fs\", (n2 - n1)/1e6);\n}\n\nstatic void test_misc(const char* fname) {\n        _cleanup_freecon_ char *label = NULL, *label2 = NULL, *label3 = NULL, *label4 = NULL;\n        int r;\n        _cleanup_close_ int fd = -EBADF;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        r = mac_selinux_get_our_label(&label);\n        log_info_errno(r, \"mac_selinux_get_our_label → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label));\n\n        r = mac_selinux_get_create_label_from_exe(fname, &label2);\n        log_info_errno(r, \"mac_selinux_create_label_from_exe → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label2));\n\n        fd = socket(AF_INET, SOCK_DGRAM, 0);\n        assert_se(fd >= 0);\n\n        r = mac_selinux_get_child_mls_label(fd, fname, label2, &label3);\n        log_info_errno(r, \"mac_selinux_get_child_mls_label → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label3));\n\n        r = mac_selinux_get_peer_label(fd, &label4);\n        log_info_errno(r, \"mac_selinux_get_peer_label → %d, \\\"%s\\\" (%m)\",\n                       r, strnull(label4));\n}\n\nstatic void test_create_file_prepare(const char* fname) {\n        int r;\n\n        log_info(\"============ %s ==========\", __func__);\n\n        r = mac_selinux_create_file_prepare(fname, S_IRWXU);\n        log_info_errno(r, \"mac_selinux_create_file_prepare → %d (%m)\", r);\n\n        mac_selinux_create_file_clear();\n}\n\nint main(int argc, char **argv) {\n        const char *path = SYSTEMD_BINARY_PATH;\n        if (argc >= 2)\n                path = argv[1];\n\n        test_setup_logging(LOG_DEBUG);\n\n        test_testing();\n        test_loading();\n        test_misc(path);\n        test_create_file_prepare(path);\n        test_cleanup();\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "10μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "6μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "15622μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "46882μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "23055μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "5944μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "37μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "91556μs",
      "parallelizable_steps": [],
      "critical_path_length": "52832μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 77,
        "complexity_score": 0.25974025974025977
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 77,
        "complexity_score": 0.25974025974025977,
        "content_hash": "ec983b518ebdc80f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-selinux.c"
      }
    },
    "source_hash": "062372a09294"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/hid.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n *  Copyright (c) 1999 Andreas Gal\n *  Copyright (c) 2000-2001 Vojtech Pavlik\n *  Copyright (c) 2006-2007 Jiri Kosina\n */\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n *\n * Should you need to contact me, the author, you can do so either by\n * e-mail - mail your message to <vojtech@ucw.cz>, or by paper mail:\n * Vojtech Pavlik, Simunkova 1594, Prague 8, 182 00 Czech Republic\n */\n#ifndef __HID_H\n#define __HID_H\n\n\n\n/*\n * USB HID (Human Interface Device) interface class code\n */\n\n#define USB_INTERFACE_CLASS_HID\t\t3\n\n/*\n * USB HID interface subclass and protocol codes\n */\n\n#define USB_INTERFACE_SUBCLASS_BOOT\t1\n#define USB_INTERFACE_PROTOCOL_KEYBOARD\t1\n#define USB_INTERFACE_PROTOCOL_MOUSE\t2\n\n/*\n * HID report types --- Ouch! HID spec says 1 2 3!\n */\n\nenum hid_report_type {\n\tHID_INPUT_REPORT\t\t= 0,\n\tHID_OUTPUT_REPORT\t\t= 1,\n\tHID_FEATURE_REPORT\t\t= 2,\n\n\tHID_REPORT_TYPES,\n};\n\n/*\n * HID class requests\n */\n\nenum hid_class_request {\n\tHID_REQ_GET_REPORT\t\t= 0x01,\n\tHID_REQ_GET_IDLE\t\t= 0x02,\n\tHID_REQ_GET_PROTOCOL\t\t= 0x03,\n\tHID_REQ_SET_REPORT\t\t= 0x09,\n\tHID_REQ_SET_IDLE\t\t= 0x0A,\n\tHID_REQ_SET_PROTOCOL\t\t= 0x0B,\n};\n\n/*\n * HID class descriptor types\n */\n\n#define HID_DT_HID\t\t\t(USB_TYPE_CLASS | 0x01)\n#define HID_DT_REPORT\t\t\t(USB_TYPE_CLASS | 0x02)\n#define HID_DT_PHYSICAL\t\t\t(USB_TYPE_CLASS | 0x03)\n\n#define HID_MAX_DESCRIPTOR_SIZE\t\t4096\n\n\n#endif /* __HID_H */\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "246μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "56μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "335612μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "53594μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "69187μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "102249μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "111363μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "57μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "672364μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "516162μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 1.6923076923076925
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 65,
        "complexity_score": 1.6923076923076925,
        "content_hash": "3972eb94c5948287"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/hid.h"
      }
    },
    "source_hash": "1101a89328e7"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-timeouts.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-def.h\"\n#include \"time-util.h\"\n\n/* LLMNR Jitter interval, see RFC 4795 Section 7 */\n#define LLMNR_JITTER_INTERVAL_USEC (100 * USEC_PER_MSEC)\n\n/* mDNS probing interval, see RFC 6762 Section 8.1 */\n#define MDNS_PROBING_INTERVAL_USEC (250 * USEC_PER_MSEC)\n\n/* Maximum attempts to send DNS requests, across all DNS servers */\n#define DNS_TRANSACTION_ATTEMPTS_MAX 24\n\n/* Maximum attempts to send LLMNR requests, see RFC 4795 Section 2.7 */\n#define LLMNR_TRANSACTION_ATTEMPTS_MAX 3\n\n/* Maximum attempts to send MDNS requests, see RFC 6762 Section 8.1 */\n#define MDNS_TRANSACTION_ATTEMPTS_MAX 3\n\n/* Maximum attempts to send an mDNS continuous query.\n *\n * RFC 6762 Section 5.2 does not specify a maximum number of attempts directly.\n * However, it outlines two important guidelines:\n *\n * 1. The interval between the first two queries MUST be at least one second.\n * 2. The intervals between successive queries MUST increase by at least a factor of two.\n *\n * To adhere to these timing requirements for continuous queries,\n * the maximum number of attempts should be set to 1.\n */\n#define MDNS_TRANSACTION_CONTINUOUS_QUERY_MAX 1U\n\nstatic inline unsigned dns_transaction_attempts_max(DnsProtocol p, uint64_t query_flags) {\n        switch (p) {\n\n        case DNS_PROTOCOL_LLMNR:\n                return LLMNR_TRANSACTION_ATTEMPTS_MAX;\n\n        case DNS_PROTOCOL_MDNS:\n                if (FLAGS_SET(query_flags, SD_RESOLVED_QUERY_CONTINUOUS))\n                        return MDNS_TRANSACTION_CONTINUOUS_QUERY_MAX;\n                else\n                        return MDNS_TRANSACTION_ATTEMPTS_MAX;\n\n        default:\n                return DNS_TRANSACTION_ATTEMPTS_MAX;\n        }\n}\n\n/* After how much time to repeat classic DNS requests */\n#define TRANSACTION_UDP_TIMEOUT_USEC (SD_RESOLVED_QUERY_TIMEOUT_USEC / DNS_TRANSACTION_ATTEMPTS_MAX)\n\n/* When we do TCP, grant a much longer timeout, as in this case there's no need for us to quickly\n * resend, as the kernel does that anyway for us, and we really don't want to interrupt it in that\n * needlessly. */\n#define TRANSACTION_TCP_TIMEOUT_USEC (10 * USEC_PER_SEC)\n\n/* Should be longer than transaction timeout for a single UDP transaction, so we get at least\n * one transaction retry before timeouting the whole candidate */\n#define CANDIDATE_EXPEDITED_TIMEOUT_USEC (TRANSACTION_UDP_TIMEOUT_USEC + 1 * USEC_PER_SEC)\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "226μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "306μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "23505μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "71928μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "343353μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "224899μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "155947μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "332μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "820496μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "522805μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.875
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 48,
        "complexity_score": 1.875,
        "content_hash": "6081cc4f1bb4055f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-timeouts.h"
      }
    },
    "source_hash": "55b90439adb8"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-util.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"dns-def.h\"\n#include \"dns-domain.h\"\n#include \"hostname-setup.h\"\n#include \"hostname-util.h\"\n#include \"idn-util.h\"\n#include \"log.h\"\n#include \"resolved-util.h\"\n#include \"utf8.h\"\n\nint resolve_system_hostname(char **full_hostname, char **first_label) {\n        _cleanup_free_ char *h = NULL, *n = NULL;\n#if HAVE_LIBIDN2\n        _cleanup_free_ char *utf8 = NULL;\n#elif HAVE_LIBIDN\n        int k;\n#endif\n        char label[DNS_LABEL_MAX+1];\n        const char *p, *decoded;\n        int r;\n\n        /* Return the full hostname in *full_hostname, if nonnull.\n         *\n         * Extract and normalize the first label of the locally configured hostname, check it's not\n         * \"localhost\", and return it in *first_label, if nonnull. */\n\n        r = gethostname_strict(&h);\n        if (r < 0)\n                return log_debug_errno(r, \"Can't determine system hostname: %m\");\n\n        p = h;\n        r = dns_label_unescape(&p, label, sizeof label, 0);\n        if (r < 0)\n                return log_debug_errno(r, \"Failed to unescape hostname: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"Couldn't find a single label in hostname.\");\n\n#if HAVE_LIBIDN || HAVE_LIBIDN2\n        r = dlopen_idn();\n        if (r < 0) {\n                log_debug_errno(r, \"Failed to initialize IDN support, ignoring: %m\");\n                decoded = label; /* no decoding */\n        } else\n#endif\n        {\n#if HAVE_LIBIDN2\n                r = sym_idn2_to_unicode_8z8z(label, &utf8, 0);\n                if (r != IDN2_OK)\n                        return log_debug_errno(SYNTHETIC_ERRNO(EUCLEAN),\n                                               \"Failed to undo IDNA: %s\", sym_idn2_strerror(r));\n                assert(utf8_is_valid(utf8));\n\n                r = strlen(utf8);\n                decoded = utf8;\n#elif HAVE_LIBIDN\n                k = dns_label_undo_idna(label, r, label, sizeof label);\n                if (k < 0)\n                        return log_debug_errno(k, \"Failed to undo IDNA: %m\");\n                if (k > 0)\n                        r = k;\n\n                if (!utf8_is_valid(label))\n                        return log_debug_errno(SYNTHETIC_ERRNO(EINVAL),\n                                               \"System hostname is not UTF-8 clean.\");\n                decoded = label;\n#else\n                decoded = label; /* no decoding */\n#endif\n        }\n\n        r = dns_label_escape_new(decoded, r, &n);\n        if (r < 0)\n                return log_debug_errno(r, \"Failed to escape hostname: %m\");\n\n        if (is_localhost(n))\n                return log_debug_errno(SYNTHETIC_ERRNO(EINVAL),\n                                       \"System hostname is 'localhost', ignoring.\");\n\n        if (full_hostname)\n                *full_hostname = TAKE_PTR(h);\n        if (first_label)\n                *first_label = TAKE_PTR(n);\n        return 0;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "59μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "15μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "577523μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "2508μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "102μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "61μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "580268μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "577625μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 76,
        "complexity_score": 3.026315789473684
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 76,
        "complexity_score": 3.026315789473684,
        "content_hash": "d3711059f886d58f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-util.c"
      }
    },
    "source_hash": "facdec1b6cb6"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/sd-dns-resolver.h\n\nCode:\n#ifndef SD_DNS_RESOLVER_H\n#define SD_DNS_RESOLVER_H\n\n#include \"_sd-common.h\"\n\n#include \"forward.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dns_resolver sd_dns_resolver;\n\n/* https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids */\ntypedef enum sd_dns_alpn_flags {\n        /* There isn't really an alpn reserved for Do53 service, but designated resolvers may or may not offer\n         * Do53 service, so we should probably have a flag to represent this capability. Unfortunately DNR\n         * does not indicate the status to us. */\n        SD_DNS_ALPN_DO53           = 1 << 0,\n        /* SD_DNS_ALPN_HTTP_1_1,                \"http/1.1\" [RFC9112] */\n        SD_DNS_ALPN_HTTP_2_TLS     = 1 << 1, /* \"h2\"  [RFC9113] [RFC9461] */\n        /* SD_DNS_ALPN_HTTP_2_TCP,              \"h2c\" [RFC9113] */\n        SD_DNS_ALPN_HTTP_3         = 1 << 2, /* \"h3\"  [RFC9114] [RFC9461] */\n        SD_DNS_ALPN_DOT            = 1 << 3, /* \"dot\" [RFC7858] [RFC9461] */\n        SD_DNS_ALPN_DOQ            = 1 << 4, /* \"doq\" [RFC9250] [RFC9461] */\n\n        _SD_ENUM_FORCE_S64(SD_DNS_ALPN)\n} sd_dns_alpn_flags;\n\nint sd_dns_resolver_get_priority(sd_dns_resolver *res, uint16_t *ret_priority);\nint sd_dns_resolver_get_adn(sd_dns_resolver *res, const char **ret_adn);\nint sd_dns_resolver_get_inet_addresses(sd_dns_resolver *res, const struct in_addr **ret_addrs, size_t *n);\nint sd_dns_resolver_get_inet6_addresses(sd_dns_resolver *res, const struct in6_addr **ret_addrs, size_t *n);\nint sd_dns_resolver_get_alpn(sd_dns_resolver *res, sd_dns_alpn_flags *ret_alpn);\nint sd_dns_resolver_get_port(sd_dns_resolver *res, uint16_t *ret_port);\nint sd_dns_resolver_get_dohpath(sd_dns_resolver *res, const char **ret_dohpath);\n\nsd_dns_resolver *sd_dns_resolver_unref(sd_dns_resolver *res);\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dns_resolver, sd_dns_resolver_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif /* SD_DNS_RESOLVER_H */\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "330μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "81μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "190570μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "48965μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "95μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "75μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "240116μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "190665μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 1.935483870967742
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 31,
        "complexity_score": 1.935483870967742,
        "content_hash": "96c4f6e70f8fe2aa"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/sd-dns-resolver.h"
      }
    },
    "source_hash": "0c2717ef1e6d"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/sbat.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#ifdef SBAT_DISTRO\n#  include \"version.h\"\n#  define SBAT_MAGIC \"sbat,1,SBAT Version,sbat,1,https://github.com/rhboot/shim/blob/main/SBAT.md\\n\"\n#  define SBAT_BOOT_SECTION_TEXT \\\n        SBAT_MAGIC \\\n        SBAT_PROJECT \"-boot\" \",1,The systemd Developers,\" SBAT_PROJECT \",\" PROJECT_VERSION \",\" PROJECT_URL \"\\n\" \\\n        SBAT_PROJECT \"-boot\" \".\" SBAT_DISTRO \",\" STRINGIFY(SBAT_DISTRO_GENERATION) \",\" SBAT_DISTRO_SUMMARY \",\" SBAT_DISTRO_PKGNAME \",\" SBAT_DISTRO_VERSION \",\" SBAT_DISTRO_URL \"\\n\"\n#  define SBAT_STUB_SECTION_TEXT \\\n        SBAT_MAGIC \\\n        SBAT_PROJECT \"-stub\" \",1,The systemd Developers,\" SBAT_PROJECT \",\" PROJECT_VERSION \",\" PROJECT_URL \"\\n\" \\\n        SBAT_PROJECT \"-stub\" \".\" SBAT_DISTRO \",\" STRINGIFY(SBAT_DISTRO_GENERATION) \",\" SBAT_DISTRO_SUMMARY \",\" SBAT_DISTRO_PKGNAME \",\" SBAT_DISTRO_VERSION \",\" SBAT_DISTRO_URL \"\\n\"\n#endif\n\n#ifdef SBAT_DISTRO\n#  define DECLARE_SBAT(text) DECLARE_NOALLOC_SECTION(\".sbat\", text)\n#  define DECLARE_SBAT_PADDED(text) DECLARE_NOALLOC_SECTION_PADDED(\".sbat\", text)\n#else\n#  define DECLARE_SBAT(text)\n#  define DECLARE_SBAT_PADDED(text)\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "198μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "1310819μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "770μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "1414μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "45436μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "280μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1358917μs",
      "parallelizable_steps": [],
      "critical_path_length": "1312513μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 3.5
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 20,
        "complexity_score": 3.5,
        "content_hash": "2770a5867f10243c"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/sbat.h"
      }
    },
    "source_hash": "3e17af4f0ec6"
  },
  {
    "instruction": "Analyze and break down this async_networking code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/fdset.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n#include \"iterator.h\"\n\nFDSet* fdset_new(void);\nFDSet* fdset_free(FDSet *s);\nFDSet* fdset_free_async(FDSet *s);\n\nint fdset_put(FDSet *s, int fd);\nint fdset_consume(FDSet *s, int fd);\nint fdset_put_dup(FDSet *s, int fd);\n\nbool fdset_contains(FDSet *s, int fd);\nint fdset_remove(FDSet *s, int fd);\n\nint fdset_new_array(FDSet **ret, const int *fds, size_t n_fds);\nint fdset_new_fill(int filter_cloexec, FDSet **ret);\nint fdset_new_listen_fds(FDSet **ret, bool unset);\n\nint fdset_cloexec(FDSet *fds, bool b);\n\nint fdset_to_array(FDSet *fds, int **ret);\n\nint fdset_close_others(FDSet *fds);\n\nunsigned fdset_size(FDSet *fds);\nbool fdset_isempty(FDSet *fds);\n\nint fdset_iterate(FDSet *s, Iterator *i);\n\nint fdset_steal_first(FDSet *fds);\n\nvoid fdset_close(FDSet *fds, bool async);\n\n#define _FDSET_FOREACH(fd, fds, i) \\\n        for (Iterator i = ITERATOR_FIRST; ((fd) = fdset_iterate((fds), &i)) >= 0; )\n#define FDSET_FOREACH(fd, fds) \\\n        _FDSET_FOREACH(fd, fds, UNIQ_T(i, UNIQ))\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free);\n#define _cleanup_fdset_free_ _cleanup_(fdset_freep)\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(FDSet*, fdset_free_async);\n",
    "output": {
      "operation": "Async Networking Implementation",
      "category": "async_networking",
      "steps": [
        {
          "step": 1,
          "action": "Initialize event loop",
          "expected_time": "319μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Create async context manager",
          "expected_time": "288μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Schedule multiple coroutines",
          "expected_time": "440μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": true,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Handle concurrent I/O operations",
          "expected_time": "265863μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Aggregate results from coroutines",
          "expected_time": "537μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cleanup async resources and event loop",
          "expected_time": "519μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "267966μs",
      "parallelizable_steps": [
        3,
        4
      ],
      "critical_path_length": "266670μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "async_networking",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 3.0,
        "content_hash": "4d35916a30a2b923"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/fdset.h"
      },
      "variation": true
    },
    "source_hash": "b73cab1e3368"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/libsystemd-network/fuzz-lldp-rx.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include \"sd-event.h\"\n#include \"sd-json.h\"\n#include \"sd-lldp-rx.h\"\n\n#include \"fd-util.h\"\n#include \"fuzz.h\"\n#include \"lldp-network.h\"\n#include \"lldp-rx-internal.h\"\n#include \"memstream-util.h\"\n\nstatic int test_fd[2] = EBADF_PAIR;\n\nint lldp_network_bind_raw_socket(int ifindex) {\n        if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0, test_fd) < 0)\n                return -errno;\n\n        return test_fd[0];\n}\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_(sd_event_unrefp) sd_event *e = NULL;\n        _cleanup_(sd_lldp_rx_unrefp) sd_lldp_rx *lldp_rx = NULL;\n        _cleanup_(sd_json_variant_unrefp) sd_json_variant *v = NULL;\n        _cleanup_(memstream_done) MemStream m = {};\n        FILE *f;\n\n        if (outside_size_range(size, 0, 2048))\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(sd_event_new(&e) == 0);\n        assert_se(sd_lldp_rx_new(&lldp_rx) >= 0);\n        assert_se(sd_lldp_rx_set_ifindex(lldp_rx, 42) >= 0);\n        assert_se(sd_lldp_rx_attach_event(lldp_rx, e, 0) >= 0);\n        assert_se(sd_lldp_rx_start(lldp_rx) >= 0);\n\n        assert_se(write(test_fd[1], data, size) == (ssize_t) size);\n        assert_se(sd_event_run(e, 0) >= 0);\n\n        assert_se(lldp_rx_build_neighbors_json(lldp_rx, &v) >= 0);\n        assert_se(f = memstream_init(&m));\n        (void) sd_json_variant_dump(v, SD_JSON_FORMAT_PRETTY|SD_JSON_FORMAT_COLOR, f, NULL);\n\n        assert_se(sd_lldp_rx_stop(lldp_rx) >= 0);\n        assert_se(sd_lldp_rx_detach_event(lldp_rx) >= 0);\n        test_fd[1] = safe_close(test_fd[1]);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "41μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "110μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "21367μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "103315μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "69837μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "316878μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "69μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "511617μs",
      "parallelizable_steps": [],
      "critical_path_length": "420303μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 41,
        "complexity_score": 1.707317073170732,
        "content_hash": "b5cdb818324a69c6"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/libsystemd-network/fuzz-lldp-rx.c"
      }
    },
    "source_hash": "9ddbf63f9d36"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: tools/make-autosuspend-rules.py\n\nCode:\n#!/usr/bin/env python3\n# SPDX-License-Identifier: LGPL-2.1-or-later\n\n# Generate autosuspend rules for devices that have been tested to work properly\n# with autosuspend by the Chromium OS team. Based on\n# https://chromium.googlesource.com/chromiumos/platform2/+/master/power_manager/udev/gen_autosuspend_rules.py\n\nimport chromiumos.gen_autosuspend_rules\n\nprint('# pci:v<00VENDOR>d<00DEVICE> (8 uppercase hexadecimal digits twice)')\nfor entry in chromiumos.gen_autosuspend_rules.PCI_IDS:\n    vendor, device = entry.split(':')\n    vendor = int(vendor, 16)\n    device = int(device, 16)\n    print(f'pci:v{vendor:08X}d{device:08X}*')\n\nprint('# usb:v<VEND>p<PROD> (4 uppercase hexadecimal digits twice)')\nfor entry in chromiumos.gen_autosuspend_rules.USB_IDS:\n    vendor, product = entry.split(':')\n    vendor = int(vendor, 16)\n    product = int(product, 16)\n    print(f'usb:v{vendor:04X}p{product:04X}*')\n\nprint(' ID_AUTOSUSPEND=1')\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "542μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "15892μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "3914μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "896μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "363151μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "755μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "385150μs",
      "parallelizable_steps": [],
      "critical_path_length": "367607μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [
          "chromiumos.gen_autosuspend_rules"
        ],
        "lines_of_code": 19,
        "complexity_score": 5.263157894736842
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [
          "chromiumos.gen_autosuspend_rules"
        ],
        "lines_of_code": 19,
        "complexity_score": 5.263157894736842,
        "content_hash": "c7b4d6340806d237"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "tools/make-autosuspend-rules.py"
      }
    },
    "source_hash": "113e4aa94d47"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/systemd/sd-dhcp-server-lease.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#ifndef foosddhcpserverleasehfoo\n#define foosddhcpserverleasehfoo\n\n/***\n  systemd is free software; you can redistribute it and/or modify it\n  under the terms of the GNU Lesser General Public License as published by\n  the Free Software Foundation; either version 2.1 of the License, or\n  (at your option) any later version.\n\n  systemd is distributed in the hope that it will be useful, but\n  WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public License\n  along with systemd; If not, see <https://www.gnu.org/licenses/>.\n***/\n\n#include \"_sd-common.h\"\n\n_SD_BEGIN_DECLARATIONS;\n\ntypedef struct sd_dhcp_server_lease sd_dhcp_server_lease;\n\nsd_dhcp_server_lease *sd_dhcp_server_lease_ref(sd_dhcp_server_lease *lease);\nsd_dhcp_server_lease *sd_dhcp_server_lease_unref(sd_dhcp_server_lease *lease);\n\n_SD_DEFINE_POINTER_CLEANUP_FUNC(sd_dhcp_server_lease, sd_dhcp_server_lease_unref);\n\n_SD_END_DECLARATIONS;\n\n#endif\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1563μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "790312μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "1057μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "809μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "459502μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "1223μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1254466μs",
      "parallelizable_steps": [],
      "critical_path_length": "792344μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 23,
        "complexity_score": 4.3478260869565215
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 23,
        "complexity_score": 4.3478260869565215,
        "content_hash": "228ff38a1cdd496d"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/systemd/sd-dhcp-server-lease.h"
      }
    },
    "source_hash": "b914ed7a2d08"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-delegate.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"list.h\"\n#include \"resolved-forward.h\"\n\n#define DELEGATE_SEARCH_DOMAINS_MAX 1024\n#define DELEGATE_DNS_SERVERS_MAX 256\n\n/* A DnsDelegate object is used to manage additional, explicitly configured unicast DNS lookup scopes,\n * independent from any network link and from the global scope. */\n\ntypedef struct DnsDelegate {\n        Manager *manager;\n        char *id;\n\n        LIST_HEAD(DnsServer, dns_servers);\n        unsigned n_dns_servers;\n        DnsServer *current_dns_server;\n\n        LIST_HEAD(DnsSearchDomain, search_domains);\n        unsigned n_search_domains;\n\n        int default_route;\n\n        DnsScope *scope;\n\n        LIST_FIELDS(DnsDelegate, delegates);\n} DnsDelegate;\n\nint dns_delegate_new(Manager *m, const char *id, DnsDelegate **ret);\nDnsDelegate *dns_delegate_free(DnsDelegate *d);\n\nDEFINE_TRIVIAL_CLEANUP_FUNC(DnsDelegate*, dns_delegate_free);\n\nDnsServer* dns_delegate_set_dns_server(DnsDelegate *d, DnsServer *s);\nDnsServer *dns_delegate_get_dns_server(DnsDelegate *d);\nvoid dns_delegate_next_dns_server(DnsDelegate *d, DnsServer *if_current);\n\nint manager_load_delegates(Manager *m);\n\nconst struct ConfigPerfItem* resolved_dns_delegate_gperf_lookup(const char *key, GPERF_LEN_TYPE length);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_delegate_dns_servers);\nCONFIG_PARSER_PROTOTYPE(config_parse_delegate_domains);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "35μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "45μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "2880μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "49923μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "111μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "44μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "53038μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "50012μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 1.0
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 30,
        "complexity_score": 1.0,
        "content_hash": "3743df6e29fb4eb2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-delegate.h"
      }
    },
    "source_hash": "360c1c24efd2"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/resolved-dns-synthesize.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"resolved-forward.h\"\n\nint dns_synthesize_family(uint64_t flags);\nDnsProtocol dns_synthesize_protocol(uint64_t flags);\n\nint dns_synthesize_answer(Manager *m, DnsQuestion *q, int ifindex, DnsAnswer **ret);\n\nbool shall_synthesize_own_hostname_rrs(void);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "764μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "160μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "588255μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "320119μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "604μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "68μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "909970μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "588859μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 4.285714285714286
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 7,
        "complexity_score": 4.285714285714286,
        "content_hash": "22b4cdad09766f8f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/resolved-dns-synthesize.h"
      }
    },
    "source_hash": "7be0a560f91b"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/networkd-ndisc.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <netinet/in.h>\n\n#include \"dns-resolver-internal.h\"\n#include \"networkd-forward.h\"\n\ntypedef enum IPv6AcceptRAStartDHCP6Client {\n        IPV6_ACCEPT_RA_START_DHCP6_CLIENT_NO,\n        IPV6_ACCEPT_RA_START_DHCP6_CLIENT_ALWAYS,\n        IPV6_ACCEPT_RA_START_DHCP6_CLIENT_YES,\n        _IPV6_ACCEPT_RA_START_DHCP6_CLIENT_MAX,\n        _IPV6_ACCEPT_RA_START_DHCP6_CLIENT_INVALID = -EINVAL,\n} IPv6AcceptRAStartDHCP6Client;\n\ntypedef struct NDiscRDNSS {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        struct in6_addr address;\n} NDiscRDNSS;\n\ntypedef struct NDiscDNSSL {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        /* The domain name follows immediately. */\n} NDiscDNSSL;\n\ntypedef struct NDiscCaptivePortal {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        char *captive_portal;\n} NDiscCaptivePortal;\n\ntypedef struct NDiscPREF64 {\n        struct in6_addr router;\n        /* This is an absolute point in time, and NOT a timespan/duration.\n         * Must be specified with CLOCK_BOOTTIME. */\n        usec_t lifetime_usec;\n        uint8_t prefix_len;\n        struct in6_addr prefix;\n} NDiscPREF64;\n\ntypedef struct NDiscDNR {\n        struct in6_addr router;\n        usec_t lifetime_usec;\n        sd_dns_resolver resolver;\n} NDiscDNR;\n\nchar* ndisc_dnssl_domain(const NDiscDNSSL *n);\n\nbool link_ndisc_enabled(Link *link);\n\nvoid network_adjust_ndisc(Network *network);\n\nint ndisc_start(Link *link);\nint ndisc_stop(Link *link);\nvoid ndisc_flush(Link *link);\n\nint link_request_ndisc(Link *link);\nint link_drop_ndisc_config(Link *link, Network *network);\nint ndisc_reconfigure_address(Address *address, Link *link);\n\nCONFIG_PARSER_PROTOTYPE(config_parse_ndisc_start_dhcp6_client);\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "506μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "128μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "306943μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "522653μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "61μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "11μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "830302μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "522792μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 2.6785714285714284
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 2.6785714285714284,
        "content_hash": "016332232358df3b"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/networkd-ndisc.h"
      }
    },
    "source_hash": "3c8fad649d2c"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/basic/mkdir.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"forward.h\"\n\ntypedef enum MkdirFlags {\n        MKDIR_FOLLOW_SYMLINK  = 1 << 0,\n        MKDIR_IGNORE_EXISTING = 1 << 1,  /* Quietly accept a preexisting directory (or file) */\n        MKDIR_WARN_MODE       = 1 << 2,  /* Log at LOG_WARNING when mode doesn't match */\n} MkdirFlags;\n\nint mkdirat_errno_wrapper(int dirfd, const char *pathname, mode_t mode);\n\nint mkdirat_safe(int dir_fd, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags);\nstatic inline int mkdir_safe(const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags) {\n        return mkdirat_safe(AT_FDCWD, path, mode, uid, gid, flags);\n}\nint mkdirat_parents(int dir_fd, const char *path, mode_t mode);\nstatic inline int mkdir_parents(const char *path, mode_t mode) {\n        return mkdirat_parents(AT_FDCWD, path, mode);\n}\nint mkdir_parents_safe(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags);\nint mkdir_p(const char *path, mode_t mode);\nint mkdir_p_safe(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags);\nint mkdir_p_root_full(const char *root, const char *p, uid_t uid, gid_t gid, mode_t m, usec_t ts, char **subvolumes);\nstatic inline int mkdir_p_root(const char *root, const char *p, uid_t uid, gid_t gid, mode_t m) {\n        return mkdir_p_root_full(root, p, uid, gid, m, USEC_INFINITY, NULL);\n}\n\n/* The following are used to implement the mkdir_xyz_label() calls, don't use otherwise. */\ntypedef int (*mkdirat_func_t)(int dir_fd, const char *pathname, mode_t mode);\nint mkdirat_safe_internal(int dir_fd, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir);\nstatic inline int mkdir_safe_internal(const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir) {\n        return mkdirat_safe_internal(AT_FDCWD, path, mode, uid, gid, flags, _mkdir);\n}\nint mkdirat_parents_internal(int dir_fd, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdirat);\nint mkdir_parents_internal(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir);\nint mkdir_p_internal(const char *prefix, const char *path, mode_t mode, uid_t uid, gid_t gid, MkdirFlags flags, mkdirat_func_t _mkdir);\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "38μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "10μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "79444μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "738μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "38218μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "50178μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "17μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "168643μs",
      "parallelizable_steps": [],
      "critical_path_length": "117717μs",
      "metadata": {
        "functions_found": [
          "int"
        ],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [
          "int"
        ],
        "classes": [],
        "imports": [],
        "lines_of_code": 33,
        "complexity_score": 0.6060606060606061,
        "content_hash": "726313c814f3d5e2"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/basic/mkdir.h"
      }
    },
    "source_hash": "81b234a8a22d"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netdevice.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n * INET\t\tAn implementation of the TCP/IP protocol suite for the LINUX\n *\t\toperating system.  INET is implemented using the  BSD Socket\n *\t\tinterface as the means of communication with the user level.\n *\n *\t\tDefinitions for the Interfaces handler.\n *\n * Version:\t@(#)dev.h\t1.0.10\t08/12/93\n *\n * Authors:\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\t\tCorey Minyard <wf-rch!minyard@relay.EU.net>\n *\t\tDonald J. Becker, <becker@cesdis.gsfc.nasa.gov>\n *\t\tAlan Cox, <alan@lxorguk.ukuu.org.uk>\n *\t\tBjorn Ekwall. <bj0rn@blox.se>\n *              Pekka Riikonen <priikone@poseidon.pspt.fi>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\t\tMoved to /usr/include/linux for NET3\n */\n#ifndef _LINUX_NETDEVICE_H\n#define _LINUX_NETDEVICE_H\n\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_packet.h>\n#include <linux/if_link.h>\n\n\n#define MAX_ADDR_LEN\t32\t\t/* Largest hardware address length */\n\n/* Initial net device group. All devices belong to group 0 by default. */\n#define INIT_NETDEV_GROUP\t0\n\n\n/* interface name assignment types (sysfs name_assign_type attribute) */\n#define NET_NAME_UNKNOWN\t0\t/* unknown origin (not exposed to userspace) */\n#define NET_NAME_ENUM\t\t1\t/* enumerated by kernel */\n#define NET_NAME_PREDICTABLE\t2\t/* predictably named by the kernel */\n#define NET_NAME_USER\t\t3\t/* provided by user-space */\n#define NET_NAME_RENAMED\t4\t/* renamed by user-space */\n\n/* Media selection options. */\nenum {\n        IF_PORT_UNKNOWN = 0,\n        IF_PORT_10BASE2,\n        IF_PORT_10BASET,\n        IF_PORT_AUI,\n        IF_PORT_100BASET,\n        IF_PORT_100BASETX,\n        IF_PORT_100BASEFX\n};\n\n/* hardware address assignment types */\n#define NET_ADDR_PERM\t\t0\t/* address is permanent (default) */\n#define NET_ADDR_RANDOM\t\t1\t/* address is generated randomly */\n#define NET_ADDR_STOLEN\t\t2\t/* address is stolen from other device */\n#define NET_ADDR_SET\t\t3\t/* address is set using\n\t\t\t\t\t * dev_set_mac_address() */\n\n#endif /* _LINUX_NETDEVICE_H */\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "106μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "149μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "3771μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "511432μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "378970μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "549528μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "123μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1444079μs",
      "parallelizable_steps": [],
      "critical_path_length": "1061109μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.508771929824561
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 57,
        "complexity_score": 3.508771929824561,
        "content_hash": "d214e0a5596e1df7"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netdevice.h"
      }
    },
    "source_hash": "bc4cbb317aaf"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/daemon-util.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include \"sd-daemon.h\" /* IWYU pragma: export */\n\n#include \"forward.h\"\n\n#define NOTIFY_READY_MESSAGE \"READY=1\\n\" \"STATUS=Processing requests...\"\n#define NOTIFY_STOPPING_MESSAGE \"STOPPING=1\\n\" \"STATUS=Shutting down...\"\n\nstatic inline const char* notify_start(const char *start, const char *stop) {\n        if (start)\n                (void) sd_notify(false, start);\n\n        return stop;\n}\n\n/* This is intended to be used with _cleanup_ attribute. */\nstatic inline void notify_on_cleanup(const char **p) {\n        if (*p)\n                (void) sd_notify(false, *p);\n}\n\nint notify_remove_fd_warn(const char *name);\nint notify_remove_fd_warnf(const char *format, ...) _printf_(1, 2);\nint close_and_notify_warn(int fd, const char *name);\nint notify_push_fd(int fd, const char *name);\nint notify_push_fdf(int fd, const char *format, ...) _printf_(2, 3);\n\nint notify_reloading_full(const char *status);\nstatic inline int notify_reloading(void) {\n        return notify_reloading_full(\"Reloading configuration...\");\n}\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "1166μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "750μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "612800μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "798146μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "428108μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "903672μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "587685μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "1311μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "3333638μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "1703879μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 8.4
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 8.4,
        "content_hash": "23a893eda50791c7"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/daemon-util.h"
      }
    },
    "source_hash": "390e7e99a340"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/test/test-sha1.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"hexdecoct.h\"\n#include \"sha1-fundamental.h\"\n#include \"tests.h\"\n\nstatic void sha1_process_string(const char *key, struct sha1_ctx *ctx) {\n        sha1_process_bytes(key, strlen(key), ctx);\n}\n\nstatic void test_sha1_one(const char *key, const char *expect) {\n        uint8_t result[SHA1_DIGEST_SIZE + 3];\n        _cleanup_free_ char *str = NULL;\n        struct sha1_ctx ctx;\n\n        log_debug(\"\\\"%s\\\" → %s\", key, expect);\n\n        assert_se(str = new(char, strlen(key) + 4));\n\n        /* This tests unaligned buffers. */\n\n        for (size_t i = 0; i < 4; i++) {\n                strcpy(str + i, key);\n\n                for (size_t j = 0; j < 4; j++) {\n                        _cleanup_free_ char *hex_result = NULL;\n\n                        sha1_init_ctx(&ctx);\n                        sha1_process_string(str + i, &ctx);\n                        sha1_finish_ctx(&ctx, result + j);\n\n                        hex_result = hexmem(result + j, SHA1_DIGEST_SIZE);\n                        ASSERT_STREQ(hex_result, expect);\n                }\n        }\n}\n\n/* From https://datatracker.ietf.org/doc/html/rfc3174#section-7.3 */\n#define TEST1   \"abc\"\n#define RESULT1 \"a9993e364706816aba3e25717850c26c9cd0d89d\"\n#define TEST2   \"abcdbcdecdefdefgefghfghighijhi\" \"jkijkljklmklmnlmnomnopnopq\"\n#define RESULT2 \"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n#define TEST3   \"a\"\n#define RESULT3 \"86f7e437faa5a7fce15d1ddcb9eaeaea377667b8\"\n#define TEST4   \"01234567012345670123456701234567\" \"01234567012345670123456701234567\"\n#define RESULT4 \"e0c094e867ef46c350ef54a7f59dd60bed92ae83\"\n\nTEST(sha1) {\n        /* Results compared with output of 'echo -n \"<input>\" | sha1sum -' */\n\n        test_sha1_one(TEST1, RESULT1);\n        test_sha1_one(TEST2, RESULT2);\n        test_sha1_one(TEST3, RESULT3);\n        test_sha1_one(TEST4, RESULT4);\n}\n\nDEFINE_TEST_MAIN(LOG_INFO);\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "88μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "55478μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "148μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "206μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "18841μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "305μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "75066μs",
      "parallelizable_steps": [],
      "critical_path_length": "55989μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.9302325581395349
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 43,
        "complexity_score": 0.9302325581395349,
        "content_hash": "9060d4b6c2575a19"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/test/test-sha1.c"
      }
    },
    "source_hash": "bfd4afcf1c22"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/shared/bpf-dlopen.h\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n#pragma once\n\n#include <syslog.h>\n\n#if HAVE_LIBBPF\n\n#include <bpf/bpf.h>    /* IWYU pragma: export */\n#include <bpf/libbpf.h> /* IWYU pragma: export */\n\n#include \"bpf-compat.h\" /* IWYU pragma: export */\n#include \"dlfcn-util.h\"\n#include \"forward.h\"\n\nextern DLSYM_PROTOTYPE(bpf_link__destroy);\nextern DLSYM_PROTOTYPE(bpf_link__fd);\nextern DLSYM_PROTOTYPE(bpf_link__open);\nextern DLSYM_PROTOTYPE(bpf_link__pin);\nextern DLSYM_PROTOTYPE(bpf_map__fd);\nextern DLSYM_PROTOTYPE(bpf_map__name);\nextern DLSYM_PROTOTYPE(bpf_map__set_inner_map_fd);\nextern DLSYM_PROTOTYPE(bpf_map__set_max_entries);\nextern DLSYM_PROTOTYPE(bpf_map__set_pin_path);\nextern DLSYM_PROTOTYPE(bpf_map_delete_elem);\nextern DLSYM_PROTOTYPE(bpf_map_get_fd_by_id);\nextern DLSYM_PROTOTYPE(bpf_map_lookup_elem);\nextern DLSYM_PROTOTYPE(bpf_map_update_elem);\n/* The *_skeleton APIs are autogenerated by bpftool, the targets can be found\n * in ./build/src/core/bpf/socket-bind/socket-bind.skel.h */\nextern DLSYM_PROTOTYPE(bpf_object__attach_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__destroy_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__detach_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__load_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__name);\nextern DLSYM_PROTOTYPE(bpf_object__open_skeleton);\nextern DLSYM_PROTOTYPE(bpf_object__pin_maps);\nextern DLSYM_PROTOTYPE(bpf_program__attach);\nextern DLSYM_PROTOTYPE(bpf_program__attach_cgroup);\nextern DLSYM_PROTOTYPE(bpf_program__attach_lsm);\nextern DLSYM_PROTOTYPE(bpf_program__name);\nextern DLSYM_PROTOTYPE(libbpf_set_print);\nextern DLSYM_PROTOTYPE(ring_buffer__epoll_fd);\nextern DLSYM_PROTOTYPE(ring_buffer__free);\nextern DLSYM_PROTOTYPE(ring_buffer__new);\nextern DLSYM_PROTOTYPE(ring_buffer__poll);\n\n/* libbpf sometimes returns error codes that make sense only in the kernel, like 524 for EOPNOTSUPP. Use\n * this helper instead of libbpf_get_error() to ensure some of the known ones are translated into errnos\n * we understand. */\nint bpf_get_error_translated(const void *ptr);\n\n#endif\n\nint dlopen_bpf_full(int log_level);\nstatic inline int dlopen_bpf(void) {\n        return dlopen_bpf_full(LOG_DEBUG);\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "38μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "23μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "24827μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "126486μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "745μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "80083μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "64μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "232266μs",
      "parallelizable_steps": [],
      "critical_path_length": "206592μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 1.0204081632653061
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 49,
        "complexity_score": 1.0204081632653061,
        "content_hash": "c843f67b8231fb7f"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/shared/bpf-dlopen.h"
      }
    },
    "source_hash": "170c977e7186"
  },
  {
    "instruction": "Analyze and decompose this network_security code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/fundamental/uki.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <stddef.h>\n\n#include \"uki.h\"\n\nconst char* const unified_sections[_UNIFIED_SECTION_MAX + 1] = {\n        /* These section names must fit in 8ch (excluding any trailing NUL) as per PE spec for executables:\n         * https://learn.microsoft.com/en-us/windows/win32/debug/pe-format#section-table-section-headers\n         * (Note that PE *object* files may have longer section names (via indirection in the string table) but\n         * this is not allowed for PE *executables*, which UKIs are.) */\n        [UNIFIED_SECTION_LINUX]   = \".linux\",\n        [UNIFIED_SECTION_OSREL]   = \".osrel\",\n        [UNIFIED_SECTION_CMDLINE] = \".cmdline\",\n        [UNIFIED_SECTION_INITRD]  = \".initrd\",\n        [UNIFIED_SECTION_UCODE]   = \".ucode\",\n        [UNIFIED_SECTION_SPLASH]  = \".splash\",\n        [UNIFIED_SECTION_DTB]     = \".dtb\",\n        [UNIFIED_SECTION_UNAME]   = \".uname\",\n        [UNIFIED_SECTION_SBAT]    = \".sbat\",\n        [UNIFIED_SECTION_PCRSIG]  = \".pcrsig\",\n        [UNIFIED_SECTION_PCRPKEY] = \".pcrpkey\",\n        [UNIFIED_SECTION_PROFILE] = \".profile\",\n        [UNIFIED_SECTION_DTBAUTO] = \".dtbauto\",\n        [UNIFIED_SECTION_HWIDS]   = \".hwids\",\n        [UNIFIED_SECTION_EFIFW]   = \".efifw\",\n        NULL,\n};\n",
    "output": {
      "operation": "Network Security Implementation",
      "category": "network_security",
      "steps": [
        {
          "step": 1,
          "action": "Initialize SSL/TLS context",
          "expected_time": "1960μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Load certificates and private keys",
          "expected_time": "3649307μs",
          "resource": "I/O",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Perform certificate chain validation",
          "expected_time": "5775μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            1
          ]
        },
        {
          "step": 4,
          "action": "Execute cryptographic handshake",
          "expected_time": "2651μs",
          "resource": "CPU",
          "criticality": "critical",
          "parallelizable": false,
          "dependencies": [
            0,
            2
          ]
        },
        {
          "step": 5,
          "action": "Establish secure communication channel",
          "expected_time": "979214μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Encrypt/decrypt data packets",
          "expected_time": "2263μs",
          "resource": "CPU",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "4641170μs",
      "parallelizable_steps": [],
      "critical_path_length": "3654221μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 9.200000000000001
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "network_security",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 25,
        "complexity_score": 9.200000000000001,
        "content_hash": "ced735ce2e1aa243"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/fundamental/uki.c"
      }
    },
    "source_hash": "41b5a4a6e9db"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/resolve/fuzz-resource-record.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"sd-json.h\"\n\n#include \"fuzz.h\"\n#include \"memstream-util.h\"\n#include \"resolved-dns-packet.h\"\n#include \"resolved-dns-rr.h\"\n#include \"string-util.h\"\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n        _cleanup_(dns_resource_record_unrefp) DnsResourceRecord *rr = NULL, *copy = NULL;\n        _cleanup_(sd_json_variant_unrefp) sd_json_variant *v = NULL;\n        _cleanup_(memstream_done) MemStream m = {};\n        FILE *f;\n\n        if (outside_size_range(size, 0, DNS_PACKET_SIZE_MAX))\n                return 0;\n\n        if (dns_resource_record_new_from_raw(&rr, data, size) < 0)\n                return 0;\n\n        fuzz_setup_logging();\n\n        assert_se(copy = dns_resource_record_copy(rr));\n        assert_se(dns_resource_record_equal(copy, rr) > 0);\n\n        assert_se(f = memstream_init(&m));\n        (void) fprintf(f, \"%s\", strna(dns_resource_record_to_string(rr)));\n\n        assert_se(dns_resource_record_to_json(rr, &v) >= 0);\n        assert_se(sd_json_variant_dump(v, SD_JSON_FORMAT_PRETTY|SD_JSON_FORMAT_COLOR|SD_JSON_FORMAT_SOURCE, f, NULL) >= 0);\n        assert_se(dns_resource_record_to_wire_format(rr, false) >= 0);\n        assert_se(dns_resource_record_to_wire_format(rr, true) >= 0);\n\n        return 0;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "585μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "92μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "76858μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "41229μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "483μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "23μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "119270μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "77341μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 2.962962962962963
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 27,
        "complexity_score": 2.962962962962963,
        "content_hash": "d8facec6ec36a0e1"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/resolve/fuzz-resource-record.c"
      }
    },
    "source_hash": "b6f9a52fafed"
  },
  {
    "instruction": "Analyze and decompose this dns_resolution code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/network/test-network-tables.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include <net/if.h>\n\n#include \"sd-dhcp-lease.h\"\n\n#include \"bond-util.h\"\n#include \"dhcp6-protocol.h\"\n#include \"ethtool-util.h\"\n#include \"ipvlan-util.h\"\n#include \"lldp-rx-internal.h\"\n#include \"macvlan-util.h\"\n#include \"ndisc-internal.h\"\n#include \"networkd-dns.h\"\n#include \"networkd-lldp-rx.h\"\n#include \"networkd-radv.h\"\n#include \"networkd-sysctl.h\"\n#include \"test-tables.h\"\n#include \"tests.h\"\n#include \"tunnel.h\"\n\nint main(int argc, char **argv) {\n        test_setup_logging(LOG_DEBUG);\n\n        test_table(BondAdSelect, bond_ad_select, NETDEV_BOND_AD_SELECT);\n        test_table(BondArpAllTargets, bond_arp_all_targets, NETDEV_BOND_ARP_ALL_TARGETS);\n        test_table(BondArpValidate, bond_arp_validate, NETDEV_BOND_ARP_VALIDATE);\n        test_table(BondFailOverMac, bond_fail_over_mac, NETDEV_BOND_FAIL_OVER_MAC);\n        test_table(BondLacpRate, bond_lacp_rate, NETDEV_BOND_LACP_RATE);\n        test_table(BondMode, bond_mode, NETDEV_BOND_MODE);\n        test_table(BondPrimaryReselect, bond_primary_reselect, NETDEV_BOND_PRIMARY_RESELECT);\n        test_table(BondXmitHashPolicy, bond_xmit_hash_policy, NETDEV_BOND_XMIT_HASH_POLICY);\n        test_table(DHCP6Status, dhcp6_message_status, DHCP6_STATUS);\n        test_table_sparse(DHCP6MessageType, dhcp6_message_type, DHCP6_MESSAGE_TYPE); /* enum starts from 1 */\n        test_table(UseDomains, use_domains, USE_DOMAINS);\n        test_table(Duplex, duplex, DUP);\n        test_table(TunnelMode, tunnel_mode, TUNNEL_MODE);\n        test_table(IPv6PrivacyExtensions, ipv6_privacy_extensions, IPV6_PRIVACY_EXTENSIONS);\n        test_table(IPVlanFlags, ipvlan_flags, NETDEV_IPVLAN_FLAGS);\n        test_table(LinkOperationalState, link_operstate, LINK_OPERSTATE);\n        /* test_table(link_state, LINK_STATE);  — not a reversible mapping */\n        test_table(LLDPMode, lldp_mode, LLDP_MODE);\n        test_table(NetDevKind, netdev_kind, NETDEV_KIND);\n        test_table(RADVPrefixDelegation, radv_prefix_delegation, RADV_PREFIX_DELEGATION);\n        test_table(sd_lldp_rx_event_t, lldp_rx_event, SD_LLDP_RX_EVENT);\n        test_table(sd_ndisc_event_t, ndisc_event, SD_NDISC_EVENT);\n        test_table(sd_dhcp_lease_server_type_t, dhcp_lease_server_type, SD_DHCP_LEASE_SERVER_TYPE);\n\n        test_table_sparse(IPVlanMode, ipvlan_mode, NETDEV_IPVLAN_MODE);\n        test_table_sparse(MacVlanMode, macvlan_mode, NETDEV_MACVLAN_MODE);\n        test_table_sparse(AddressFamily, address_family, ADDRESS_FAMILY);\n\n        assert_cc(sizeof(sd_lldp_rx_event_t) == sizeof(int64_t));\n        assert_cc(sizeof(sd_ndisc_event_t) == sizeof(int64_t));\n        assert_cc(sizeof(sd_dhcp_lease_server_type_t) == sizeof(int64_t));\n\n        return EXIT_SUCCESS;\n}\n",
    "output": {
      "operation": "Dns Resolution Implementation",
      "category": "dns_resolution",
      "steps": [
        {
          "step": 1,
          "action": "Parse and validate domain name",
          "expected_time": "41μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Check local DNS cache",
          "expected_time": "9μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Query configured DNS resolver",
          "expected_time": "11814μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Handle recursive DNS resolution",
          "expected_time": "28582μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Parse DNS response packets",
          "expected_time": "53μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Cache DNS results",
          "expected_time": "20μs",
          "resource": "MEMORY",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "40519μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "28611μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 0.4
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "dns_resolution",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 50,
        "complexity_score": 0.4,
        "content_hash": "b8650a9bd1025767"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/network/test-network-tables.c"
      }
    },
    "source_hash": "54087255dc29"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/if_vlan.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */\n/*\n * VLAN\t\tAn implementation of 802.1Q VLAN tagging.\n *\n * Authors:\tBen Greear <greearb@candelatech.com>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n */\n\n#ifndef _LINUX_IF_VLAN_H_\n#define _LINUX_IF_VLAN_H_\n\n\n/* VLAN IOCTLs are found in sockios.h */\n\n/* Passed in vlan_ioctl_args structure to determine behaviour. */\nenum vlan_ioctl_cmds {\n\tADD_VLAN_CMD,\n\tDEL_VLAN_CMD,\n\tSET_VLAN_INGRESS_PRIORITY_CMD,\n\tSET_VLAN_EGRESS_PRIORITY_CMD,\n\tGET_VLAN_INGRESS_PRIORITY_CMD,\n\tGET_VLAN_EGRESS_PRIORITY_CMD,\n\tSET_VLAN_NAME_TYPE_CMD,\n\tSET_VLAN_FLAG_CMD,\n\tGET_VLAN_REALDEV_NAME_CMD, /* If this works, you know it's a VLAN device, btw */\n\tGET_VLAN_VID_CMD /* Get the VID of this VLAN (specified by name) */\n};\n\nenum vlan_flags {\n\tVLAN_FLAG_REORDER_HDR\t\t= 0x1,\n\tVLAN_FLAG_GVRP\t\t\t= 0x2,\n\tVLAN_FLAG_LOOSE_BINDING\t\t= 0x4,\n\tVLAN_FLAG_MVRP\t\t\t= 0x8,\n\tVLAN_FLAG_BRIDGE_BINDING\t= 0x10,\n};\n\nenum vlan_name_types {\n\tVLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */\n\tVLAN_NAME_TYPE_RAW_PLUS_VID, /* name will look like:  eth1.0005 */\n\tVLAN_NAME_TYPE_PLUS_VID_NO_PAD, /* Name will look like:  vlan5 */\n\tVLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD, /* Name will look like:  eth0.5 */\n\tVLAN_NAME_TYPE_HIGHEST\n};\n\nstruct vlan_ioctl_args {\n\tint cmd; /* Should be one of the vlan_ioctl_cmds enum above. */\n\tchar device1[24];\n\n        union {\n\t\tchar device2[24];\n\t\tint VID;\n\t\tunsigned int skb_priority;\n\t\tunsigned int name_type;\n\t\tunsigned int bind_type;\n\t\tunsigned int flag; /* Matches vlan_dev_priv flags */\n        } u;\n\n\tshort vlan_qos;   \n};\n\n#endif /* _LINUX_IF_VLAN_H_ */\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "291μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "109μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "123588μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "214825μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "64030μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "28325μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "64162μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "202μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "495532μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "251780μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.7857142857142858
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 56,
        "complexity_score": 1.7857142857142858,
        "content_hash": "37e4ce89343c0d97"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/if_vlan.h"
      }
    },
    "source_hash": "692889ea3ca4"
  },
  {
    "instruction": "Analyze and decompose this socket_programming code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/journal/journald-wall.c\n\nCode:\n/* SPDX-License-Identifier: LGPL-2.1-or-later */\n\n#include \"alloc-util.h\"\n#include \"format-util.h\"\n#include \"journald-manager.h\"\n#include \"journald-wall.h\"\n#include \"log.h\"\n#include \"process-util.h\"\n#include \"string-util.h\"\n#include \"wall.h\"\n\nvoid manager_forward_wall(\n                Manager *m,\n                int priority,\n                const char *identifier,\n                const char *message,\n                const struct ucred *ucred) {\n\n        _cleanup_free_ char *ident_buf = NULL, *l_buf = NULL;\n        const char *l;\n        int r;\n\n        assert(m);\n        assert(message);\n\n        if (LOG_PRI(priority) > m->config.max_level_wall)\n                return;\n\n        if (ucred) {\n                if (!identifier) {\n                        (void) pid_get_comm(ucred->pid, &ident_buf);\n                        identifier = ident_buf;\n                }\n\n                if (asprintf(&l_buf, \"%s[\"PID_FMT\"]: %s\", strempty(identifier), ucred->pid, message) < 0) {\n                        log_oom();\n                        return;\n                }\n\n                l = l_buf;\n\n        } else if (identifier) {\n\n                l = l_buf = strjoin(identifier, \": \", message);\n                if (!l_buf) {\n                        log_oom();\n                        return;\n                }\n        } else\n                l = message;\n\n        r = wall(l, \"systemd-journald\", NULL, NULL, NULL);\n        if (r < 0)\n                log_debug_errno(r, \"Failed to send wall message: %m\");\n}\n",
    "output": {
      "operation": "Socket Programming Implementation",
      "category": "socket_programming",
      "steps": [
        {
          "step": 1,
          "action": "Create socket object",
          "expected_time": "197μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Configure socket options",
          "expected_time": "42μs",
          "resource": "CPU",
          "criticality": "low",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Bind socket to address and port",
          "expected_time": "90753μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            0,
            1
          ]
        },
        {
          "step": 4,
          "action": "Listen for incoming connections",
          "expected_time": "498875μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Accept client connection",
          "expected_time": "276113μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Send/receive data packets",
          "expected_time": "352380μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Handle connection cleanup and close",
          "expected_time": "170μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        }
      ],
      "complexity": "high",
      "estimated_total_time": "1218530μs",
      "parallelizable_steps": [],
      "critical_path_length": "851297μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 44,
        "complexity_score": 3.6363636363636367
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "socket_programming",
      "complexity": "high",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 44,
        "complexity_score": 3.6363636363636367,
        "content_hash": "9c3a0908359657e9"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/journal/journald-wall.c"
      }
    },
    "source_hash": "7a534a913d45"
  },
  {
    "instruction": "Analyze and decompose this http_requests code from a production repository",
    "input": "Repository: https://github.com/systemd/systemd\nFile: src/include/uapi/linux/netfilter/nfnetlink_compat.h\n\nCode:\n/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */\n#ifndef _NFNETLINK_COMPAT_H\n#define _NFNETLINK_COMPAT_H\n\n#include <linux/types.h>\n\n/* Old nfnetlink macros for userspace */\n\n/* nfnetlink groups: Up to 32 maximum */\n#define NF_NETLINK_CONNTRACK_NEW \t\t0x00000001\n#define NF_NETLINK_CONNTRACK_UPDATE\t\t0x00000002\n#define NF_NETLINK_CONNTRACK_DESTROY\t\t0x00000004\n#define NF_NETLINK_CONNTRACK_EXP_NEW\t\t0x00000008\n#define NF_NETLINK_CONNTRACK_EXP_UPDATE\t\t0x00000010\n#define NF_NETLINK_CONNTRACK_EXP_DESTROY\t0x00000020\n\n/* Generic structure for encapsulation optional netfilter information.\n * It is reminiscent of sockaddr, but with sa_family replaced\n * with attribute type.\n * ! This should someday be put somewhere generic as now rtnetlink and\n * ! nfnetlink use the same attributes methods. - J. Schulist.\n */\n\nstruct nfattr {\n\t__u16 nfa_len;\n\t__u16 nfa_type;\t/* we use 15 bits for the type, and the highest\n\t\t\t\t * bit to indicate whether the payload is nested */\n};\n\n/* FIXME: Apart from NFNL_NFA_NESTED shamelessly copy and pasted from\n * rtnetlink.h, it's time to put this in a generic file */\n\n#define NFNL_NFA_NEST\t0x8000\n#define NFA_TYPE(attr) \t((attr)->nfa_type & 0x7fff)\n\n#define NFA_ALIGNTO     4\n#define NFA_ALIGN(len)\t(((len) + NFA_ALIGNTO - 1) & ~(NFA_ALIGNTO - 1))\n#define NFA_OK(nfa,len)\t((len) > 0 && (nfa)->nfa_len >= sizeof(struct nfattr) \\\n\t&& (nfa)->nfa_len <= (len))\n#define NFA_NEXT(nfa,attrlen)\t((attrlen) -= NFA_ALIGN((nfa)->nfa_len), \\\n\t(struct nfattr *)(((char *)(nfa)) + NFA_ALIGN((nfa)->nfa_len)))\n#define NFA_LENGTH(len)\t(NFA_ALIGN(sizeof(struct nfattr)) + (len))\n#define NFA_SPACE(len)\tNFA_ALIGN(NFA_LENGTH(len))\n#define NFA_DATA(nfa)   ((void *)(((char *)(nfa)) + NFA_LENGTH(0)))\n#define NFA_PAYLOAD(nfa) ((int)((nfa)->nfa_len) - NFA_LENGTH(0))\n#define NFA_NEST(skb, type) \\\n({\tstruct nfattr *__start = (struct nfattr *)skb_tail_pointer(skb); \\\n\tNFA_PUT(skb, (NFNL_NFA_NEST | type), 0, NULL); \\\n\t__start;  })\n#define NFA_NEST_END(skb, start) \\\n({      (start)->nfa_len = skb_tail_pointer(skb) - (unsigned char *)(start); \\\n        (skb)->len; })\n#define NFA_NEST_CANCEL(skb, start) \\\n({      if (start) \\\n                skb_trim(skb, (unsigned char *) (start) - (skb)->data); \\\n        -1; })\n\n#define NFM_NFA(n)      ((struct nfattr *)(((char *)(n)) \\\n        + NLMSG_ALIGN(sizeof(struct nfgenmsg))))\n#define NFM_PAYLOAD(n)  NLMSG_PAYLOAD(n, sizeof(struct nfgenmsg))\n\n#endif /* _NFNETLINK_COMPAT_H */\n",
    "output": {
      "operation": "Http Requests Implementation",
      "category": "http_requests",
      "steps": [
        {
          "step": 1,
          "action": "Parse URL and extract components",
          "expected_time": "231μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 2,
          "action": "Prepare request headers and payload",
          "expected_time": "392μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": []
        },
        {
          "step": 3,
          "action": "Resolve DNS for hostname",
          "expected_time": "408811μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": true,
          "dependencies": []
        },
        {
          "step": 4,
          "action": "Establish TCP connection",
          "expected_time": "119593μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            2
          ]
        },
        {
          "step": 5,
          "action": "Send HTTP request",
          "expected_time": "392302μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            3
          ]
        },
        {
          "step": 6,
          "action": "Receive HTTP response headers",
          "expected_time": "148645μs",
          "resource": "I/O",
          "criticality": "high",
          "parallelizable": false,
          "dependencies": [
            4
          ]
        },
        {
          "step": 7,
          "action": "Receive and buffer response body",
          "expected_time": "85530μs",
          "resource": "I/O",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            5
          ]
        },
        {
          "step": 8,
          "action": "Parse response and handle status codes",
          "expected_time": "248μs",
          "resource": "CPU",
          "criticality": "medium",
          "parallelizable": false,
          "dependencies": [
            6
          ]
        }
      ],
      "complexity": "extreme",
      "estimated_total_time": "1155752μs",
      "parallelizable_steps": [
        3
      ],
      "critical_path_length": "886643μs",
      "metadata": {
        "functions_found": [],
        "classes_found": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154
      }
    },
    "metadata": {
      "source": "github_repository",
      "category": "http_requests",
      "complexity": "extreme",
      "code_analysis": {
        "functions": [],
        "classes": [],
        "imports": [],
        "lines_of_code": 52,
        "complexity_score": 2.1153846153846154,
        "content_hash": "d7a122ec93ce932a"
      },
      "repo_context": {
        "repo": "https://github.com/systemd/systemd",
        "file_path": "src/include/uapi/linux/netfilter/nfnetlink_compat.h"
      }
    },
    "source_hash": "4f4c31c87c3a"
  }
]